angular.module('gettext').run(['gettextCatalog', function (gettextCatalog) {
/* jshint -W100 */
    gettextCatalog.setStrings('en', {"(preview)":"(preview)","« Previous":"&laquo; Previous","<span translate=\"\">\n                €<% result.value=\"\" |=\"\" number:=\"\" 2%=\"\"> | Download\n              </%></span>":"<span translate=\"\">\n                €<% result.value=\"\" |=\"\" number:=\"\" 2%=\"\"> | Download\n              </%></span>","<span translate=\"\">Statistics</span>":"<span translate=\"\">Statistics</span>","€<% result.value=\"\" |=\"\" number:=\"\" 2%=\"\"> | Download\n              </%>":"€<% result.value=\"\" |=\"\" number:=\"\" 2%=\"\"> | Download\n              </%>","3di resultaten":"3di resultaten","Add an annotation":"Add an annotation","Add an attachment:":"Add an attachment:","Add data…\n        <div class=\"layer-chooser-tools\">\n          <i class=\"fa fa-plus\"></i>\n        </div>":"Add data&hellip;\n        <div class=\"layer-chooser-tools\">\n          <i class=\"fa fa-plus\"></i>\n        </div>","Adjust opacity":"Adjust opacity","Annotation attachment size cannot be bigger than 10MB.":"Annotation attachment size cannot be bigger than 10MB.","Annotation message...":"Annotation message...","Annotation text cannot be longer than 256 characters.":"Annotation text cannot be longer than 256 characters.","Annotation text is required.":"Annotation text is required.","Aquifer confinement":"Aquifer confinement","Assets":"Assets","Ay ay: Lizard could not retrieve your favourite":"Ay ay: Lizard could not retrieve your favourite","Baselayer":"Baselayer","Bosom channel":"Bosom channel","Bottom level":"Bottom level","Bottom level manhole":"Bottom level manhole","Bridge":"Bridge","Capacity":"Capacity","Category":"Category","Channel":"Channel","Close data menu":"Close data menu","Close result window":"Close result window","Close timeline":"Close timeline","Coating":"Coating","Code":"Code","Construction year":"Construction year","Control":"Control","Crest height":"Crest height","Crest level":"Crest level","Crest Level":"Crest Level","Crest width":"Crest width","Crossprofile":"Crossprofile","Culvert":"Culvert","Dashboard":"Dashboard","Dashed line":"Dashed line","Delete this annotation from the database.":"Delete this annotation from the database.","Diameter":"Diameter","Distance along cross section":"Distance along cross section","Double click for lizard version number":"Double click for lizard version number","Download":"Download","Download attachment.":"Download attachment.","Duration":"Duration","Edit profile":"Edit profile","Elevation along crosssection (source: AHN2).":"Elevation along crosssection (source: AHN2).","End":"End","End of current timeline":"End of current timeline","Ended (simulation time)":"Ended (simulation time)","Example value":"Example value","Export":"Export","Export data":"Export data","Export info card data":"Export info card data","Favourite name cannot be longer than 256 characters.":"Favourite name cannot be longer than 256 characters.","Favourite name is required.":"Favourite name is required.","Favourites":"Favourites","Filter":"Filter","Filter bottom level":"Filter bottom level","Filter top level":"Filter top level","Frequency":"Frequency","Go to the present in timeline":"Go to the present in timeline","Green line":"Green line","Grey dots":"Grey dots","Groundwater station":"Groundwater station","Height":"Height","Help":"Help","indicative interpolation of hydraulic head in the same aquifer.":"indicative interpolation of hydraulic head in the same aquifer.","Invert level end point":"Invert level end point","Invert level start point":"Invert level start point","Length":"Length","Levee":"Levee","Levee cross section":"Levee cross section","Levee reference point":"Levee reference point","Line selection":"Line selection","Litology":"Litology","Locations":"Locations","Log in":"Log in","Log out":"Log out","Make time relative (sticky to the end)":"Make time relative (sticky to the end)","Manhole":"Manhole","Manhole id":"Manhole id","Map":"Map","Material":"Material","Measured hydraulic head at current time.":"Measured hydraulic head at current time.","Measuring station":"Measuring station","mm":"mm","mm / 5 min":"mm / 5 min","mm / day":"mm / day","mm / hour":"mm / hour","mm / month":"mm / month","Modify profile":"Modify profile","Monitoring well":"Monitoring well","Name":"Name","New favourite name...":"New favourite name...","Next »":"Next &raquo;","No data available for this location":"No data available for this location","No raster data available for this geometry":"No raster data available for this geometry","No results":"No results","No timeseries available for this asset":"No timeseries available for this asset","One annotation":["One annotation","<% $count %> annotations"],"Oops! Something went wrong while creating the annotation.":"Oops! Something went wrong while creating the annotation.","Oops! Something went wrong while creating the favourite.":"Oops! Something went wrong while creating the favourite.","Oops! Something went wrong while deleting the annotation.":"Oops! Something went wrong while deleting the annotation.","Oops! Something went wrong while deleting the favourite.":"Oops! Something went wrong while deleting the favourite.","Oops! Something went wrong while fetching the favourites.":"Oops! Something went wrong while fetching the favourites.","Oops! Something went wrong while fetching the layers.":"Oops! Something went wrong while fetching the layers.","Oops! Something went wrong while fetching your organisations.":"Oops! Something went wrong while fetching your organisations.","Open data menu":"Open data menu","Open timeline":"Open timeline","Open water level (average)":"Open water level (average)","Orifice":"Orifice","Outlet":"Outlet","Overflow":"Overflow","Pipe":"Pipe","Play/pause":"Play/pause","Point selection":"Point selection","Pressure pipe":"Pressure pipe","Primary channel":"Primary channel","Pump":"Pump","Pump station":"Pump station","Question and manual":"Question and manual","Rain":"Rain","Rain recurrence statistics":"Rain recurrence statistics","Recurrence times (RT)":"Recurrence times (RT)","Region selection":"Region selection","Restoring favourite":"Restoring favourite","RT (years)":"RT (years)","Screen view":"Screen view","Search for places, or dates (i.e. 23-10-2013)":"Search for places, or dates (i.e. 23-10-2013)","Select an organisation:":"Select an organisation:","Select Multiple Points":"Select Multiple Points","Shape":"Shape","Sluice":"Sluice","Start":"Start","Start animation":"Start animation","Start level":"Start level","Start of current timeline":"Start of current timeline","Started (simulation time)":"Started (simulation time)","Statistics":"Statistics","Stop animation":"Stop animation","Stop level":"Stop level","Surface level":"Surface level","Switch to dashboard":"Switch to dashboard","Switch to map":"Switch to map","The 'now' of the timeline":"The 'now' of the timeline","Time":"Time","Timeseries":"Timeseries","Top level":"Top level","Type":"Type","View selection":"View selection","Wastewater treatment plant":"Wastewater treatment plant","Weir":"Weir","Well bottom level":"Well bottom level","Well top level":"Well top level","Whoops: favourite has been removed":"Whoops: favourite has been removed","Width":"Width","You don't have any favourites yet.<br>\nAdd the current portal state to your favourites!":"You don't have any favourites yet.<br>\nAdd the current portal state to your favourites!","Zoom in on the map":"Zoom in on the map","Zoom in on timeline":"Zoom in on timeline","Zoom out of timeline":"Zoom out of timeline","Zoom out on the map":"Zoom out on the map"});
    gettextCatalog.setStrings('nl', {"(preview)":"(preview)","« Previous":"&laquo; Vorige","<span translate=\"\">\n                €<% result.value=\"\" |=\"\" number:=\"\" 2%=\"\"> | Download\n              </%></span>":"<span translate=\"\">\n€<% result.value=\"\" |=\"\" number:=\"\" 2%=\"\"> | Download\n</%></span>","<span translate=\"\">Statistics</span>":"<span translate=\"\">Statistieken</span>","€<% result.value=\"\" |=\"\" number:=\"\" 2%=\"\"> | Download\n              </%>":"€<% result.value=\"\" |=\"\" number:=\"\" 2%=\"\"> | Download\n</%>","3di resultaten":"3di resultaten","Add an annotation":"Voeg een annotatie toe","Add an attachment:":"Voeg een bijlage toe:","Add data…\n        <div class=\"layer-chooser-tools\">\n          <i class=\"fa fa-plus\"></i>\n        </div>":"Toevoegen&hellip;\n<div class=\"layer-chooser-tools\">\n<i class=\"fa fa-plus\"></i>\n</div>","Adjust opacity":"Transparantie aanpassen","Annotation attachment size cannot be bigger than 10MB.":"Bijlage van annotatie mag niet groter zijn dan 10MB.","Annotation message...":"Annotatie bericht...","Annotation text cannot be longer than 256 characters.":"Annotatie mag niet langer zijn dan 256 tekens.","Annotation text is required.":"Annotatietekst is vereist.","Aquifer confinement":"Watervoerend pakket","Assets":"Assets","Ay ay: Lizard could not retrieve your favourite":"Bliksem: Lizard kon je favoriet niet vinden","Baselayer":"Basislaag","Bosom channel":"Boezemkanaal","Bottom level":"Onderkant buis","Bottom level manhole":"Putbodem","Bridge":"Brug","Capacity":"Capaciteit","Category":"Categorie","Channel":"Watergang","Close data menu":"Sluit het datamenu","Close result window":"Sluit het resultatenvenster","Close timeline":"Sluit de tijdlijn","Coating":"Bekleding","Code":"Code","Construction year":"Bouwjaar","Control":"Bediening","Crest height":"Kruinhoogte","Crest level":"Overstorthoogte","Crest Level":"Niveau","Crest width":"Overstortbreedte","Crossprofile":"Dwarsprofiel","Culvert":"Duiker","Dashboard":"Dashboard","Dashed line":"Stippellijn","Delete this annotation from the database.":"Verwijder deze annotatie uit de database.","Diameter":"Diameter","Distance along cross section":"Afstand langs dwarsdoorsnede","Double click for lizard version number":"Dubbelklikken voor lizard versienummer","Download":"Download","Download attachment.":"Bijlage downloaden.","Duration":"Duur","Edit profile":"Profiel bewerken","Elevation along crosssection (source: AHN2).":"Maaiveldhoogte langs dwarsprofiel (bron: AHN2).","End":"Einde","End of current timeline":"Einde van de huidige tijdlijn","Ended (simulation time)":"Einde (simulatie tijd)","Example value":"Voorbeeldwaarde","Export":"Exporteer","Export data":"Exporteer","Export info card data":"Exporteer infocard data","Favourite name cannot be longer than 256 characters.":"Naam van favoriet mag niet langer zijn dan 256 karakters.","Favourite name is required.":"Naam van favoriet is vereist.","Favourites":"Favorieten","Filter":"Filter","Filter bottom level":"Onderkant filter","Filter top level":"Bovenkant filter","Frequency":"Frequentie","Go to the present in timeline":"Ga naar het heden in de tijdlijn","Green line":"Groene lijn","Grey dots":"Grijze punten","Groundwater station":"Grondwatermeetpunt","Height":"Hoogte","Help":"Help","indicative interpolation of hydraulic head in the same aquifer.":"Indicatieve interpolatie van stijghoogte in hetzelfde watervoerend pakket.","Invert level end point":"BOB eindpunt","Invert level start point":"BOB beginpunt","Length":"Lengte","Levee":"Kering","Levee cross section":"Dijkdwarsdoorsnede","Levee reference point":"Keringreferentiepunt","Line selection":"Lijnselectie","Litology":"Lithologie","Locations":"Locaties","Log in":"Inloggen","Log out":"Uitloggen","Make time relative (sticky to the end)":"Maak tijd relatief (t.o.v. het nu)","Manhole":"Put","Manhole id":"Put id","Map":"Kaart","Material":"Materiaal","Measured hydraulic head at current time.":"Huidige gemeten stijghoogte.","Measuring station":"Meetstation","mm":"mm","mm / 5 min":"mm / 5 min","mm / day":"mm / dag","mm / hour":"mm / uur","mm / month":"mm / maand","Modify profile":"Profiel aanpassen","Monitoring well":"Waterspanningsmeter","Name":"Naam","New favourite name...":"Nieuwe naam van favoriet...","Next »":"Volgende &raquo;","No data available for this location":"Geen data beschikbaar voor deze locatie","No raster data available for this geometry":"Geen raster data beschikbaar voor deze geometrie","No results":"Geen resultaten","No timeseries available for this asset":"Geen tijdreeksen beschikbaar voor dit object","One annotation":["Eén annotatie","<% $count %> annotaties"],"Oops! Something went wrong while creating the annotation.":"Oeps! Er is iets misgegaan bij het aanmaken van de annotatie.","Oops! Something went wrong while creating the favourite.":"Oeps! Er is iets misgegaan bij het aanmaken van de favoriet.","Oops! Something went wrong while deleting the annotation.":"Oeps! Er is iets misgegaan bij het verwijderen van de annotatie.","Oops! Something went wrong while deleting the favourite.":"Oeps! Er is iets misgegaan bij het verwijderen van de favoriet.","Oops! Something went wrong while fetching the favourites.":"Oeps! Er is iets misgegaan bij het ophalen van de favorieten.","Oops! Something went wrong while fetching the layers.":"Oeps! Er is iets misgegaan bij het ophalen van de lagen.","Oops! Something went wrong while fetching your organisations.":"Oeps! Er is iets misgegaan bij het ophalen van uw organisaties.","Open data menu":"Open het datamenu","Open timeline":"Open de tijdlijn","Open water level (average)":"Buitenwaterstand (gemiddeld)","Orifice":"Doorlaat","Outlet":"Uitlaat","Overflow":"Overstort","Pipe":"Leiding","Play/pause":"Play/pauze","Point selection":"Puntselectie","Pressure pipe":"Persleiding","Primary channel":"Primaire watergang","Pump":"Pomp","Pump station":"Gemaal","Question and manual":"Vragen en handleiding","Rain":"Regen","Rain recurrence statistics":"Neerslagstatistiek","Recurrence times (RT)":"Herhalingstijden (HT)","Region selection":"Regio selectie","Restoring favourite":"Favoriet aan het terugzetten","RT (years)":"HT (jaren)","Screen view":"Schermoverzicht","Search for places, or dates (i.e. 23-10-2013)":"Zoek naar plaatsen of data (bv. 23-10-2013)","Select an organisation:":"Selecteer een organisatie:","Select Multiple Points":"Selecteer Meerdere Punten","Shape":"Vorm","Sluice":"Sluis","Start":"Start","Start animation":"Start animatie","Start level":"Aanslagpeil","Start of current timeline":"Start van de huidige tijdlijn","Started (simulation time)":"Start (simulatie tijd)","Statistics":"Statistieken","Stop animation":"Stop animatie","Stop level":"Afslagpeil","Surface level":"Maaiveldhoogte","Switch to dashboard":"Schakel naar dashboard","Switch to map":"Schakel naar kaart","The 'now' of the timeline":"Het 'nu' van de tijdlijn","Time":"Tijd","Timeseries":"Tijdreeksen","Top level":"Bovenkant buis","Type":"Type","View selection":"Schermselectie","Wastewater treatment plant":"Afvalwaterzuivering","Weir":"Stuw","Well bottom level":"Onderkant put","Well top level":"Bovenkant put","Whoops: favourite has been removed":"Oeps: favoriet is verwijderd.","Width":"Breedte","You don't have any favourites yet.<br>\nAdd the current portal state to your favourites!":"U heeft nog geen favorieten.<br>\nVoeg de huidige status van het portaal toe aan uw favorieten!","Zoom in on the map":"Zoom in op de kaart","Zoom in on timeline":"Zoom in op de tijdlijn","Zoom out of timeline":"Zoom uit van de tijdlijn","Zoom out on the map":"Zoom uit van de kaart"});
    gettextCatalog.setStrings('vi', {});
/* jshint +W100 */
}]);
'use strict';

/**
 * Setup Raven if available.
 * Raven is responsible for logging to https://sentry.lizard.net
 */
if (window.RavenEnvironment) {
  window.Raven.config(window.RavenEnvironment, {
    ignoreUrls: [/localhost/]
  }).install();
  if (window.user.authenticated) {
    window.Raven.setUserContext({
      username: window.user.userName
    });
  }
}

/**
 * Configure Angular's $resource to not strip trailing slashes.
 */
angular.module('ngResource').config([
  '$resourceProvider', function($resourceProvider) {
    $resourceProvider.defaults.stripTrailingSlashes = false;
  }
]);

/**
 * Initialise angular.module('lizard-nxt')
 *
 */
angular.module("lizard-nxt", [
  'lizard-nxt-filters',
  'ngAnimate',
  'annotations',
  'data-menu',
  'map',
  'omnibox',
  'dashboard',
  'scenarios',
  'user-menu',
  'favourites',
  'global-state',
  'ngSanitize',
  'ngCsv',
  'gettext',
  'timeseries',
  'lodash',
  'ui.bootstrap',
  'lizard-http-throttler', // Add this $http interceptor befor the loading-bar.
  'angular-loading-bar'
])

// Decorator for ngExceptionHandler to log exceptions to sentry
.config(function ($provide) {
  $provide.decorator("$exceptionHandler", function ($delegate) {
    return function (exception, cause) {
      $delegate(exception, cause);
      window.Raven.captureException(exception, {
        extra: {cause: cause}
      });
    };
  });
})

.config(['$compileProvider', function ($compileProvider) {
  $compileProvider.debugInfoEnabled(false);
}])

/**
 * Change default angular tags to prevent collision with Django tags.
 */
.config(function ($interpolateProvider) {
  //To prevent Django and Angular Template hell
  $interpolateProvider.startSymbol('<%');
  $interpolateProvider.endSymbol('%>');
})

/**
 * Set url fragment behavior to HTML5 mode (without hash in url).
 */
.config(function ($locationProvider) {
  // We want to release to gh-pages for demo purposes or whatever
  // But github.io doesn't rewrite the urls beautifully like we do.
  var html5Mode = (window.location.host !== 'nens.github.io' &&
                   window.location.host !== 'lizard.sandbox.lizard.net');
  $locationProvider.html5Mode(html5Mode);
})

// Configure loading indicator.
.config(['cfpLoadingBarProvider', function (cfpLoadingBarProvider) {
  // Only show bar, no spinner.
  cfpLoadingBarProvider.includeSpinner = false;
  // Default is 100, but Lizard is not for impatient teenagers, so 250 is ok.
  cfpLoadingBarProvider.latencyThreshold = 250;
  }
])

/**
 * @name user
 * @memberOf app
 * @description User and auth stuff
 */
.constant('user', window.user)

/**
 * @name notie
 * @memberOf app
 * @description Notification service
 */
.constant('notie', window.notie)

/**
 * @name versioning
 * @memberOf app
 * @description User and auth stuff
 */
.constant('versioning', window.versioning)

/**
 * @name production backend
 * @memberOf app
 * @description subdomain of production backend.
 */
.constant('backendDomain', 'https://demo.lizard.net')

/**
 * @name locale
 * @memberOf app
 * @description Portal's default locale.
 */
.constant('defaultLocale', window.locale)

/**
 * @name temporalBounds
 * @memberOf app
 * @description Portal's default temporal bounds.
 */
.constant('temporalBounds', window.temporalBounds);


/**
 *
 * @name MasterController
 * @class MasterCtrl
 * @memberOf app
 *
 * @summary Master controller
 *
 * @description Binds logic and attributes to the global $scope. Keep
 *              this clean and put stuff in specific component controllers
 *              if it is not global.
 *
 */
angular.module('lizard-nxt')
  .controller('MasterCtrl',

  ['$scope',
   '$rootScope',
   '$timeout',
   'CabinetService',
   'UtilService',
   'ClickFeedbackService',
   'versioning',
   'State',
   'MapService',
   'rmAllButLastAssetAndGeometry',

  function ($scope,
            $rootScope,
            $timeout,
            CabinetService,
            UtilService,
            ClickFeedbackService,
            versioning,
            State,
            MapService,
            rmAllButLastAssetAndGeometry) {

  $scope.versioning = versioning;
  $scope.tooltips = CabinetService.createTooltips();

  // When the language changes we remake the tooltips for the current language.
  $scope.$on('gettextLanguageChanged', function () {
    $scope.tooltips = CabinetService.createTooltips();
  });

  // CONTEXT

  /**
   * Switch between contexts.
   *
   * @param {string} context - Context name to switch to
   */
  $scope.transitionToContext = function (context) {
    if (context !== State.context) {
      State.context = context;
      if (State.context === 'map' && State.box.type === 'point') {
        rmAllButLastAssetAndGeometry();
      }
    }
    var overlay = angular.element('#context-transition-overlay')[0];
    overlay.style.transition = null;
    overlay.style.minHeight = window.innerHeight + 'px';
    $rootScope.context = State.context;
    $timeout(function () {
      overlay.style.transition = 'ease .3s';
      overlay.style.opacity = 1;
    }, 10);
    $timeout(function () {
      overlay.style.opacity = 0;
    }, 300);
    $timeout(function () {
      overlay.style.transition = null;
      overlay.style.minHeight = 0;
    }, 600, true);
  };

  $scope.$watch(State.toString('context'), function () {
    $scope.transitionToContext(State.context);
  });

  $scope.toggleDashboard = function () {
    $scope.transitionToContext(($scope.context === 'map') ? 'dashboard' : 'map');
  };

  // END CONTEXT

  $scope.toggleVersionVisibility = function () {
    $('.navbar-version').toggle();
  };

  UtilService.preventOldIEUsage();

  // catch window.load event
  window.addEventListener("load", function () {
    window.loaded = true;
  });
}]);


/**
 * $http interceptor to prevent rapid fire of slow requests such as timeseries.
 *
 * Intercepts all $http request to throttle when specified with a custom timeout
 * promise.
 *
 * Depends on lodash throttle and $q.
 */
angular.module('lizard-http-throttler', [])
.config(['$httpProvider', function ($httpProvider) {

  $httpProvider.interceptors.push(function($q) {

    var WAIT = 1000; // Max two request every second.
    var throttles = {};
    var timeouts = {};

    return {
      request: function(config) {

        var timeout = config.timeout;
        // Only intercept when $http is called with custom timeout.
        if (!timeout) { return config; }

        // To prevent loading bar waiting for requests never firing, set ignore
        // to true and back to false when fired by throttle.
        config.ignoreLoadingBar = true;

        // Store timeout synchronously.
        timeouts[config.url] = timeout;

        // Create config promise for $http.
        var promise = $q.defer();

        // Create throttle function if necessary
        if (!throttles[config.url]) {
          throttles[config.url] = _.throttle(function (config, defer) {

            // Throttle function fires asynchronously but requires timeout of
            // last request.
            config.timeout = timeouts[config.url];
            // This request will actually fire, so stop ignoring it, and show
            // loading bar.
            config.ignoreLoadingBar = false;
            // Start $http request.
            defer.resolve(config);
          }, WAIT);
        }

        // Call throttled function.
        throttles[config.url](config, promise);

        // $http takes a promise which ignites request when resolved.
        return promise.promise;
      }
    };
  });
}]);


'use strict';

/**
 * @class Resource
 * @memberof lizard-nxt
 * @description Helper functions for getting data from places
 */
angular.module('lizard-nxt')
  .service('Resource', ['$http', function ($http) {

  this.baseUrl = '';

  /**
   * @function
   * @description sets Base url of resource (application wide)
   * @params {string} baseurl e.g. https://demo.lizard.net/
   */
  this.setBaseUrl = function (baseUrl) {
    this.baseUrl = baseUrl;
  };

  /**
   * @functtion
   * @description makes an url based on base url and the url param
   * @params {string} url e.g. api/v2/search/
   * @params {string} baseurl - optional e.g. https://demo.lizard.net/
   */
  this.makeUrl = function (url, baseUrl) {
    if (baseUrl) {
      return baseUrl + url;
    } else {
      return this.baseUrl + url;
    }
  };

  this.options = {};

  /**
   * @function
   * @description sets $http settings application wide like default Headers
   * @params {object} - options object e.g. {withCredentials: true}
   */
  this.setDefaultHttpFields = function (options) {
    this.options = angular.extend(this.options, options);
  };

  /**
   * @function
   * @description helper function for options that $http uses
   * @params {string} url - e.g. 'api/v2/timeseries/'
   * @params {object} params - url parameters e.g. {q: 'this-is-a-query-param'}
   * @params {string} method - HTTP method e.g. 'PUT'
   */
  this.buildOptions = function (url, params, method) {
    var options = angular.copy(this.options);
    angular.extend(options, {
      url: this.makeUrl(url),
      method: (method) ? method : 'GET',
      params: params
    });

    return options;
  };

  var self = this;

  /**
   * @memberof Resource
   * @class Endpoint
   * @description Wrapper for $http to do stuff on the REST API
   */
  this.Endpoint = function (url, resourceOptions) {
    this.url = url;

    /**
     * @function
     * @description GET method on rest api
     */
    this.get = function (params, httpOptions) {
      var newUrl = self.makeUrl(this.url, this.baseUrl);
      var options = self.buildOptions(newUrl, params, 'GET');

      if (httpOptions) {
        angular.extend(options, httpOptions);
      }

      if (resourceOptions) {
        angular.extend(options, resourceOptions);
      }

      return $http(options)
        .then(function (response) {
          return response.data;
        }, function (error) {
          // something went wrong
          console.error(error);
        });
    };

    /**
     * @function
     * @description only set base url for this endpoint not for all resources
     */
    this.setBaseUrl = function (url) {
      this.baseUrl = url;
      return this;
    };

  };

}]);

'use strict';

angular.module('lizard-nxt')
  .service("CabinetService", [
           "$q", "Resource", "backendDomain", "gettextCatalog",
  function ($q, Resource, backendDomain, gettextCatalog) {

  var geocodeResource,
      searchResource,
      timeseriesResource,
      locationsResource,
      regions,
      wmsGetFeatureInfo;

  // for the wizard demo's
  if (window.location.host === 'nens.github.io' ||
      window.location.host === 'lizard.sandbox.lizard.net') {
    Resource.setBaseUrl(backendDomain);
    Resource.setDefaultHttpFields({withCredentials: true});
  }

  timeseriesResource = new Resource.Endpoint('api/v2/timeseries/');
  regions = new Resource.Endpoint('api/v2/regions/?page_size=500');

  // Wms getFeatureInfo goes through a proxy. Specify url as a param.
  wmsGetFeatureInfo = new Resource.Endpoint('proxy/');

  geocodeResource = new Resource.Endpoint('api/geocode/json')
    // Use a different base url, go directly to our friends at google.
    // They don't mind.
    .setBaseUrl('https://maps.googleapis.com/maps/');

  /**
   * Raster resource, last stop to the server
   * @param  {object} q             a promise to cancel previous requests
   *                                 if none is given a local 'abortGet' is
   *                                 used.
   *                                 At the next request without a promise, the
   *                                 abortGet is cancelled.
   * @return {Resource}  a gettable resource
   */
  var abortGet;
  var rasterResource = function (q) {
    var localPromise = q ? q : abortGet;
    if (localPromise === abortGet) {
      if (abortGet) {
        abortGet.resolve();
      }
      abortGet = $q.defer();
      localPromise = abortGet;
    }
    return new Resource.Endpoint('api/v2/raster-aggregates/');
  };

  /**
   * Create tooltips for the current language.
   *
   * Tooltips are dynamic. When the language changes they have to update. This
   * function fetches the correct values from gettext and return a tooltip
   * object.
   * @return {tooltips} tooltip object with translated tooltips.
   */
  var createTooltips = function () {
    return {
      login: gettextCatalog.getString("Log in"),
      logout: gettextCatalog.getString("Log out"),
      profile: gettextCatalog.getString("Modify profile"),
      version: gettextCatalog.getString(
        "Double click for lizard version number"),
      openMenu: gettextCatalog.getString("Open data menu"),
      closeMenu: gettextCatalog.getString("Close data menu"),
      transparency: gettextCatalog.getString("Adjust opacity"),
      pointTool: gettextCatalog.getString("Point selection"),
      lineTool: gettextCatalog.getString("Line selection"),
      areaTool: gettextCatalog.getString("View selection"),
      resetQuery: gettextCatalog.getString("Close result window"),
      zoomInMap: gettextCatalog.getString("Zoom in on the map"),
      zoomOutMap: gettextCatalog.getString("Zoom out on the map"),
      zoomInTimeline: gettextCatalog.getString("Zoom in on timeline"),
      goToNow: gettextCatalog.getString("Go to the present in timeline"),
      zoomOutTimeline: gettextCatalog.getString("Zoom out of timeline"),
      startAnim: gettextCatalog.getString("Start animation"),
      stopAnim: gettextCatalog.getString("Stop animation"),
      timelineStart: gettextCatalog.getString("Start of current timeline"),
      timelineAt: gettextCatalog.getString("The 'now' of the timeline"),
      timelineEnd: gettextCatalog.getString("End of current timeline"),
      openTimeline: gettextCatalog.getString("Open timeline"),
      closeTimeline: gettextCatalog.getString("Close timeline")
    };
  };

  return {
    createTooltips: createTooltips,
    geocode: geocodeResource,
    raster: rasterResource,
    timeseries: timeseriesResource,
    wmsGetFeatureInfo: wmsGetFeatureInfo,
    regions: regions
  };
}]);

/**
 * @ngdoc service
 * @class UtilService
 * @name UtilService
 * @summary Generic util functions.
 * @description Generic util functions.
 */
angular.module('lizard-nxt')
  .service("UtilService", ["NxtD3", "$timeout", function (NxtD3, $timeout) {


  /**
   * Returns the index of the value at key in arrayObject closest to value.
   * When value is exactly in the middle, the first index is returned.
   *
   * @param  {array}        collection array of objects or array of arrays
   *                                   to be searched.
   * @param  {string | int} key to compare property in arrayOfObjects.
   * @param  {int}          value to search for.
   * @return {int}          first index closest to value.
   */
  this.bisect = function (collection, key, value) {
    var index;
    var initialSmallestDiff = Infinity;
    _.reduce(collection, function (smallestDiff, d, i) {
      var currentDiff = Math.abs(d[key] - value);
      if (currentDiff < smallestDiff) {
        index = i;
        smallestDiff = currentDiff;
      }
      return smallestDiff;
    }, initialSmallestDiff);
    return index;
  };

  /**
   * @function roundTimestamp
   * @memberOf UtilService
   * @summary Round javascript timestamp to nearest coefficient.
   *
   * @description For example, if you want to round timestamp to the nearest 5
   * minutes, coefficient = 1000 * 60 * 5 = 30000.
   *
   * @param {integer} timestamp - javascript timestamp in ms.
   * @param {integer} coefficient - coefficient to round to in ms.
   * @param {boolean} up - true if you want to round instead of floor.
   * offset.
   * @returns {integer} roundedTimestamp - timestamp rounded to nearest
   * coefficient.
   */
  this.roundTimestamp = function (timestamp, coefficient, up) {
    var format;

    if (up) {
      timestamp += coefficient / 2;
    }
    if (coefficient === 2635200000) { // One month
      format = NxtD3.prototype._localeFormatter.nl_NL.timeFormat("%m/01/%Y");
      return new Date(format(new Date(timestamp))).getTime();
    } else if (coefficient === 86400000) { // One day
      format = NxtD3.prototype._localeFormatter.nl_NL.timeFormat("%m/%d/%Y");
      return new Date(format(new Date(timestamp))).getTime();
    }
    var roundedTimestamp = parseInt(timestamp / coefficient, 10) * coefficient;

    return roundedTimestamp;
  };

  // List of graph colors used to color timeseries
  this.GRAPH_COLORS = [
    '#1abc9c', // turquoise
    '#3498db', // peterRiver
    '#f1c40f', // sunflower
    '#9b59b6', // amethyst
    '#2ecc71', // emerald
    '#2980b9', // belizeHole
    '#e67e22', // carrot
    '#8e44ad', // wisteria
    '#16a085', // greenSea
    '#34495e', // wetAsphalt
    '#27ae60', // nephritis
    '#f39c12', // orange
    '#2c3e50', // midnightBlue
    '#d35400' // pumpkin
  ];

  /**
   * Returns true for <protocol>:<domain>.
   * Or www with a domain. Both options might include paths, query params
   * and anchors. It does not return true for 'henkie.com' but basically
   * everything else is matched.
   *
   * @param  {str}  string string to test
   * @return {Boolean} true for urls, false otherwise.
   */
  this.isUrl = function (string) {
    return /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[\-;:&=\+\$,\w]+@)?[A-Za-z0-9\.\-]+|(?:www\.|[\-;:&=\+\$,\w]+@)[A-Za-z0-9\.\-]+)((?:\/[\+~%\/\.\w\-_]*)?\??(?:[\-\+=&;%@\.\w_]*)#?(?:[\.\!\/\\\w]*))?)/.test(string);
  };


  /**
   * @function fixTouch
   * @memberOf UtilService
   * @summary sets x and y for touch event.
   * @description webkit has a bug with touches.
   * this fixes the x and y coordinates of the touch.
   */
  this.fixTouch = function (touch) {
    var winPageX = window.pageXOffset,
        winPageY = window.pageYOffset,
        x = touch.clientX,
        y = touch.clientY;

    if (touch.pageY === 0 && Math.floor(y) > Math.floor(touch.pageY) ||
        touch.pageX === 0 && Math.floor(x) > Math.floor(touch.pageX)) {
      // iOS4 clientX/clientY have the value that should have been
      // in pageX/pageY. While pageX/page/ have the value 0
      x = x - winPageX;
      y = y - winPageY;
    } else if (y < (touch.pageY - winPageY) || x < (touch.pageX - winPageX)) {
      // Some Android browsers have totally bogus values for clientX/Y
      // when scrolling/zooming a page. Detectable since clientX/clientY
      // should never be smaller than pageX/pageY minus page scroll
      x = touch.pageX - winPageX;
      y = touch.pageY - winPageY;
    }

    return {
        clientX:    x,
        clientY:    y
      };
  };


  // Available zoomlevels
  this._zoomLvls = {
    '5min': 300000,
    'hour': 3600000,
    'day': 86400000,
    'month': 2635200000
  }; // Month equals 30.5 days

  /**
   * @function getAggWindow
   * @memberOf UtilService
   *
   * @summary return aggregation window.
   *
   * @desc Returns aggWindow. Either five minutes, an hour or a day, should
   * lead to a minimum of three pixels within the drawing width.
   *
   * @param  {int} start    start of rainseries.
   * @param  {int} stop     end of rainseries.
   * @param  {int} drawingWidth size of graph in px.
   * @return {int} aggWindow in ms.
   */
  this.getAggWindow = function (start, stop, drawingWidth) {

    // TODO: Called both by omnibox and timeline, should be called only by
    // timeline, while omnibox subsequently syncs to timeState.aggWindow

    var aggWindow;
    var MIN_PX = 3; // Minimum width of a bar

    // ms per pixel
    var msPerPx = (stop - start) / drawingWidth;
    for (var zoomLvl in this._zoomLvls) {
      aggWindow = this._zoomLvls[zoomLvl];
      if (aggWindow > MIN_PX * msPerPx) {
        break; // If zoomlevel is sufficient to get enough width in the bars
      }
    }

    return aggWindow;
  };


  this.getAggWindowAsString = function (aggWindow) {
    var text = '';

    for (var zoomLvl in this._zoomLvls) {
      text = zoomLvl;
      if (this._zoomLvls[zoomLvl] === aggWindow) {
        break;
      }
    }

    return text;
  };

  this.getAggWindowAsText = this.getAggWindowAsString;

  /**
   * @function fadeCurrentCards
   * @memberOf UtilService
   *
   * @summary Fade out (in) currently (in-)visible cards.
   *
   * @param {boolean} fadeIn - An Angular scope s.t.
   * scope.mapState.mapMoving is defined.
   */
  this.fadeCurrentCards = function (scope) {

    var cards = d3.selectAll(".card");

    if (!scope.mapState.mapMoving) {
      // card comes back instantaniously
      cards
        .style("opacity", 1);
    } else {
      // card fades away into transparancy, after a delay, but only if
      // the map is still moving after that delay
      setTimeout(function () {
        if (scope.mapState.mapMoving) {
          cards
            .transition(100)
            .style("opacity", 0.2);
        } else {
          cards
            .style("opacity", 1);
        }
      }, 700);
    }
  };


  // helper for time stuff
  this.hour = 60 * 60 * 1000;
  this.day = 24 * this.hour;

  /**
   * @function parseDaysHours
   * @param {string} 0Days3Hours string
   * @return {int} milliseconds representation
   */
  this.parseDaysHours = function (timeString) {
    if (timeString === undefined) {
      return 0;
    }

    var days = parseInt(timeString.split('Days')[0]);
    var hours = parseInt(timeString.split('Days')[1].split('Hours')[0]);

    var totalMS = 0;
    if (!isNaN(days)) {
      totalMS += parseInt(days) * this.day;
    }

    if (!isNaN(hours)) {
      totalMS += parseInt(hours) * this.hour;
    }

    return totalMS;
  };

  /**
   * @function getTimeIntervalAsText
   * @param {int} Start time
   * @param {int} End time
   * @return {string} Difference in format of: 7 days 3 hours
   */
  this.getTimeIntervalAsText = function (start, end) {
    var days = '',
        hours = '';

    // only calculate if the end is larger than start
    if (end > start) {
      var interval = end - start;
      days = Math.floor(interval / this.day);
      hours = Math.floor((interval % this.day) / this.hour);
    }
    return {
      days: days,
      hours: hours
    };
  };

  /**
   * @function metersToDegs
   * @memberOf UtilService
   *
   * @summary Takes meters converts to radians, then converts degrees.
   *
   * @param  {float} meters
   * @return {float} degrees
   */
  this.metersToDegs = function (meters) {
    return (meters / 1000 / 6371) * 180 / Math.PI;
  };


  /**
   * @function createDataForTimeState
   * @memberOf UtilService
   *
   * @summary Creates a subset data object for a specific timeState.
   *
   * @param  {array} data      array of shape:
   *                           [
   *                             [t0, [[x0, y0], [x1, y1], ..., [xn, yn]],
   *                             [t1, [[x0, y0], [x1, y1], ..., [xn, yn]],
   *                             ...
   *                             [tm, [[x0, y0], [x1, y1], ..., [xn, yn]],
   *                           ]
   * @param  {object} timeState nxt timeState object
   * @return {array}           array (for timestep 1) of shape:
   *                           [[x0, y0_1], [x1, y1_1], ...]
   */
  this.createDataForTimeState = function (data, timeState) {
    var interval = timeState.end - timeState.start;
    var cur = timeState.at - timeState.start;
    var i = Math.round(data.length * cur / interval);
    var dataForTimeState = [];

    angular.forEach(data[i][1], function (value) {
      dataForTimeState.push([value[0], value[1]]);
    });

    return dataForTimeState;
  };


  /**
   * @function serveToOldIE
   * @memberOf UtilService
   * @description Check whether the client uses IE10+/non-IE browser
   *   (return false) OR that she uses an older IE version (return true)
   */
  this.serveToOldIE = function () {

    function getInternetExplorerVersion() {
      // Returns the version of Internet Explorer or -1
      // (indicating the use of another browser).

      var rv = -1, // Return value assumes failure.
          ua = navigator.userAgent,
          re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");

      if (re.exec(ua) !== null) {
        rv = parseFloat(RegExp.$1);
      }
      return rv;
    }
    var version = getInternetExplorerVersion();
    return version !== -1 && version < 10;
  };


  var checkForLine = function (geom) {
    if (geom.length > 1) {
      angular.forEach(geom, function (value) {
        if (!(value instanceof L.LatLng)) {
          return false;
        }
      });
      return true;
    }
  };


  /**
   * @function geomToWkt
   * @memberOf UtilService
   */
  this.geomToWkt = function (geom) {
    var coords = [];
    if (geom instanceof L.LatLng) {
      // geom is a L.LatLng object
      return "POINT(" + geom.lng + " " + geom.lat + ")";
    }

    else if (checkForLine(geom)) {
      // geom represents a line
      angular.forEach(geom, function (latLng) {
        coords.push(latLng.lng + " " + latLng.lat);
      });
      return "LINESTRING(" + coords.join(',') + ")";
    }

    else if (geom.type === 'Polygon') {
      var lng, lat;
      var cs = geom.coordinates[0];
      for (var i = 0; i < cs.length; i++) {
        coords.push(cs[i][0] + " " + cs[i][1]);
        if (i === 0) {
          lng = cs[i][0];
          lat = cs[i][1];
        }
      }
      return "POLYGON((" + coords.join(",") + "," + lng + " " + lat + "))";
    }

    else {
      // geom is a L.Bounds object
      return "POLYGON(("
            + geom.getWest() + " " + geom.getSouth() + ", "
            + geom.getEast() + " " + geom.getSouth() + ", "
            + geom.getEast() + " " + geom.getNorth() + ", "
            + geom.getWest() + " " + geom.getNorth() + ", "
            + geom.getWest() + " " + geom.getSouth()
            + "))";
    }
  };

  /**
   * @function buildString
   * @memberof UtilService
   * @description Glues all of it's arguments to a single string
   */
  this.buildString = function () {
    var i, result = "";
    for (i = 0; i < arguments.length; i++) {
      result += arguments[i];
    }
    return result;
  };


  /**
   * @function all
   * @memberof UtilService
   * @description - Checks whether ALL elements of the input satisfy the
   *                predicate
   * @param {arr} - An enumerable/iterable datastructure, e.g. Array
   * @param {predicate_} - A predicate, e.g.
   *                       'even': function (x) { x % 2 === 0 };
   * @return {boolean}
   */
  this.all = function (arr, predicate_) {
    var i,
        result = true,
        predicate = predicate_ || function (x) { return !!x; };
    for (i = 0; i < arr.length; i++) {
      result = result && predicate(arr[i]);
    }
    return result;
  };


  /**
   * @function any
   * @memberof UtilService
   * @description - Checks whether ANY element of the input satisfies the
   *   predicate
   * @param {arr} - An enumerable/iterable datastructure, e.g. Array
   * @param {predicate_} - A predicate, e.g. 'even':
   *   function (x) { x % 2 === 0 };
   * @return {boolean}
   */
  this.any = function (arr, predicate_) {
    var i,
        result = false,
        predicate = predicate_ || function (x) { return !!x; };
    for (i = 0; i < arr.length; i++) {
      result = result || predicate(arr[i]);
    }
    return result;
  };


  /**
   * @function
   * @memberOf UtilService
   * @description - Checks whether API response from the raster store has enough
   *                (non-null) data to actually put it on the scope.
   * @param {Object[]} response - An API response
   * @return {boolean}
   */
  this.isSufficientlyRichData = function (data) {

    if (data === undefined) {
      return false;

    } else if (data === 'null') {
      // backend did not return valid data.. log as ERROR?
      return false;

    } else if (this.nullOrNestedNull(data)) {
      // kill: null AND [null] AND [[null]] etc
      return false;

    } else if (data.constructor === Array) {

      if (data.length === 0) {
        // kill: []
        return false;

      } else if (this.all(data, function (x) { return x === null; })) {

        // kill: [null, null, ..., null]
        return false;

      } else if (data[0].constructor === Array) {

        if (data[0] === []) {
          return false;

        } else if (data[0].length === 1 && data[0][0] !== null) {
          return true;

        } else if (data[0].length > 1) {

          if (data[0][0].constructor === Array) {

            // kill: [[x0, [null]], [x1, [null]], ..., [xn, [null]]]
            return !this.all(data, function (elem) {
              return elem[1].length === 1 && elem[1][0] === null;
            });

          } else {

            // kill: [[x0, null], [x1, null], ..., [xn, null]]
            return !this.all(data, function (elem) {
              return elem[1] === null;
            });
          }
        }
      }
    }
    return true;
  };


  /**
   * @function
   * @memberOf UtilService
   * @description - checks whether passed in argument is null or nested null,
                    e.g: null, [null], [[null]] etc
   * @param {anything}
   * @return {boolean}
   */
  this.nullOrNestedNull = function (x) {

    if (x === null) {
      return true;

    } else if (x.constructor === Array && x.length === 1) {
      return this.nullOrNestedNull(x[0]);

    } else {
      return false;
    }
  };


  this.preventOldIEUsage = function () {
    if (this.serveToOldIE()) {
      document.querySelector("#dark-overlay").style.display = "block";
      document.querySelector("#mymodal").style.display = "block";
      // explicitly HIDE the layerMenu
      document.querySelector(".layer-switcher-wrapper").style.display = "none";
      // explicitly setZindex of a few items. This should NOT be in main.css
      // breaks functionality:
      var node = document.createElement('style');
      node.innerHTML = '#timeline, #searchbox, .container-fluid,'
        + '.navbar, #omnibox, .layer-menu-container,'
        + '.ribbon {'
        + ' z-index: 0;'
        + '}';
      document.body.appendChild(node);
    }
  };


  /**
   * @description - Deduce the wanted geometry-type from the passed in geomOpts
   * @param {object} geomOpts - the options.geom object
   * @return {string} - "POINT" | "LINE" | "AREA" | throw new Error!
   *
   * TODO: get rid of this maniacal reverse engineering of our own code.
   * could be as easy as `feature.geometry.type`.
   */
  this.getGeomType = function (geomOpts) {

    if (geomOpts instanceof L.LatLng) {
      return "POINT";

    } else if (geomOpts._southWest && geomOpts._northEast) {
      return "AREA";

    } else if (geomOpts.length === 2
      && geomOpts[0] instanceof L.LatLng
      && geomOpts[1] instanceof L.LatLng) {
      return "LINE";

    } else if (geomOpts.coordinates) { // geojson
      return "REGION";

    } else {
      throw new Error(
        "getGeomType could not deduce a valid geometry type from the passed " +
        " in arg: 'geomOpts' =", geomOpts
      );
    }
  };


  /**
   * @function
   * @description - Count all keys for an object (we can't do this vanilla.js
   *                style in Angular template)
   * @param {object} obj - The object for which we want to know the amount of
   *                       keys.
   * @return {integer} - The amount of keys.
   */
  this.countKeys = function (obj) {
    return obj === undefined ? 0 : Object.keys(obj).length;
  };


  /**
   * @function
   * @description Get correct icon for structure
   */
  this.getIconClass = function (str) {
    switch (str) {
    case 'pumpstation':
      return 'icon-pumpstation-diesel';
    case 'bridge':
      return 'icon-bridge';
    case 'bridge-draw':
      return 'icon-bridge';
    case 'bridge-fixed':
      return 'icon-bridge';
    default:
      return 'icon-' + str;
    }
  };


  /* @description - Convert lin to log scale, given the following 3 args.
   * @param {number} value - the value to convert
   * @param {number} minValue - the start of the scale
   * @param {number} maxValue - the end of the scale
   * @return {number} - The converted value
   */
  this.lin2log = function (value, minValue, maxValue, minDomain, maxDomain) {
    var scale = d3.scale.log()
      .domain([minDomain, maxDomain])
      .range([minValue, maxValue]);
    return scale(value);
  };


  /**
   * @description - This add a <style> tag + it's contents to the <head> of the
   *                page. Adding more will iteratively subsitute the most recent
   *                addition.
   * @param {string} newStyle - A string representing the to-be-added CSS
   * @return {void}
   */
  this.addNewStyle = function (newStyle) {
    var styleElement = document.getElementById('styles_js');
    if (!styleElement) {
      styleElement = document.createElement('style');
      styleElement.type = 'text/css';
      styleElement.id = 'styles_js';
      document.getElementsByTagName('head')[0].appendChild(styleElement);
    }
    styleElement.innerHTML = "";
    styleElement.appendChild(document.createTextNode(newStyle));
  };


  /*
   * @description - Convert string ending in px to value expressed in pixels,
   *                it denotes.
   * @param {string} str - The string to be converted.
   */
  this.pxToInt = function (str) {
    try {
      return parseInt(str.replace("px", ""));
    } catch (e) {
      throw new Error("Could not extract integer from string: '" + str + "'");
    }
  };


  /**
   * @function
   * @description - Get amount of Km^2 in the current spatial extent
   *                (bottom-limit = 1)
   * @param {latLngBounds} leafletBounds - A leaflet bounds object denoting the
   *                                       current spatial extent.
   * @return {number} - A number denoting the extent's corresponding perimeter
   *                   (expressed in Km^2)
   */
  this.extent2kilometers = function (leafletBounds) {

    var northWest = L.latLng({
          lat: leafletBounds._southWest.lat,
          lng: leafletBounds._northEast.lng
        }),
        southEast = L.latLng({
          lat: leafletBounds._northEast.lat,
          lng: leafletBounds._southWest.lng
        }),
        latDistance = leafletBounds._southWest.distanceTo(southEast) / 1000,
        lngDistance = leafletBounds._northEast.distanceTo(northWest) / 1000;

    // On high zoomlevels, we limit the area to 1km^2 since that's the
    // spatial resolution ("pixel") for radar data in the rasterstore.
    return Math.max(1, latDistance * lngDistance);
  };

  /*
   * @function
   * @description wrapper around lodash.union function
   * which works better than our own implementation..
   * Could be more efficient to call from api in a batch
   * instead of tiled/geojson stuff.
   */
  this.union = _.union;

  // Add comparator to sort lists on multiple properties to D3.
  (function () {
    d3.comparator = function () {
      var cmps = [], accessors = [];

      var comparator = function (a, b) {
        var i = -1,
            n = cmps.length,
            result;
        while (++i < n) {
          result = cmps[i](accessors[i](a), accessors[i](b));
          if (result !== 0) { return result; }
        }
        return 0;
      };

      comparator.order = function (cmp, accessor) {
        cmps.push(cmp);
        accessors.push(accessor || identity);
        return comparator;
      };

      return comparator;
    };

    function identity(d) { return d; }
  })();

  this.MIN_TIME = (new Date("Jan 01, 1900")).getTime();
  this.MAX_TIME = (new Date()).getTime() + 20 * 24 * 60 * 60 * 1000; // 20 Days
  this.TIMELINE_LEFT_MARGIN = 60;
  this.TIMELINE_RIGHT_MARGIN = 40;
  this.OMNIBOX_WIDTH = 420;

  this.getMinTime = function (currentTime) {
    return Math.max(this.MIN_TIME, currentTime);
  };

  this.getMaxTime = function (currentTime) {
    return Math.min(this.MAX_TIME, currentTime);
  };

  this.getLeftMargin = function (context) {
    var leftMargin = this.TIMELINE_LEFT_MARGIN;

    if (context === 'dashboard') {
      leftMargin += this.OMNIBOX_WIDTH;
    }

    return leftMargin;
  };

  this.getCurrentWidth = function (element) {
    return element[0].clientWidth - (
      this.TIMELINE_LEFT_MARGIN + this.TIMELINE_RIGHT_MARGIN
    );
  };

  this.hexColorToDecimalTriple = function (rgbString) {

    var rInt, gInt, bInt;

    if (rgbString.charAt(0) === "#") {
      rgbString = rgbString.substring(1, rgbString.length);
    }

    if (rgbString.length === 3) {
      rInt = parseInt(rgbString.charAt(0) + rgbString.charAt(0), 16);
      gInt = parseInt(rgbString.charAt(1) + rgbString.charAt(1), 16);
      bInt = parseInt(rgbString.charAt(2) + rgbString.charAt(2), 16);

    } else if (rgbString.length === 6) {
      rInt = parseInt(rgbString.substring(0, 2), 16);
      gInt = parseInt(rgbString.substring(2, 4), 16);
      bInt = parseInt(rgbString.substring(4, 6), 16);

    } else {
      throw new Error("This is not a valid color-string: '" + rgbString + "'");
    }

    return [rInt, gInt, bInt];
  };

  this.decimalTripleToHexColor = function (rgbTriple) {

    if (rgbTriple && rgbTriple.length === 3) {
      var rgbString = "#",
          currentHexString;
      rgbTriple.forEach(function (elem) {
        currentHexString = elem.toString(16);
        if (currentHexString.length === 1) {
          currentHexString = "0" + currentHexString;
        }
        rgbString += currentHexString;
      });
      return rgbString;

    } else {
      throw new Error("This aint a valid triple to convert into rgbString: " +
                      rgbTriple);
    }
  };

  /**
   * @descriptions - Round numbers, but use specified decimalCount for
   *                 resolution
   * @param {number} nr- The number to round.
   * @param {integer} - The amount of decimals wanted. Integer of undefined
   * @return {float} - The formatted number
   */
  this.round = function (nr, decimalCount) {
    var multiplier = Math.pow(10, decimalCount || 0);
    return Math.round(nr * multiplier) / multiplier;
  };

  /**
   * @function
   * @description - "%f-in-javascript", you know the drill
   *
   * @param {number} x - The input you want to convert
   * @param {integer} wantedIntCount - The amount of leading zeros
   * @param {integer} wantedFloatCount - The amount of trailing zeros
   * @param {boolean} dutchify - Swap seperators: "." <--> ","
   *
   * @return {string} - The formatted number, formatted as string
   */
  this.formatNumber = function (x, wantedIntCount, wantedFloatCount, dutchify) {

    var i,
        splitted = x.toString().split("."),
        prefix = splitted[0],
        suffix = splitted[1] || "";

    while (prefix.length < wantedIntCount) {
      prefix = "0" + prefix;
    }

    while (suffix.length < wantedFloatCount) {
      suffix += "0";
    }

    if (dutchify) {
      prefix.replace(",", ".");
      suffix.replace(",", ".");
      return prefix + "," + suffix;
    }
    return prefix + "." + suffix;
  };

  /**
   * Set timeline to moving and back after digest loop to trigger watches
   * that do something after the timeline moved.
   *
   * @param {object} state - State object.
   */
  this.announceMovedTimeline = function (state) {
    state.temporal.timelineMoving = true;

    // Set timeline moving to false after digest loop
    $timeout(
      function () {
        state.temporal.timelineMoving = false;
      },
      0, // no delay, fire when digest ends
      true // trigger new digest loop
    );
  };

  /**
   * @function _formatDate
   * @summmary Format epoch in ms to human readable string.
   * @description Format epoch in ms to human readable string.
   *
   * @param {integer} epoch - time in ms since 1970.
   * @returns {string} formatted date.
   */
  this.formatDate = function (epoch) {
    var d = new Date(parseInt(epoch, 10));
    return [
      [d.getDate(), d.getMonth() + 1,
       d.getFullYear()].join('-'),
      [d.getHours() || "00",
       d.getMinutes() || "00",
       d.getSeconds() || "00"].join(':')
    ];
  };

  /**
   * Format CSV (exporting rain data for a point in space/interval in
   * time) in a way that makes it comprehensible for les autres.
   *
   * @param {object []} data - list with data objects to parse.
   * @param {array} coords - list of coordinates of data.
   * @returns list of formatted data objects.
   */
  this.formatCSVColumns = function (data, coords) {
    var i,
        latLng = L.latLng(coords[1], coords[0]),
        formattedDateTime,
        formattedData = [];

    for (i = 0; i < data.length; i++) {

      formattedDateTime = this.formatDate(data[i].timestamp || data[i][0]);

      var formattedDatum = [
        this.formatNumber(latLng.lat, 0, 0, true),
        this.formatNumber(latLng.lng, 0, 0, true),
        formattedDateTime[0],
        formattedDateTime[1]
      ];

      if (data[i].max !== undefined && data[i].min !== undefined) {
        formattedDatum.push(
          this.formatNumber(
            Math.round(100 * data[i].min) / 100 || 0,
            0,
            2,
            true // Dutchify seperators
          )
        );
        formattedDatum.push(
          this.formatNumber(
            Math.round(100 * data[i].max) / 100 || 0,
            0,
            2,
            true
          )
        );
      } else {
        formattedDatum.push(
          this.formatNumber(
            Math.round(100 * data[i][1]) / 100 || 0,
            0,
            2,
            true // Dutchify seperators
          )
        );
      }

      formattedData.push(formattedDatum);

    }

    return formattedData;
  };

  /**
   * Create a slug from a string.
   * This is the Javascript equivalent of the Django algorithm:
   * https://docs.djangoproject.com/en/1.8/_modules/django/utils/text/#slugify
   *
   * @param {string} s - The string to slugify.
   * @returns a slugified version of the string.
   */
  this.slugify = function(s) {
    var value;
    value = s;
    // Remove all non-alphanumeric-underscore-dash-space characters.
    value = _.replace(value, /[^\w\s-]/g, '');
    // Remove leading and trailing whitespace.
    value = _.trim(value);
    // Convert to lowercase.
    value = _.lowerCase(value);
    // Replace spaces with dashes.
    value = _.replace(value, /[-\s]+/g, '-');
    return value;
  };

  /**
   * @function
   * @description given point p find the closest
   * point on the line between a and b
   *
   * Taken from: http://www.gamedev.net/topic/444154-closest-point-on-a-line/
   */
  this.pointAlongLine = function (p, a, b) {
    var diffPA = {
      lat: p.lat - a.lat,
      lng: p.lng - a.lng
    };
    var diffAB = {
      lat: b.lat - a.lat,
      lng: b.lng - a.lng
    };

    var ab2 = diffAB.lat * diffAB.lat + diffAB.lng * diffAB.lng;
    var apAb = diffPA.lat * diffAB.lat + diffPA.lng * diffAB.lng;
    var t = apAb / ab2;
    if (t < 0) {
      t = 0;
    }
    if (t > 1) {
      t = 1;
    }
    var closest = new L.LatLng(
      a.lat + diffAB.lat * t,
      a.lng + diffAB.lng * t
    );
    return closest;
  };

}]);

/**
 * Service to handle utf grid requests.
 */
angular.module('lizard-nxt')
  .service('UtfGridService', ['$q', '$rootScope', 'UtilService',

  function ($q, $rootScope, UtilService) {


    // UtfGridService has a local cache of the last query so the dataservice can
    // get an answer of the utfgrid even if there is no map.
    // NOTE: we use this as a 'poor man's state' of the 'last selected
    // object'. We might want to include the 'last selected object' in the
    // actual state so we can refer to it directly.
    var _cache = {};

    /**
     * @function buildCacheKey
     * @summary Calculate cache key for layer and options.
     *
     * @param {object} layer    nxt layer to use as key.
     * @param {object} options  options to use as key.
     * @returns {string} key
     */
    var buildCacheKey = function (layer, options) {

      var geomString;

      try {
        // bounds have a bbox string method
        geomString = options.geom.toBBoxString();
      }
      catch (e) {
        // latlngs have a tostring method
        geomString = options.geom.toString();
      }

      return  layer.slug + geomString;
    };

    /**
     * @function setToLocalCache
     * @summary Set data to local cache.
     *
     * @param {string} key  key to store data at.
     * @param {object} data data to cache.
     */
    var setToLocalCache = function (key, data) {
      _cache = {};  // reset cache because we only need to remember the last
                    // query.
      _cache[key] = data;
    };

    /**
     * @function getFromLocalCache
     * @summary Gets data for `key` from local cache. Returns undefined if `key`
     * doesn't exist.
     *
     * @return {object} Cached data or undefined if key doesn't exist.
     */
    var getFromLocalCache = function (key) {
      return _cache[key];
    };

    var getData = function (callee, nonLeafLayer, options) {

      var leafLayer = nonLeafLayer && nonLeafLayer._leafletLayer,
          geomType = UtilService.getGeomType(options.geom),
          deferred = $q.defer(),
          e = { latlng: options.geom },
          response,
          cacheKey = buildCacheKey(nonLeafLayer, options);

      if (
        options.geom === undefined
        || geomType === "LINE"
        || geomType === "REGION") {
        deferred.reject();
        return deferred.promise;
      }

      var cached = getFromLocalCache(cacheKey);
      if (cached) {
        response = cached;
        deferred.resolve(response.data);
      } else {
        response = _getResponseForGeomType(
          leafLayer, geomType, e, options.geom);

        if (!window.loaded
          || leafLayer.isLoading
          || !leafLayer._map
          || !leafLayer._map.hasLayer(leafLayer)
        ) {
          _getDataFromUTFAsynchronous(
            nonLeafLayer, e, deferred, geomType, options);
        } else {
          setToLocalCache(cacheKey, response);
          deferred.resolve(response.data);
        }
      }

      return deferred.promise;
    };

    var _getDataFromUTFAsynchronous = function (nonLeafLayer,
                                                e,
                                                deferred,
                                                geomType,
                                                options) {
      var response, leafLayer = nonLeafLayer._leafletLayer,
          cacheKey = buildCacheKey(nonLeafLayer, options);

      leafLayer.on('load', function () {
        response = _getResponseForGeomType(
          leafLayer, geomType, e, options.geom);
        if ($rootScope.$$phase) {
          setToLocalCache(cacheKey, response);
          deferred.resolve(response.data);
        } else {
          $rootScope.$apply(function () {
            setToLocalCache(cacheKey, response);
            deferred.resolve(response.data);
          });
        }
      });
    };

    var _getResponseForGeomType = function (leafLayer, geomType, e, geomOpts) {
      switch (geomType) {
      case 'POINT':
        return leafLayer._objectForEvent(e);
      case "LINE":
        return undefined;
      case "AREA":
        return _groupStructuresByEntityName(
          leafLayer.getUniqueStructuresForExtent(),
          geomOpts
        );
      default:
        throw new Error(
          "UtfGridService._getResponseForGeomType called with invalid " +
          " arg 'geomType', which happened to be:",
          geomType
        );
      }
    };

    var _isWithinExtent = function (structureGeom, leafletBounds) {

      switch (structureGeom.type) {
      case "Point":
        return leafletBounds.contains(L.latLng(
          structureGeom.coordinates[1],
          structureGeom.coordinates[0]
        ));

      case "LineString":

        // For now (15-01-2015), don't take into account structures with a geom
        // type other than POINT. Since this will probably be reverted some time
        // in the foreseeable future, we simply comment the relevant code and
        // return false.

        // var lineStart = L.latLng(
        //       structureGeom.coordinates[0][1],
        //       structureGeom.coordinates[0][0]
        //     ),
        //     lineEnd = L.latLng(
        //       structureGeom.coordinates[1][1],
        //       structureGeom.coordinates[1][0]
        //     );

        // TODO: Fix detection of lines that overlap the extent, but that do
        // not start nor end within the extent. It negligable for now.
        //return leafletBounds.contains(lineStart) || leafletBounds.contains(lineEnd);

        return false;

      default:
        throw new Error("Did not find valid geom type:", structureGeom.type);
      }
    };

    var _groupStructuresByEntityName = function (structures, geomOpts) {

      var uniqueId,
          currentEntityName,
          structure,
          structureGeom,
          leafletBounds = L.latLngBounds(
            geomOpts._southWest, geomOpts._northEast),
          groupedStructures = { data: {} };

      for (uniqueId in structures.data) {

        structure = structures.data[uniqueId];
        structureGeom = JSON.parse(structure.geom);

        if (!_isWithinExtent(structureGeom, leafletBounds)) {
          continue;
        }

        currentEntityName = structure.entity_name;
        groupedStructures.data[currentEntityName]
          = groupedStructures.data[currentEntityName] || {};
        groupedStructures.data[currentEntityName][uniqueId] = structure;
      }
      return groupedStructures;
    };

    return { getData: getData };
  }
]);

/**
 * Service to handle raster requests.
 */
angular.module('lizard-nxt')
  .service("RasterService", ["State",
                             "UtilService",
                             "CabinetService",
                             "LeafletService",
                             "$q",
  function (State, UtilService, CabinetService, LeafletService, $q) {

  var intensityData,
      cancelers = {};

  var getData = function (callee, layer, options) {

    var srs = 'EPSG:4326',
        agg = options.agg || '',
        startString,
        endString,
        aggWindow;

    if (options.start && options.end) {
      startString = new Date(options.start).toISOString().split('.')[0];
      endString = new Date(options.end).toISOString().split('.')[0];
    }

    aggWindow = options.aggWindow || State.temporal.aggWindow;

    var canceler;
    // getData can have own deferrer to prevent conflicts
    if (options.deferrer) {
      var deferSlug = options.deferrer.origin;
      canceler = options.deferrer.deferred;
      if (cancelers[options.deferrer.origin]) {
        cancelers[options.deferrer.origin].resolve();
      }
      cancelers[options.deferrer.origin] = canceler;
    }
    // if it doesn't have a deferrer in the options
    // use the layer slug..
    else {
      if (cancelers[callee + '_' + layer.slug]) {
        cancelers[callee + '_' + layer.slug].resolve();
      }

      canceler = cancelers[callee + '_' + layer.slug] = $q.defer();
    }

    var requestOptions = {
      raster_names: layer.slug,
      srs: srs,
      start: startString,
      stop: endString,
      agg: agg,
      styles: options.styles,
      window: aggWindow
    };

    if (options.geom_id) {
      requestOptions.geom_id = options.geom_id;
      requestOptions.boundary_type = options.boundary_type;
    } else {
      requestOptions.geom = UtilService.geomToWkt(options.geom);
    }

    if (options.truncate === true) {
      requestOptions.truncate = options.truncate;
    }

    return CabinetService.raster(canceler).get(requestOptions);
  };

  /**
   * Build the bounding box given an imageBounds
   */
  var _buildBbox = function (imgBounds) {
    return [imgBounds[0].x, imgBounds[0].y].toString() +
      ',' + [imgBounds[1].x, imgBounds[1].y].toString();
  };

  /**
   * Returns wms url as used by the non-tiled layer for animation.
   *
   * @param  {object} wmsLayer   nxt map layer instance with options and slug.
   * @param  {object} map        current leaflet map
   * @param  {string} store         name of store rain-5min|rain-hour etc.
   * @param  {boolean} singleTile when single it returns a proper tilesize
   *                              otherwise just 256x256px.
   * @return {string}            url
   */
  var buildURLforWMS = function (wmsLayer, map, store, singleTile, options) {
    options = options || {};
    var layerName = store || wmsLayer.slug,
        bounds = options.bounds || map.getBounds(),
        DEFAULT_TILE_SIZE = 256; // in px

    var imgBounds = [
      LeafletService.CRS.EPSG3857.project(bounds.getSouthWest()),
      LeafletService.CRS.EPSG3857.project(bounds.getNorthEast()),
    ],

    wmsOpts = wmsLayer.options,

    result = wmsLayer.url
      + '?SERVICE=WMS&REQUEST=GetMap&VERSION=1.1.1&FORMAT=image%2Fpng'
      + '&SRS=EPSG%3A3857&LAYERS=' + layerName
      + '&BBOX=' + _buildBbox(imgBounds);

    if (singleTile) {
      var size = options.size || map.getPixelBounds().getSize();
      wmsOpts.height = Math.round(size.y / size.x * DEFAULT_TILE_SIZE);
      wmsOpts.width = Math.round(size.x / size.y  * DEFAULT_TILE_SIZE);
    } else {
      // Serve square tiles
      wmsOpts.height = DEFAULT_TILE_SIZE;
      wmsOpts.width = DEFAULT_TILE_SIZE;
    }


    angular.forEach(wmsOpts, function (v, k) {
      result += UtilService.buildString('&', k.toUpperCase(), "=", v);
    });

    // key TIME needs to come last, so we can subsequently append it's value
    // for every frame in the animation:
    result += '&TIME=';

    return result;
  };

  return {
    buildURLforWMS: buildURLforWMS,
    getData: getData,
  };

}]);

/**
 * Service to handle getFeatureInfo requests for wms layers.
 */
angular.module('lizard-nxt')
.service("WmsGetFeatureInfoService", [

  "LeafletService",
  "CabinetService",
  "$q",
  'State',

  function (LeafletService, CabinetService, $q, State) {

  /**
   * Gets data from wmsGetFeatureInfo resource of cabinetService.
   *
   * It takes the private _map leaflet map from the private _leafletLayer to
   * provide the wms server with a clue of what the user clicked on. It is a
   * nasty technique that will bite us when we ask for a featureInfo of a latLng
   * without having a map. This is the way wms works. It works if the layer has
   * a _leafletLayer._map otherwise it rejects the promise.
   *
   * @param  {string}   callee  optional string indicating the origin of the
   *                            call.
   * @param  {NxtLayer} layer   nxt layer.
   * @param  {object}   options options that contain geom.
   * @return {object}          promise that resolves with wms response object.
   *                            Or promise that gets rejected when geometry is
   *                            not a leaflet LatLng or undefined.
   *
   */
  var getData = function (callee, layer, options) {

    if (options.geom === undefined
      || !(options.geom instanceof LeafletService.LatLng)
      || !(layer._leafletLayer)
      || !(layer._leafletLayer._map)) {
      var defer = $q.defer();
      defer.reject();
      return defer.promise;
    }

    // NOTE: its ugly we know. See description above.
    var map = layer._leafletLayer._map;

    var size = map.getSize(),
        bbox = map.getBounds().toBBoxString(),
        point = map.latLngToContainerPoint(options.geom);

    var params = {
      SERVICE: 'WMS',
      VERSION: '1.1.1',
      REQUEST: 'GetFeatureInfo',
      INFO_FORMAT: 'application/json',
      LAYERS: layer.slug,
      QUERY_LAYERS: layer.slug,
      STYLES: '', // required.
      SRS: "EPSG:4326",
      BBOX: bbox,
      WIDTH: size.x,
      HEIGHT: size.y,
      X: point.x,
      Y: point.y
    };

    var url = layer.url + '/?';
    for (var key in params) {
        if (url !== "") {
            url += "&";
        }
        url += key + "=" + params[key];
    }

    return CabinetService.wmsGetFeatureInfo.get({url:url});
  };

  return {
    getData: getData,
  };

}]);


'use strict';

/**
 * @ngdoc service
 * @class VectorService
 * @memberof app
 * @name VectorService
 * @summary Receives and returns vector data, as a service (or VDaaS).
 * @description VectorService is responsible for retreiving, storing
 * and exposing vector typed data.
 *
 */

angular.module('lizard-nxt')
  .service('VectorService', ['$q',
                             '$rootScope',
                             'LeafletService',
                             'UtilService',
                             '$http',
  function ($q, $rootScope, LeafletService, UtilService, $http) {


    /**
     * Returns true if feature has the type and id provided by the objectFilter.
     * @param  {object} objectFilter object with type and id
     * @param  {object} feature      feature to check for type and id of
     *                               properties.object.
     * @return {boolean}              [description]
     */
    var checkRelatedToObject = function (objectFilter, feature) {
      return feature.properties.object
        && feature.properties.object.type === objectFilter.type
        && feature.properties.object.id === objectFilter.id;
    };

    /**
     * @function
     * @description filters geojson array on spatial bounds.
     * @param  {L.LatLngBounds} spatial
     * @param  {featureArray}   sourceArray
     * @return {filteredSet}    filtered set of features.
     */
    var filterSpatial = function (sourceArray, spatial, objectFilter) {
      var filteredSet = [];
      var query = spatial instanceof LeafletService.LatLngBounds ? 'contains' : 'equals';
      sourceArray.forEach(function (feature) {
        var withinBounds,
            partOfObject;

        if (feature.geometry.type === "Point") {
          var latLng = new LeafletService.LatLng(
            feature.geometry.coordinates[1],
            feature.geometry.coordinates[0]
            );
          withinBounds = spatial[query](latLng);
        }

        if (objectFilter) {
          partOfObject = checkRelatedToObject(objectFilter, feature);
        }

        if (withinBounds || partOfObject) {
          filteredSet.push(feature);
        }

      });
      return filteredSet;
    };

    /**
     * @description - Checks whether a single feature must be drawn given
     *                a certain timeState.
     */
    var isInTempExtent = function (feature, temporal) {
      var eventStartBeforeTLStart = false,
          eventStartAfterTLStart = false,
          eventEndBeforeTLStart = false,
          eventEndAfterTLStart = false,
          eventEndBeforeTLEnd = false;

      if (feature.properties) { feature = feature.properties; }

      if (temporal.start) {
        eventStartBeforeTLStart
          = feature.timestamp_start < temporal.start;
        eventStartAfterTLStart
          = !eventStartBeforeTLStart;
        eventEndBeforeTLStart
          = feature.timestamp_end < temporal.start;
        eventEndAfterTLStart
          = !eventEndBeforeTLStart;
      }

      if (temporal.end) {
        eventEndBeforeTLEnd
          = feature.timestamp_end < temporal.end;
      }

      var result;
      if (eventStartBeforeTLStart
          && eventEndAfterTLStart) { result = true; }
      else if (
                (temporal.start === undefined || eventStartAfterTLStart)
                && (temporal.end === undefined || eventEndBeforeTLEnd)
              )
              { result = true; }
      else if (feature.hasOwnProperty("timestamp")) {
        result = feature.timestamp >= temporal.start
                 && feature.timestamp <= temporal.end;
      }
      else {
        result = false;
      }

      return result;
    };

    /**
     * @function
     * @description filters geojson array on temporal bounds.
     * @param  {object}      start end object
     * @param  {feature[]}   sourceArray
     * @return {filteredSet} filtered set of features.
     */
    var filterTemporal = function (sourceArray, temporal) {
      return sourceArray.filter(function (feature) {
        return isInTempExtent(feature, temporal);
      });
    };

    /**
     * @description filters data on time, spatial extent and relation to object.
     * @param  {L.LatLngBounds} spatial  Leaflet Bounds object
     * @param  {object}         temporal object with start and end in epoch
     *                          timestamp
     * @param {object}          objectFilter object with type and id of object.
     * @return {filteredSet}    Array with points within extent.
     */
    var filterSet = function (filteredSet, spatial, objectFilter, temporal) {
      if (!spatial && !temporal && !objectFilter) { return filteredSet; }

      // First filter temporal.
      if (temporal.hasOwnProperty('start') || temporal.hasOwnProperty('end')) {
        filteredSet = filterTemporal(filteredSet, temporal);
      } else if (temporal) {
        throw new Error(temporal + "is an invalid time to query VectorService");
      }

      // Second filter spatially but leave features in the set when related to
      // object.
      if (spatial instanceof LeafletService.LatLngBounds
        || spatial instanceof LeafletService.LatLng) {
        filteredSet = filterSpatial(filteredSet, spatial, objectFilter);
      } else if (spatial instanceof Array
        && spatial[0] instanceof LeafletService.LatLng) {
        // TODO: implement line intersect with vector data
        filteredSet = [];
      } else if (spatial) {
        throw new Error(
          spatial + "is an invalid geometry to query VectorService");
      }

      return filteredSet;
    };

    var vectorLayers = {};

    /**
     * @memberof app.VectorService
     * @function
     * @description gets data from backend
     * @param  {string} callee string of the callee to keep requests
     *                         seperate NOTE: not implemented in this service.
     * @param  {layer} layer as defined by layer-service
     * @param  {object} geomortime  geometry or time that it needs to get
     *                  (e.g. bboxs)
     * @param  {object} time  start, stop object
     * @return {object}
     */
    var getData = function (callee, nonLeafLayer, options) {
      var deferred = $q.defer(),
          layerSlug;

      // leaflet knows nothing, so sends slug and leaflayer
      if (typeof nonLeafLayer === 'string') {
        layerSlug = nonLeafLayer;
      } else {
        layerSlug = nonLeafLayer.slug;
      }

      if (!vectorLayers[layerSlug] || vectorLayers[layerSlug].isLoading) {
        getDataAsync(layerSlug, nonLeafLayer, options, deferred);
      } else {
        var set = filterSet(vectorLayers[layerSlug].data,
        options.geom, options.object, {
          start: options.start,
          end: options.end
        });

        deferred.resolve(set);
      }

      return deferred.promise;
    };

    var invalidateData = function (nonLeafLayer) {
      vectorLayers[nonLeafLayer.slug] = null;
    };

    /**
     * @description Triggers resolve callback on loaded data.
     * @param {layer}
     * @param {options}
     * @param {object}
     */
    var getDataAsync = function (layerSlug, layer, options, deferred) {
      if (!vectorLayers[layerSlug]) {

        vectorLayers[layerSlug] = {
          data: [],
          isLoading: true,
          promise: {}
        };

        vectorLayers[layerSlug].promise = $http({
          url: layer.url,
          method: 'GET',
          params: { page_size: 5000 }
        })
        .then(function (response) {
          vectorLayers[layerSlug].isLoading = false;
          var data = response.data.results;
          var geoData = data.filter(
            function (item) { return item.geometry !== null; }
          );
          setData(layerSlug, geoData, 1);
        });

      }

      vectorLayers[layerSlug].promise.then(function () {
        deferred.resolve(filterSet(vectorLayers[layerSlug].data,
          options.geom, options.objectFilter, {
            start: options.start,
            end: options.end
          }
        ));
      });

    };

    /**
     * @description sets data.
     *
     */
    var setData = function (layerSlug, data, zoom) {
      vectorLayers[layerSlug] = {
        data: data,
      };
    };

    return {
      getData: getData,
      setData: setData,
      isInTempExtent: isInTempExtent,
      invalidateData: invalidateData
    };
  }
]);

'use strict';

/**
 * @name NxtD3
 * @class angular.module('lizard-nxt')
  .NxtD3
 * @memberOf app
 *
 * @summary Service to create and update common d3 elements.
 *
 * @description Inject "NxtD3Service" and either extend this service
 * by calling: Child.prototype = Object.create(NxtD3Service.prototype) as
 * in the higher level graph and timeline services or use these methods
 * directly by calling NxtD3Service.<method>(<args>).
 */
angular.module('lizard-nxt')
  .factory("NxtD3", ["$rootScope", "$location", function ($rootScope, $location) {

  var createCanvas, createElementForAxis, resizeCanvas, createPathGenerator;

  /**
   * @constructor
   * @memberOf angular.module('lizard-nxt')
  .NxtD3
   *
   * @param {object} element    svg element for the graph.
   * @param {object} dimensions object containing, width, height and
   *                            an object containing top,
   *                            bottom, left and right padding.
   *                            All values in px.
   * @param {int} xDomainStart  unix-time; start of wanted domain
   * @param {int} xDomainEnd    unix-time; end of wanted domain
   */
  function NxtD3(element, dimensions, xDomain) {
    this.dimensions = angular.copy(dimensions);
    this._xDomain = xDomain;
    this._svg = createCanvas(element, this.dimensions);
  }

  NxtD3.prototype = {

    constructor: NxtD3,

    /**
     * @attribute
     * @memberOf angular.module('lizard-nxt')
     * @description        The duration of transitions in ms. Use(d)
     *                     throughout the graphs and timeline.
     */
    transTime: 300,

    /**
     * @attribute
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     * @description        Locales. Used in the axes. Currently only Dutch
     *                     is supported (and d3's default english/US en_US).
     */
    _localeFormatter: {
      'nl_NL': d3.locale({
        "decimal": ",",
        "thousands": ".",
        "grouping": [3],
        "currency": ["€", ""],
        "dateTime": "%a %b %e %X %Y",
        "date": "%d-%m-%Y",
        "time": "%H:%M:%S",
        "periods": ["AM", "PM"],
        "days": ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"],
        "shortDays": ["zo", "ma", "di", "wo", "do", "vr", "za"],
        "months": ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"],
        "shortMonths": ["jan", "feb", "mar", "apr", "mei", "jun", "jul", "aug", "sep", "okt", "nov", "dec"]
      })
    },


    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     *
     * @description Creates or modifies a clippath and features-group
     *              to the svg. Feature-group is to draw the features
     *              in, clippath is to prevent drawing outside this
     *              area.
     * @return {object} svg with clip-area and feature-group
     */
    _createDrawingArea: function () {
      var width = this._getWidth(this.dimensions),
      height = this._getHeight(this.dimensions);
      // Add clippath to limit the drawing area to inside the graph
      // See: http://bost.ocks.org/mike/path/
      //
      // NOTE: we append the height to the clippath to prevent assocating a
      // clippath with the wrong rect element. What used to happen was: the
      // elevation graph gets clipped by the clippath of the horizontalstack.
      var clip = this._svg.select('g').select("defs");
      if (!clip[0][0]) {
        clip = this._svg.select('g').append('defs').append("svg:clipPath")
        .attr('class', 'clip-path');
        clip.append("svg:rect");

      }
      clip = this._svg.select('g').select("defs").select('.clip-path')
      .attr("id", "clip" + height)
      .select('rect')
        .attr("id", "clip-rect")
        .attr("x", "0")
        // give some space to draw full stroke-width.
        .attr("y", 0 - 2)
        .attr("width", width)
        .attr("height", height + 2);
      // Put the data in this group
      var g = this._svg.select('g').select('g');
      if (!g[0][0]) {
        g = this._svg.select('g').append('g');
      }

      // Since html5 url is used we need to refer to the absolute url of the
      // clip rect
      g.attr("clip-path", "url(" + $location.absUrl() + "#clip" + height + ")")
        .attr('id', 'feature-group');
      // This url changes constantly so we set a watch.
      this._addLocationWatch(this);
      return this._svg;
    },

    /**
     * Set location watch to update absolute reference to clip-path.
     * @param {NxtD3} instance of NxtD3
     */
    _addLocationWatch: function (instance) {
      instance._locationWatch = $rootScope.$on('$locationChangeSuccess', function (e, newUrl, optOldUrl) {
        if (newUrl === optOldUrl) { return; }
        var height = instance._getHeight(instance.dimensions);
        instance._svg.select('#feature-group')
        .attr("clip-path", "url(" + newUrl + "#clip" + height + ")");
      });
    },

    /**
     * Removes listener to update absolute reference to clip-path.
     */
    destroy: function () {
      if (this._locationWatch) {
        this._locationWatch();
      }
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     *
     * @param {object} svg        d3 selection of an svg.
     * @param {object} dimensions object containing, width, height and
     *                            an object containing top,
     *                            bottom, left and right padding.
     *                            All values in px.
     * @param {array} data        Array of data objects.
     * @param {string} key (int or string) key to the values for the scale and
     *                            axis in the data element
     * @param {object} options    options object that will be passed
     *                            to the d3 scale and axis.
     * @param {boolean} y         Determines whether to return a y scale.
     * @description Computes and returns maxmin, scale and axis.
     * @return {object} containing maxmin, d3 scale and d3 axis.
     */
    _createD3Objects: function (data, key, options, y) {

      // Computes and returns maxmin scale and axis
      var width = this._getWidth(this.dimensions),
          height = this._getHeight(this.dimensions),
          d3Objects = {},
          // y range runs from height till zero, x domain from 0 to width.
          range;

      if (y) {
        range = { max: 0, min: height };
        d3Objects.maxMin = this._maxMin(data, key);
      } else {
        range = { min: 0, max: width };
        d3Objects.maxMin = (this._xDomain.start && this._xDomain.end)
          ? { min: this._xDomain.start, max: this._xDomain.end }
          : this._maxMin(data, key);
      }
      d3Objects.range = range;
      d3Objects.scale = this._makeScale(d3Objects.maxMin, range, options);
      d3Objects.axis = this._makeAxis(d3Objects.scale, options);
      return d3Objects;
    },

    /**
     * @function
     * @description give back a range based on the Dimensions
     * @param {string} - axis can either be 'y' or 'x'
     * return {object} - min and max for the pixel range
     */
    _makeRange: function (axis, dimensions) {
      var width = this._getWidth(dimensions),
          height = this._getHeight(dimensions),
          range;
      if (axis === 'y') {
        range = { max: 0, min: height };
      } else {
        range = { min: 0, max: width };
      }
      return range;
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     *
     * @param {object} dimensions object containing, width, height and
     *                            an object containing top,
     *                            bottom, left and right padding.
     *                            All values in px.
     * @description Resizes the canvas and the updates the drawing
     *              area. Does not resize the elements drawn on the
     *              canvas.
     */
    resize: function (dimensions) {
      this.dimensions = angular.extend(this.dimensions, dimensions);
      this._svg = resizeCanvas(this._svg, this.dimensions);
      this._svg = this._createDrawingArea(this._svg, this.dimensions);
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt').NxtD3
     *
     * @param {array} data        Array of data objects.
     * @param {string} key to the value in the array or object.
     * @description returns the maximum and minimum
     * @return {object} containing the max and min
     */
    _maxMin: function (data, key) {
      if (data === null || data.length < 0) {
        return {max: null, min: null};
      }

      var min, max;

      // Key can be a string or integer, or an object containing two y keys.
      if (key.hasOwnProperty
        && key.hasOwnProperty('y0')
        && key.hasOwnProperty('y1')) {
        var minComparator = function (d) { return d[key.y0]; };
        min = d3.min(data, minComparator);

        var maxComparator = function (d) { return d[key.y1]; };
        max = d3.max(data, maxComparator);
      }

      else {
        // min max of d3 filters nulls but not if you cast null into 0. Only cast
        // strings, and array like [0, [3]].
        var comparator = function (d) {
          return typeof(d[key]) === 'string' || d[key] instanceof Array
            ? Number(d[key])
            : d[key];
        };
        max = d3.max(data, comparator);
        min = d3.min(data, comparator);
      }

      return {
        max: max,
        min: min
      };
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     *
     * @param {object} minMax object containing the max and min
     * @param {object} range object contaning from where to where
     *                       the scale runs.
     * @param {object} options object what kind of scale to return
     * @description returns a d3 scale
     * @return {object} d3 scale
     */
    _makeScale: function (minMax, range, options) {
      // Instantiate a d3 scale based on min max and
      // width and height of plot
      var scale;
      if (options.scale === 'time') {
        scale = d3.time.scale()
          .domain([new Date(minMax.min), new Date(minMax.max)])
          .range([range.min, range.max]);
      } else if (options.scale === "ordinal") {
        scale = d3.scale.ordinal()
          .domain(function (d) {
            return d3.set(d.properties.event_sub_type).values();
          })
          .range(options.colors[8]);
      } else if (options.scale === "linear") {
        scale = d3.scale.linear()
          .domain([minMax.min, minMax.max])
          .range([range.min, range.max]);
      } else {
        throw new Error(options.scale + ' is not a valid d3 scale');
      }
      return scale;
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     *
     * @param {object} scale d3 scale
     * @param {object} options object containing the orientation
     *                         (bottom/left/right/top) and optionally
     *                         an overwrite for the default ticks (5).
     * @description returns a d3 axis
     * @return {object} d3 axis
     */
    _makeAxis: function (scale, options, dimensions) {
      // Make an axis for d3 based on a scale
      var decimalCount,
          axis = d3.svg.axis()
          .scale(scale)
          .orient(options.orientation);
      if (options.ticks) {
        axis.ticks(options.ticks);
      } else {
        axis.ticks(5);
      }
      if (scale.domain()[0] instanceof Date) {
        var tickFormat = this._localeFormatter.nl_NL.timeFormat.multi([
          ["%H:%M", function (d) { return d.getMinutes(); }],
          ["%H:%M", function (d) { return d.getHours(); }],
          ["%a %d", function (d) { return d.getDay() && d.getDate() !== 1; }],
          ["%b %d", function (d) { return d.getDate() !== 1; }],
          ["%B", function (d) { return d.getMonth(); }],
          ["%Y", function () { return true; }]
        ]);
        axis.tickFormat(tickFormat);
      } else {
        if (options.tickFormat) {
          axis.tickFormat(options.tickFormat);
        } else {
          var domainDiff = scale.domain()[1] - scale.domain()[0];
          if (domainDiff < 0.5) {
            axis.tickFormat(function (d) {
              return d3.format(".2f")(d);
            });
          } else if (domainDiff < 5.0) {
            axis.tickFormat(function (d) {
              return d3.format(".1f")(d);
            });
          } else {
            axis.tickFormat(
              this._localeFormatter.nl_NL.numberFormat()
            );
          }
        }
      }

      dimensions = (this.dimensions) ? this.dimensions : dimensions;

      if (options.drawGrid && dimensions) {
        var gridLength = this._getWidth(dimensions);
        axis
          .tickSize(-gridLength);
      }

      return axis;
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     *
     * @param {object} svg  d3 selection of svg
     * @param {object} axis d3 axis
     * @param {object} dimensions object containing dimensions.
     * @param {boolean} y to draw y-axis or not (x-axis).
     * @param {int} duration if specified, transitions the drawing.
     * @description Creates axis group if necessary and draws
     *              axis.
     */
    _drawAxes: function (svg, axis, dimensions, y, duration) {
      if (typeof(y) !== 'boolean') { throw new Error('Invalid input: y is not a boolean'); }
      var id = y === true ? 'yaxis': 'xaxis';
      var axisEl = svg.select('g').select('#' + id);
      if (!axisEl[0][0]) {
        axisEl = createElementForAxis(svg, id, dimensions, y);
      }
      if (duration) {
        axisEl
          .transition()
          .duration(duration)
          .call(axis);
      } else {
        axisEl
          .call(axis);
      }
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     *
     * @param {object} dimensions object containing dimensions
     * @description Deducts the left and right padding to get
     *              the actual width of the drawing area
     * @return {int} width
     */
    _getWidth: function (dimensions) {
      return dimensions.width -
        dimensions.padding.left -
        dimensions.padding.right;
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     *
     * @param {object} dimensions object containing dimensions
     * @description Deducts the bottom padding to get
     *              the actual height of the drawing area
     * @return {int} height
     */
    _getHeight: function (dimensions) {
      return dimensions.height -
        dimensions.padding.bottom;
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt').NxtD3
     *
     * @param {object} xy object containing y.scales and x.scale.
     * @param {object} keys object containing y.key and x.key.
     * @description returns a line definition for the provided scales.
     * @return {object} d3 path generator for line.
     */
    _createLine: function (xy, keys) {
      return createPathGenerator(d3.svg.line)
        .y(function (d) { return xy.y.scale(d[keys.y]); })
        .x(function (d) { return xy.x.scale(d[keys.x]); })
        // interrupt the line when no data
        .defined(function (d) { return !isNaN(parseFloat(d[keys.y])); });
    },


    /**
     * @function
     * @memberOf angular.module('lizard-nxt').NxtD3
     *s
     * @param {object} xy object containing y.scales and x.scale.
     * @param {object} keys object containing y.key and x.key.
     * @description returns an area definition for the provided scales.
     * @return {object} d3 path generator for area.
     */
    _createArea: function (xy, keys) {
      return createPathGenerator(d3.svg.area)
        .x(function(d) { return Math.round(xy.x.scale(d[keys.x]), 10); })
        .y0(function(d) { return Math.round(xy.y.scale(d[keys.y.y0]), 10); })
        .y1(function(d) { return Math.round(xy.y.scale(d[keys.y.y1]), 10); })
        // interrupt the line when no data
        .defined(function (d) {
          var y0 = !isNaN(parseFloat(d[keys.y.y0]));
          var y1 = !isNaN(parseFloat(d[keys.y.y1]));
          return y0 && y1;
        });
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     *
     * @param {int} now timestamp from epoch in ms
     * @param {object} scale d3 scale for time
     * @description draws a line.
     */
    _drawNow: function (now, scale) {
      var height = this._getHeight(this.dimensions);
      var x = scale(now);
      var nowIndicator = this._svg.select('g').select('#feature-group').select('.now-indicator');

      if (!nowIndicator[0][0]) {
        nowIndicator = this._svg.select('g').select('#feature-group').append('line')
          .attr('class', 'now-indicator')
          .style("stroke", "#c0392b") // pommegranate
          .style("stroke-width", 2);
      }
      nowIndicator
        .attr('x1', x)
        .attr('x2', x)
        .attr('y1', height)
        .attr('y2', 0);
    }
  };


  /**
   * Creates a svg canvas for drawing,
   *
   * @param  {object} svg element to create canvas.
   * @param  {object} dimensions  object containing, width, height and an
   *                              object containing top,
   *                              bottom, left and right padding. All
   *                              values in px.
   * @return {object} svg         svg.
   */
  createCanvas = function (element, dimensions) {

    var width = NxtD3.prototype._getWidth(dimensions),
        height = NxtD3.prototype._getHeight(dimensions),
        svg = d3.select(element);

    // Create the svg as big as the dimensions
    svg.attr('width', dimensions.width)
      .attr('height', dimensions.height)
      // Create a drawing group that is shifted left side padding to the right
      .append("g")
        .attr("transform", "translate(" + dimensions.padding.left + ", " + dimensions.padding.top + ")")
        // Add rect element to attach listeners
        .append('rect')
          .attr('id', 'listeners')
          .attr('width', width)
          .attr('height', height);
    return svg;
  };

  resizeCanvas = function (svg, dimensions) {
    var width = NxtD3.prototype._getWidth(dimensions),
    height = NxtD3.prototype._getHeight(dimensions);
    // Create the svg as big as the dimensions
    svg.attr('width', dimensions.width)
      .attr('height', dimensions.height)
      // Create a drawing group that is shifted left side padding to the right
      .select("g")
        .attr("transform", "translate(" + dimensions.padding.left + ", " + dimensions.padding.top + ")")
        .select('#listeners')
          .attr('width', width)
          .attr('height', height);
    return svg;
  };

  createElementForAxis = function (svg, id, dimensions, y) {
    var className = y ? 'y axis': 'x axis',
    transform = y ? 0: NxtD3.prototype._getHeight(dimensions);
    return svg.select('g').append('g')
      .attr('class', className)
      .attr('id', id)
      .attr("transform", "translate(0 ," + transform + ")");
  };

  /**
   * Returns a d3 path.
   *
   * The path used to have .interpolate('monotone') to create a smoothed
   * line through datapoints, but it makes lines messy when data is missing.
   * Currently no interpolation is used.
   *
   * @param  {object} d3Generator d3 [line|area] generator function.
   * @return {object}             d3 path generator.
   */
  createPathGenerator = function (d3Generator) {
    // Monotone line goes through all datapoints. Other options are 'basis'
    // which looks nice but can give inaccurate results, or 'cardinal' which
    // results in a line with a bigger domain/amplitute than the data.
    return d3Generator();
  };


  return NxtD3;

}]);


/**
 * Service to draw click feedback.
 */
angular.module('lizard-nxt')
  .service('ClickFeedbackService', ['$rootScope', 'LeafletService',
  function ($rootScope, LeafletService) {
    var ClickLayer = function () {

      /**
       * @description Removes clicklayer, adds a new one.
       *              Clicklayer has a default color, opacity
       *              and a way to transform points.
       * @param {object} mapState
       */
      this.emptyClickLayer = function (mapState) {
        clearInterval(this._vibration);

        if (this.clickLayer) {
          mapState.removeLeafletLayer(this.clickLayer);
        }

        this.clickedPoints = [];

        this.clickLayer = LeafletService.geoJson(null, {
          style: function (feature) {
            return {
              name: 'click',
              clickable: true,
              color: '#c0392b',
              stroke: '#c0392b',
              opacity: 0.8,
              'stroke-opacity': 0.8,
              radius: getRadius(feature),
            };
          }
        });

        var self = this;
        this.drawPointsAsCircleMarker(self);

        // Hack to make click on the clicklayer bubble down to the map it is
        // part of.
        this.clickLayer.on('click', function (e) {
            this._map.fire('click', e);
          }
        );

        mapState.addLeafletLayer(this.clickLayer);
      };

      this.remove = function () {
        this.clickLayer = null;
      };

      this.drawPointsAsCircleMarker = function (self) {
        // Explain leaflet to draw points as circlemarkers.
        this.clickLayer.options.pointToLayer = function (feature, latlng) {
          var circleMarker = L.circleMarker(latlng, {
            radius: 0,
            weight: self.strokeWidth,
            fill: false,
            zIndexOffset: 1000,
            clickable: true
          });
          self._circleMarker = circleMarker;
          return circleMarker;
        };
      };

      /**
       * Returns the svg as a d3 selection of leaflet layer.
       *
       * @param  {object} layer
       * @return {object} the svg of the leaflet object layer
       */
      this._getSelection = function (layer, _id) {
        // Due to some leaflet obscurity you have to get the first item with an
        // unknown key.
        var _layers = layer._layers;
        var selection;
        if (_id) {
          selection = d3.select(_layers[_id]._container);
        } else {
          for (var key in _layers) {
            selection = d3.select(_layers[key]._container);
            // Don't break, because we need the latest item;
          }
        }
        return selection;
      };

      /**
       * @description add data to the clicklayer
       * with a small hackery to find out this specific id
       */
      this.drawFeature = function (geojson, strokeSize) {
        this.strokeWidth = strokeSize || 5;
        var oldIds = Object.keys(this.clickLayer._layers);

        // actually add the data
        this.clickLayer.addData(geojson);

        // check id.
        var newIds = Object.keys(this.clickLayer._layers);
        var newId;
        angular.forEach(newIds, function (item) {
          if (oldIds.indexOf(item) < 0) {
            newId = item;
          }
        });
        return newId;
      };

      /**
       * @function drawLineElement
       * @memberof clickFeedbackService
       * @summary Draws a line between the given points.
       * @description Draws a line between `first` and `second`. If `first` or
       * `second` don't exist, return. If `dashed` is `true`, draw a dashed
       * line.
       *
       * @param  {L.LatLng} first - start of the line
       * @param  {L.LatLng} second - end of the line
       * @param  {boolean} dashed - when true draws a dashed line
       */
      this.drawLineElement = function (first, second, dashed) {

        if (first === undefined || second === undefined) {
          return;
        }

        var oldIds = Object.keys(this.clickLayer._layers);

        this.strokeWidth = 3;

        var geojsonFeature = { "type": "Feature" };
        geojsonFeature.geometry = {
          "type": "LineString",
          "coordinates": [[first.lng, first.lat], [second.lng, second.lat]]
        };


        if (dashed) {
          this.clickLayer.options.style.dashArray = "5, 5";
        }

        this.clickLayer.addData(geojsonFeature);

        // check id.
        var newIds = Object.keys(this.clickLayer._layers);
        var newId;
        angular.forEach(newIds, function (item) {
          if (oldIds.indexOf(item) < 0) {
            newId = item;
          }
        });
        var sel = this._selection = this._getSelection(this.clickLayer, newId);
        this.vibrate(sel);
        return newId;
      };

      /**
       * @description vibrates the features in the clickLayer.
       */
      this.vibrateFeatures = function (id) {
        var sel = this._selection = this._getSelection(this.clickLayer, id);
        clearInterval(this._vibration);
        var vibrate = this.vibrate;
        var self = this;
        this._vibration = setInterval(
          function () { vibrate.call(self, sel, false); }, 400);
      };

      /**
       * @describtion Vibrate the features in the clicklayer once.
       *
       * @param  {geojson} geojson if provided draws the features in
       *                           the geojson, vibrates it and removes it.
       */
      this.vibrateOnce = function (geojson, layerId) {
        var sel = this._selection = this._getSelection(this.clickLayer, layerId);
        var remove = false;
        if (geojson) {
          sel = this._getSelection(this.clickLayer, this.drawFeature(geojson));
          //sel = this._selection = this._getSelection(this.clickLayer);
          remove = true;
        }
        this.vibrate(sel, remove);
      };

      /**
       * @description add a locationMarker as a leaflet marker with
       *              a leaflet divIcon. Overwrites the pointTolayer
       *              of the clicklayer.
       * @param {object} mapState nxt mapState
       * @param {L.latLng} latLng location of marker
       */
      this.addLocationMarker = function (mapState, latLng) {
        var divIcon = L.divIcon({
          className: 'selected',
          iconAnchor: [10, 48],
          html: '<svg width=20 height=48><path d="M10,16'
            + 'c-5.523 0-10 4.477-10 10 0 10 10 22 10 22'
            + 's10-12 10-22c0-5.523-4.477-10-10-10z M10,32'
            + ' c-3.314 0-6-2.686-6-6s2.686-6 6-6 6 2.686'
            + ' 6 6-2.686 6-6 6z"></path></svg>'
        });

        this.clickLayer.options.pointToLayer = function (feature, latlng) {
          return L.marker(latlng, {
            icon: divIcon,
            clickable: true
          });
        };

      };

      /**
       * @descriptions vibretes a selection.paths by varying the stroke-width
       * @param  {object} sel selection contaning a path.
       * @param  {boolean} remove to remove or not. When true, stroke-width
       *                          is set to 0 at the end the vibration.
       */
      this.vibrate = function (sel, remove) {
        if (sel.empty()) { return; } // bail when empty
        var width = this.strokeWidth;

        sel.selectAll("path")
          .classed("vibrator", true)
          .attr("stroke-width", function () { return width * 2; })
          .transition().duration(200)
          .attr("stroke-width", function () { return width * 3; })
          .transition().duration(200)
          .attr("stroke-width", function () { return remove ? 0 : width; });
      };

      /**
       * @description returns specific radius for water-objects coming from
       *              the utfGrid
       * @param  {object} geojson feature containing the entity_name of the
       *                           water-object
       * @return {int}             radius
       */
      var getRadius = function (feature) {
        var radius = 0;

        if (feature.properties) {
          var entityName = feature.properties.entity_name,
              entityType = feature.properties.type;
          radius = feature.properties.radius || 0;
          if (entityName) {
            radius = 12;
            if (entityName === "pumpstation" && entityType !== "Rioolgemaal") {
              radius =  13;
            } else if (entityType === "Rioolgemaal" || entityName === "weir") {
              radius =  11;
            } else if (entityName === "bridge" || entityName === "manhole") {
              radius =  14;
            }
          }
        }

        return radius;
      };

    };

    var clickLayer = new ClickLayer(),
        emptyClickLayer,
        removeClickFromClickLayer,
        drawCircle,
        updateCircle,
        drawArrow,
        drawLine,
        drawGeometry,
        startVibration,
        vibrateOnce,
        removeLayer,
        removeLeafletLayerWithId;

    /**
     * @description should remove that exact click that is wanting to be
     * removed from the map
     * @params {object} LatLng object
     */
    removeClickFromClickLayer = function (toBeRemovedClick) {
      if (clickLayer.clickLayer
        && toBeRemovedClick in clickLayer.clickLayer._layers) {
        clickLayer.clickLayer.removeLayer(toBeRemovedClick);
      }
    };


    /**
     * @description empties the clicklayer.
     */
    emptyClickLayer = function (mapState) {
      clickLayer.emptyClickLayer(mapState);
    };

    /**
     * Draws visible feedback on the map after a click.
     *
     * Removes possible click feedback layer and creates a new clickLayer
     * containing a circle.
     *
     * @param {object} latLng Leaflet object specifying the latitude
     * and longitude of a click
     */
    drawCircle = function (mapState, latlng, dontEmpty, strokeSize) {
      if (!dontEmpty) {
        clickLayer.emptyClickLayer(mapState);
      }
      var geometry = {
        "type": "Point",
        "coordinates":
          [latlng.lng, latlng.lat]
      };
      return clickLayer.drawFeature(geometry, strokeSize);
    };

    /**
     * Updates circle with new position
     */
    updateCircle = function (mapState, latlng, id) {
      var layer = mapState.getLeafletLayer(id);
      d3.select(layer._container).select('path')
        .attr('stroke-width', 15);
      layer._latlng = latlng;
      layer.redraw();
    };

    /**
     * Removes leafletLayer
     */
    removeLeafletLayerWithId = function (mapState, id) {
      var layer = mapState.getLeafletLayer(id);
      mapState.removeLeafletLayer(layer);
    };

    drawGeometry = function (mapState, geometry, entityName) {
      if (!clickLayer.clickLayer) {
        clickLayer.emptyClickLayer(mapState);
      }
      clickLayer.drawPointsAsCircleMarker(clickLayer);
      return clickLayer.drawFeature(geometry);
    };

    /**
     * @function drawArrow
     * @memberof ClickFeedbackService
     * @summary Draws an arrow at latLng.
     * @description Draws arrow at specified location to indicate click. Used
     * to indicate location of rain graph. Returns void if latLng doesn't exist.
     *
     * @param {object} mapState - the mapState object, which assumes the key
     *   'here' to be defined.
     */
    drawArrow = function (mapState, latLng) {

      if (latLng === undefined) {
        return;
      }

      if (!clickLayer.clickLayer) {
        clickLayer.emptyClickLayer(mapState);
      }
      var geometry = {
        "type": "Point",
        "coordinates": [latLng.lng, latLng.lat]
      };
      clickLayer.addLocationMarker(mapState, latLng);
      return clickLayer.drawFeature(geometry);
    };

    drawLine = function (mapState, first, second, dashed) {
      if (!clickLayer.clickLayer) {
        clickLayer.emptyClickLayer(mapState);
      }
      return clickLayer.drawLineElement(first, second, dashed);
    };

    startVibration = function (id) {
      clickLayer.vibrateFeatures(id);
    };

    vibrateOnce = function (geojson, id) {
      clickLayer.vibrateOnce(geojson, id);
    };

    removeLayer = function () {
      clickLayer.remove();
    };

    return {
      emptyClickLayer: emptyClickLayer,
      drawArrow: drawArrow,
      drawCircle: drawCircle,
      drawGeometry: drawGeometry,
      startVibration: startVibration,
      drawLine: drawLine,
      removeClickFromClickLayer: removeClickFromClickLayer,
      removeLeafletLayerWithId: removeLeafletLayerWithId,
      vibrateOnce: vibrateOnce,
      updateCircle: updateCircle,
      remove: removeLayer
    };
  }
]);


/**
 * @ngdoc service
 * @class EventAggregateService
 * @name EventAggregateService
 * @summary Event aggregation functions.
 * @description Functions to aggregate event series over time with d3
 */
angular.module('lizard-nxt')
  .service("EventAggregateService", ["UtilService", function (UtilService) {

    var that = this; // the mind's a terrible thing to taste 8)

    this.colorScales = {};
    this.colorMaps = {};
    this.categoryIndex = {};

    /**
     * @function getColorMap
     * @summary Helper function to get colormap from outside this module.
     * @description Helper function to get colormap from outside this module.
     *
     * @param {string} baseColor - hex color string.
     * @returns {object} colormap.
     */
    this.getColorMap = function (baseColor) {
      return that.colorMaps[baseColor];
    };

    /**
     * @function timeCatComparator
     * @summary comparator function to use for javascript array sort.
     *
     * @description Sorts arrays of object on properties timestamp and category
     */
    var timeCatComparator = d3.comparator()
      .order(d3.ascending, function (d) { return d.timestamp; })
      .order(d3.ascending, function (d) { return d.category; });

    /**
     * @function _buildColorScale
     * @summary Build color scale based on base color and number of classes.
     * @description Build color scale based on base color.
     *
     * @param {string} baseColor - hex color string.
     * @param {integer} numClasses - number of classes to build.
     * @returns {array[]} list of hex colors.
     */
    var _buildColorScale = function (baseColor, numClasses) {

      var MAX_CATS = 7;
      numClasses = Math.min(numClasses, MAX_CATS);

      var i,
          derivedColors = [],
          baseColorTriple = UtilService.hexColorToDecimalTriple(baseColor),
          shifts = _.map([0, 1, 2], function (i) {
            return Math.round((255 - baseColorTriple[i]) / numClasses);
          });

      _.each(_.range(numClasses), function (i) {
        derivedColors.push(_.map([0, 1, 2], function (j) {
          return baseColorTriple[j] + i * shifts[j];
        }));
      });

      return derivedColors.map(UtilService.decimalTripleToHexColor);
    };

    /**
     * @function _getColor
     * @summary helper function to get color for category
     *
     * @param {string} categoryName  - Name of the current category.
     * @param {string} baseColor     - Hex color.
     * @returns {string} HTML HEX color code.
     */
    var _getColor = function (

      categoryName,
      baseColor

      ) {

      // if colorscale doesn't exist yet, build a new one plus a new colormap.
      if (!that.colorScales.hasOwnProperty(baseColor)) {
        that.colorScales[baseColor] = _buildColorScale(baseColor, 7);
        that.colorMaps[baseColor] = {};
        that.categoryIndex[baseColor] = 0;
      }

      // if entry for categoryName doesn't exist yet, make one and assign a
      // color from colorscale.
      if (!that.colorMaps[baseColor].hasOwnProperty(categoryName)) {
        that.colorMaps[baseColor][categoryName] =
          that.colorScales[baseColor][that.categoryIndex[baseColor]++];
      }

      return that.colorMaps[baseColor][categoryName];
    };

    /**
     * @function _getValue
     * @summary helper function to get value property of geojson feature.
     *
     * @param {object} d - geojson feature.
     * @returns {float} value field of properties.
     */
    var _getValue = function (d) {return parseFloat(d.properties.value); };

    /**
     * @function _getTimeIntervalDats
     * @summary helper function to get difference between timestamp_end and
     * timestamp_start
     *
     * @param {object} d - geojson feature.
     * @returns {integer} time interval in days.
     */
    var _getTimeIntervalDays = function (d) {
      return (d.properties.timestamp_end - d.properties.timestamp_start) /
              1000 / 60 / 60 / 24;
    };

    /**
     * @function aggregate
     * @memberOf EventAggregateService
     * @summary Aggregates list of geojson features by category.
     *
     * @description Uses d3.nest() to aggregate lists of geojson events by
     * interval and category, additionaly returns average duration of events
     * when timestamp_start and timestamp_end are set.
     *
     * When the `value` property of a feature is a `float` or `int`, additional
     * statistics are calculated: min, max, sum, mean,
     *
     * If data is empty returns empty array.
     *
     * @param {object[]} data - list of event geojson features.
     * @param {integer} aggWindow - aggregation window in ms.
     * @param {string} baseColor - hex color.
     * @returns {array} - array of objects with keys
     *   for ordinal en nominal:
     *     timestamp, category, count, mean_duration
     *
     *   for ratio and interval:
     *     timestamp, mean, min, max,
     *
     */
    this.aggregate = function (data, aggWindow, baseColor) {

      if (data.length === 0) {
        return [];
      }

      var isString = true,
          // isString = isNaN(parseFloat(data[0].properties.value)),
          nestedData = {},
          aggregatedArray = [],
          timestampKey = function (d) {
            var start;
            if(d.properties.hasOwnProperty('timestamp')) {
              start = d.properties.timestamp;
            } else {
              start = d.properties.timestamp_start;
            }
            return UtilService.roundTimestamp(start, aggWindow);
          };

      if (baseColor === undefined) {

        nestedData = d3.nest()
          .key(timestampKey)
          .rollup(function (leaves) {
            var stats = {
              count: leaves.length,
            };

            return stats;
          })
          .map(data, d3.map);

        // rewrite d3 nested map to array of flat objects
        nestedData
          .forEach(function (timestamp, value) {
            var tmpObj = {
              timestamp: Number(timestamp) + aggWindow,
              count: value.count,
              interval: aggWindow
            };
            aggregatedArray.push(tmpObj);
          }
        );

      // if value is string, data is nominal or ordinal, calculate counts
      // per cateogry
      } else if (isString) {

        nestedData = d3.nest()
          .key(timestampKey)
          .key(function (d) {return d.properties.category; })
          .rollup(function (leaves) {
            var stats = {
              "count": leaves.length,
              "mean_duration": d3.mean(leaves, _getTimeIntervalDays)
            };
            return stats;
          })
          .map(data, d3.map);

        // rewrite d3 nested map to array of flat objects
        nestedData
          .forEach(function (timestamp, value) {
            var tmpObj;
            value.forEach(function (category, value) {
              tmpObj = {
                timestamp: Number(timestamp) + aggWindow,
                category: category,
                mean_duration: value.mean_duration,
                color: _getColor(category,
                                 baseColor),
                count: value.count,
                interval: aggWindow
              };
              aggregatedArray.push(tmpObj);
            });
          }
        );

        // sort array by timestamp and category
        aggregatedArray.sort(timeCatComparator);
      } else {

        nestedData = d3.nest()
          .key(timestampKey)
          .rollup(function (leaves) {
            var stats = {
              count: leaves.length,
              min: d3.min(leaves, _getValue),
              max: d3.max(leaves, _getValue),
              mean: d3.mean(leaves, _getValue),
              median: d3.median(leaves, _getValue),
              sum: d3.sum(leaves, _getValue),
              mean_duration: d3.mean(leaves, _getTimeIntervalDays),
            };

            return stats;
          })
          .map(data, d3.map);

        // rewrite d3 nested map to array of flat objects
        nestedData
          .forEach(function (timestamp, value) {
            var tmpObj = {
              color: baseColor,
              timestamp: Number(timestamp) + aggWindow,
              mean_duration: value.mean_duration,
              min: value.min,
              max: value.max,
              mean: value.mean,
              median: value.median,
              sum: value.sum,
              count: value.count
            };
            aggregatedArray.push(tmpObj);
          }
        );

      }

      return aggregatedArray;
    };

  }]);

angular.module('lizard-nxt')
.service("CSVService",

  [

  "UtilService",
  "DataService",
  "State",

  function (

    UtilService,
    DataService,
    State

    ) {

    // CONSTANTS

    var NO_DATA_MSG = "Geen waarde bekend",
        TOO_MUCH_DATA_MSG = "De door u getrokken lijn of het temporeel interval is te lang. Er zijn te veel metingen om in een CSV weer te geven: ",
        COORD_DECIMAL_COUNT = 8,
        DUTCHIFY_TIMESTAMPS = true,
        MAX_ROW_COUNT = 50000;

    // PUBLIC /////////////////////////////////////////////////////////////////

    /**
     * @description - Delegates between the two CSV generating functions, one
     *                for temporal rasters and on for non-temporal rasters.
     * @param {string} lgSlug - The slug for the layergroup we want to intersect.
     * @param {object} layer - The layer we want to intersect.
     * @return {object} - Array of arrays result, which can be formatted to an
     *                               actual CSV by the ng-csv directive.
     */
    this.formatLineCSV = function (lgSlug, layer) {
      if (layer.data) {
        return _dataIsTemporal(lgSlug)
          // NB! Sometimes a resolved API call uses layer.data for housing it's
          // raw response, and sometimes it uses layer.temporalData; in the latter
          // case layer.data is already needed for the Graph svc, where D3 requires
          // specifically formatted data:
          ? _formatLineCSVTemporal(layer.temporalData || layer.data, lgSlug)
          : _formatLineCSVNonTemporal(layer.data);
      } else {
        _throwDataError(layer);
      }
    };

    /*
     * @description - Get the column names for CSV
     * @param {string} lgSlug - The slug for the layergroup we want to intersect.
     * @param {object} layer - The layer we want to intersect.
     * @return {string[]} - A list with the column names.
     */
    this.getLineCSVHeaders = function (lgSlug, layer) {

      var DEFAULT_HUMAN_READABLE_X = "Afstand [m]",
          humanReadableX = {
            // someLGslug: someHumanReadableXforThatLG
          }[lgSlug] || DEFAULT_HUMAN_READABLE_X,
          humanReadableY = layer.quantity + ' [' + layer.unit + ']';

      if (layer.data) {
        return _dataIsTemporal(lgSlug)
          ? [ 'Timestamp',
              humanReadableX,
              humanReadableY,
              'Lijn start (latitude)',
              'Lijn start (longitude)',
              'Lijn eind (latitude)',
              'Lijn eind (longitude)'
          ]
          : [
              humanReadableX,
              humanReadableY,
              'Lijn start (latitude)',
              'Lijn start (longitude)',
              'Lijn eind (latitude)',
              'Lijn eind (longitude)'
          ];
      } else {
        _throwDataError(layer);
      }
    };

    // PRIVATE ////////////////////////////////////////////////////////////////

    /**
     * @description - Throws error because insufficient data.
     * @param {object} layer - The layer we want to intersect.
     * @return {void}
     */
    var _throwDataError = function (layer) {
      throw new Error(
        "Cannot format CSV since the specified layer has not enough data. layer.slug =" + layer.slug
      );
    };

    /**
     * @description - Throws error because incorrect layergroup slug.
     * @param {object} lgSlug - The slug for the layergroup we want to intersect.
     * @return {void}
     */
    var _throwLayerGroupError = function (lgSlug) {
      throw new Error(
        "No layerGroup retrievable from DataService when using the slug: " + lgSlug
      );
    };

    /**
     * @description - Check whether a layergroup has a temporal component.
     * @param {string} lgSlug - The slug for the layergroup we want to intersect.
     * @return {boolean}
     */
    var _dataIsTemporal = function (lgSlug) {
      var lg = DataService.layerGroups[lgSlug];
      if (lg !== undefined) {
        return lg.isTemporal();
      } else {
        _throwLayerGroupError(lgSlug);
      }
    };

    var _getStoreResolution = function (lgSlug) {
      var lg = DataService.layerGroups[lgSlug];
      if (lg !== undefined && lg.temporalResolution) {
        return lg.temporalResolution;
      } else {
        _throwLayerGroupError(lgSlug);
      }
    };

    /**
     * @description - Get start-/end coordinates for current line.
     * @return {float[]} - A list with the 4 floats denoting the start-/end of
     *                     the line.
     */
    var _getLineCoordinates = function () {
      var lineGeom = State.selected.geometries[0].geometry;
      return {

        startLat: UtilService.formatNumber(UtilService.round(
          lineGeom.coordinates[0][0], COORD_DECIMAL_COUNT
        ), 0, COORD_DECIMAL_COUNT, true),

        startLng: UtilService.formatNumber(UtilService.round(
          lineGeom.coordinates[0][1], COORD_DECIMAL_COUNT
        ), 0, COORD_DECIMAL_COUNT, true),

        endLat: UtilService.formatNumber(UtilService.round(
          lineGeom.coordinates[1][0], COORD_DECIMAL_COUNT
        ), 0, COORD_DECIMAL_COUNT, true),

        endLng: UtilService.formatNumber(UtilService.round(
          lineGeom.coordinates[1][1], COORD_DECIMAL_COUNT
        ), 0, COORD_DECIMAL_COUNT, true)
      };
    };

    /**
     * @description - Make timestamps readable for dutch-only people
     * @param {integer} epoch - Seconds since 1970-01-01 00:00:00 .
     * @return {string} - Timestamp in "horlogetijd"
     */
    var _dutchifyTimestamp = function (epoch) {

      var d = new Date(epoch),
          datePart = [
            d.getDate(),
            d.getMonth() + 1,
            d.getFullYear()
          ].join('-'),
          timePart = [
            d.getHours() || "00",
            d.getMinutes() || "00",
            d.getSeconds() || "00"
          ].join(':');

      return timePart + " " + datePart;
    };

    /**
     * @description - format the CSV data (non-temporal raster data)
     * @param {number[][]} data - The data to be formatted.
     * @return {number[][]} - the formatted data
     */
    var _formatLineCSVNonTemporal = function (data) {

      var i,
          datum,
          result = [],
          coords = _getLineCoordinates(),
          startLat = coords.startLat,
          startLng = coords.startLng,
          endLat = coords.endLat,
          endLng = coords.endLng;

      if (data.length > MAX_ROW_COUNT) {
        return [[TOO_MUCH_DATA_MSG + data.length]];
      }

      for (i = 0; i < data.length; i++) {
        datum = data[i];
        if (datum[1] === null) { continue; }
        result.push([
          typeof data[i][0] === 'number'
            ? UtilService.formatNumber(UtilService.round(datum[0], 2), 0, 2, true)
            : NO_DATA_MSG,
          typeof data[i][1] === 'number'
            ? UtilService.formatNumber(UtilService.round(datum[1], 2), 0, 2, true)
            : NO_DATA_MSG,
          startLat,
          startLng,
          endLat,
          endLng
        ]);
      }
      return result;
    };

    /**
     * @description - format the CSV data (temporal raster data)
     * @param {number[][]} data - The data to be formatted.
     * @return {number[][]} - the formatted data
     */
    var _formatLineCSVTemporal = function (data, lgSlug) {

      var t,
          i,
          datum,
          result = [],
          timestamp,
          coords = _getLineCoordinates(),
          startLat = coords.startLat,
          startLng = coords.startLng,
          endLat = coords.endLat,
          endLng = coords.endLng,
          amountOfTimestamps = data.length,
          tempExtentInterval = State.temporal.end - State.temporal.start,
          // Assumption which holds when measurements (i) are present for full
          // temp.extent and (ii) are equidistant with distance equal to aggWindow:
          durationPerMeasurement = _getStoreResolution(lgSlug);

      if (amountOfTimestamps * data[0][1].length > MAX_ROW_COUNT) {
        return [[TOO_MUCH_DATA_MSG + amountOfTimestamps * data.length]];
      }

      var roundedStartTime = State.temporal.start - (
        State.temporal.start % durationPerMeasurement
      );

      for (t = 0; t < amountOfTimestamps; t++) {

        timestamp = DUTCHIFY_TIMESTAMPS
          ? _dutchifyTimestamp(roundedStartTime + (t * durationPerMeasurement))
          : roundedStartTime + (t * durationPerMeasurement);

        datum = data[t];
        for (i = 0; i < datum[1].length; i++) {
          var datum_ = datum[1][i];
          result.push([
            timestamp,
            typeof datum_[0] === 'number'
              ? UtilService.formatNumber(UtilService.round(datum_[0], 2), 0, 2, true)
              : NO_DATA_MSG,
            typeof datum_[1] === 'number'
              ? UtilService.formatNumber(UtilService.round(datum_[1], 2), 0, 2, true)
              : NO_DATA_MSG,
            startLat,
            startLng,
            endLat,
            endLng,
          ]);
        }
      }
      return result;
    };
}]);

/**
 * @ngdoc service
 * @class DragulaService
 * @memberof app
 * @name DragulaService
 * @description Trivial wrapper for global dragula object.
 *
 * Perhaps in the future this can be done with CommonJS style requires.
 */
angular.module('lizard-nxt')
.service('DragService', [function () {

  var dragula;

  if (window.dragula) {
    dragula =  window.dragula;
  } else {
    throw new Error('Dragula can not be found');
  }

  var drake;
  var dragContainer;
  var dropContainer;

  /**
   * Return true if el is a child of the dropContainer or if the dropContainer
   * has no children and el is the dropContainer.
   *
   * @param  {DOM element}  el
   * @return {Boolean}
   */
  var isDropContainerOrChild = function (el) {
    var itIs = false;
    if (dropContainer === undefined) { return false; }

    if (!dropContainer.children.length && el === dropContainer) {
      itIs = true;
    }
    else if (dropContainer.children.length
      // element.children contains an HTMLCollection object, which does not have
      // an indexOf method. Lodash to the rescue.
      && _.indexOf(dropContainer.children, el) !== -1) {
      itIs = true;
    }

    return itIs;
  };

  /**
   * Recursively searches for dropContainer in element and
   * element.parentElement.
   *
   * @param  {DOM element}  el DOM element.
   * @return {Boolean} is dropContainer or in dropcontainer.
   */
  var isDropContainerOrDescendant = function (el) {
    if (isDropContainerOrChild(el)) {
      return true;
    } else if (el.parentElement) {
      return isDropContainerOrDescendant(el.parentElement);
    } else { return false; }
  };

  var addContainer = function (el) {
    drake.containers.push(el);
  };

  var createDrake = function () {

    drake = dragula({

      direction: 'horizontal',

      // Dynamically accept all existing graphs in dashboard as valid dropzones.
      isContainer: function (el) {
        return el.classList.contains('drag-target');
      },

      // Elements cannot be dragged into the dragContainer
      accepts: function (el, target) {
        return target !== dragContainer;
      },

      // Dropcontainer elements cannot be dragged.
      invalid: isDropContainerOrDescendant,

      copy: true, // Keep original in place.
      revertOnSpill: true // Spilling puts element back where it was dragged from.

    });

  };

  return {

    /**
     * Adds a container with draggable elements in it to the "drake". Makes
     * all children elements draggable.
     *
     * @param {Angular.element} element Angular element containing draggable
     *                                  elements.
     */
    addDraggableContainer: function (element) {
      dragContainer = element[0];
      addContainer(dragContainer);
      return drake;
    },

    /**
     * Adds a container of drop zones. Drops can be made in element or
     * element.children
     *
     * @param {Angular.element} element Angular element containing dropzones.
     */
    addDropZone: function (element) {
      dropContainer = element[0];
      return drake;
    },

    on: function (type, cb) {
      drake.on(type, cb);
    },

    destroy: function () {
      drake.destroy();
    },

    create: function () {
      createDrake();
    }

  };

}]);

'use strict';

/**
 * Lizard-nxt filters
 *
 * Overview
 * ========
 *
 * Defines custom filters
 *
 */

angular.module('lizard-nxt-filters', []);

/**
 * Filter to order objects instead of angulars orderBy
 * that only orders array
 */
angular.module('lizard-nxt-filters')
  .filter('orderObjectBy', function () {
  return function (items, field, reverse) {
    var filtered = [];
    angular.forEach(items, function (item) {
      filtered.push(item);
    });
    filtered.sort(function (a, b) {
      return (a[field] > b[field] ? 1 : -1);
    });
    if (reverse) { filtered.reverse(); }
    return filtered;
  };
});


/**
 * Returns a rounded number or a '...' based on input type.
 *
 * @param {string} input to round or convert to dash, can be string or number
 * @param {number} optional decimals to round the number to
 * @return {string} when input is a number: returns a number
 * rounded to specified decimals else returns '-'
 */
angular.module('lizard-nxt-filters')
  .filter('niceNumberOrEllipsis', function () {
  return function (input, decimals) {
    var out;
    if (typeof(input) === 'number') {
      var factor = 1;
      if (decimals) {
        factor = Math.pow(10, decimals);
      }
      out = Math.round(input * factor) / factor;
    } else {
      out = '...';
    }
    return out;
  };
});

// lookups: manhole

angular.module('lizard-nxt-filters')
  .filter('lookupManholeShape', function () {
  return function (input) {
    var out;
    switch (input) {
    case '0.0':
      out = 'vierkant';
      break;
    case '1.0':
      out = 'rond';
      break;
    case '2.0':
      out = 'rechthoekig';
      break;
    case '00':
      out = 'vierkant';
      break;
    case '01':
      out = 'rond';
      break;
    case '02':
      out = 'rechthoekig';
      break;
    default:
      out = 'Afwijkende vorm';
    }
    return out;
  };
});

angular.module('lizard-nxt-filters')
  .filter('lookupManholeMaterial', function () {
  return function (input) {
    var out;
    switch (input) {
    case '0.0':
      out = 'beton';
      break;
    case '1.0':
      out = 'PVC';
      break;
    case '2.0':
      out = 'gres';
      break;
    case '00':
      out = 'beton';
      break;
    case '01':
      out = 'PVC';
      break;
    case '02':
      out = 'gres';
      break;
    default:
      out = 'Materiaal afwijkend';
    }
    return out;
  };
});

// lookups: culvert

angular.module('lizard-nxt-filters')
  .filter('lookupCulvertShape', function () {
  return function (input) {
    var out;
    switch (input) {
    case '0':
      out = 'rond';
      break;
    case '1':
      out = 'eivorm';
      break;
    case '2':
      out = 'rechthoek';
      break;
    case '3':
      out = 'muilvorm';
      break;
    case '4':
      out = 'vierkant';
      break;
    case '5':
      out = 'heul';
      break;
    case '6':
      out = 'trapezium';
      break;
    case '98':
      out = 'Vorm afwijkend';
      break;
    case '99':
      out = 'Vorm onbekend';
      break;
    default:
      out = 'Vorm afwijkend';
    }
    return out;
  };
});

angular.module('lizard-nxt-filters')
  .filter('lookupCulvertMaterial', function () {
  return function (input) {
    var out;
    switch (input) {
    case '0':
      out = 'beton';
      break;
    case '1':
      out = 'PVC';
      break;
    case '2':
      out = 'gres';
      break;
    default:
      out = 'Materiaal afwijkend';
    }
    return out;
  };
});

// lookups: weir

angular.module('lizard-nxt-filters')
  .filter('lookupWeirControl', function () {
  return function (input) {
    var out;
    switch (input) {
    case '1':
      out = 'Vast';
      break;
    case '2':
      out = 'Regelbaar, niet auto';
      break;
    case '3':
      out = 'Regelbaar, auto';
      break;
    case '4':
      out = 'Handmatig';
      break;
    case '98':
      out = 'Overig';
      break;
    default:
      out = 'Niet bekend';
    }
    return out;
  };
});


// lookups: levee

angular.module('lizard-nxt-filters')
  .filter('lookupLeveeType', function () {
  return function (input) {
    var out;
    switch (input) {
    case 1:
      out = 'Primair';
      break;
    case 2:
      out = 'Regionaal';
      break;
    case 3:
      out = 'c-type';
      break;
    default:
      out = 'Afwijkend type';
    }
    return out;
  };
});

angular.module('lizard-nxt-filters')
  .filter('lookupLeveeReferencePointType', function () {
  return function (input) {
    var out;
    switch (input) {
    case 1:
      out = 'Dijkpaal';
      break;
    case 2:
      out = 'Virtueel';
      break;
    default:
      out = 'Afwijkend type';
    }
    return out;
  };
});


angular.module('lizard-nxt-filters')
  .filter('allowedFlowDirection', function () {
  return function (input) {
    var out;
    if (input !== null && input !== undefined) {
      out = input;
    } else {
      out = '...';
    }
    return out;
  };
});


angular.module('lizard-nxt-filters')
  .filter('lookupPumpStationType', function () {
  return function (input) {
      switch (input) {
      case 'HOUSEHOLD':
        return 'Drukgemaal';
      case 'SEWER':
        return 'Rioolgemaal';
      case 'TRANSPORT':
        return 'Transportgemaal';
      case 'UNDER':
        return 'Onderbemaling';
      case 'POLDER':
        return 'Poldergemaal';
      case 'BOSOM':
        return 'Boezemgemaal';
      case 'OTHER':
        return 'Gemaaltype afwijkend';
      default:
        return 'Gemaaltype onbekend';
      }
    };
});

angular.module('lizard-nxt-filters')
  .filter('lookupPipeType', function () {
  return function (input) {
    var out;
    switch (input) {
    case '00':
      out = 'Gemengde leiding';
      break;
    case '01':
      out = 'Regenwaterleiding';
      break;
    case '02':
      out = 'Vuilwaterleiding';
      break;
    case '03':
      out = 'Transportleiding';
      break;
    case '04':
      out = 'Overstortleiding';
      break;
    case '05':
      out = 'Zinker';
      break;
    case '06':
      out = 'Bergingsleiding';
      break;
    case '07':
      out = 'Berg-/Bezinkleiding';
      break;
    default:
      out = 'Leidingtype afwijkend';
    }
    return out;
  };
});

angular.module('lizard-nxt-filters')
  .filter('lookupPipeShape', function () {
  return function (input) {
    var out;
    switch (input) {
    case '0.0':
      out = 'rond';
      break;
    case '1.0':
      out = 'eivorm';
      break;
    case '2.0':
      out = 'rechthoek';
      break;
    case '4.0':
      out = 'vierkant';
      break;
    case '00':
      out = 'rond';
      break;
    case '01':
      out = 'eivorm';
      break;
    case '02':
      out = 'rechthoek';
      break;
    case '04':
      out = 'vierkant';
      break;
    default:
      out = 'Vorm afwijkend';
    }
    return out;
  };
});

angular.module('lizard-nxt-filters')
  .filter('lookupPressurePipeType', function () {
  return function (input) {
    var out;
    switch (input) {
    case '1':
      out = 'Drukriolering';
      break;
    case '2':
      out = 'Persleiding';
      break;
    case '3':
      out = 'Pers-/transportleiding';
      break;
    default:
      out = 'Persleidingtype afwijkend';
    }
    return out;
  };
});

angular.module('lizard-nxt-filters')
  .filter('pipeMaterialOrEllipsis', function () {
  return function (input) {
    var out;
    switch (input) {
    case '0.0':
      out = 'beton';
      break;
    case '1.0':
      out = 'PVC';
      break;
    case '2.0':
      out = 'gres';
      break;
    case '00':
      out = 'beton';
      break;
    case '01':
      out = 'PVC';
      break;
    case '02':
      out = 'gres';
      break;
    default:
      out = 'Materiaal afwijkend';
    }
    return out;
  };
});

angular.module('lizard-nxt-filters')
  .filter('aggWinToYLabel', ['gettext', function (gettext) {
  return function (input) {
    var out;
    switch (input) {
    case 300000:
      out = gettext('mm / 5 min');
      break;
    case 3600000:
      out = gettext('mm / hour');
      break;
    case 86400000:
      out = gettext('mm / day');
      break;
    case 2635200000:
      out = gettext('mm / month');
      break;
    default:
      out = '...';
    }
    return out;
  };
}]);

/**
 * Truncates a string to have no more than maxLength characters.
 * Used in the righthand menu for truncating lengthy layer names.
 *
 * @param {integer} maxLength - Length at which string gets truncated.
 * @return {string} The truncated layer name
 */
angular.module('lizard-nxt-filters')
  .filter('truncate', function () {

  return function (input, maxLength) {

    if (input === undefined) { return ''; }

    var MAX_LENGTH = maxLength || 20;

    if (input.length > MAX_LENGTH) {
      return input.slice(0, MAX_LENGTH - 3) + "...";

    } else {
      return input;
    }
  };
});

/**
 * For the n timeseries related to a structure, remove the ones with an
 * insufficient amount of measurements to be able draw a graph. Since ts events
 * have a max and a min, it is possible to draw a line between 1 data point.
 *
 * @param {Object[]} A list of timeseries
 * @return  {Object[]} A list of timeseries with sufficient data
 */
angular.module('lizard-nxt-filters')
  .filter('rmZeroDatumTimeseries', function () {

  return function (input) {
    var result = [];
    angular.forEach(input, function (datum) {
      if (datum.events.length > 0) { result.push(datum); }
    });
    return result;
  };
});


angular.module('lizard-nxt-filters')
  .filter('objectTitle', ['gettext', function (gettext) {

  return function (input) {

    return {
      'bridge': gettext('Bridge'),
      'channel': gettext('Channel'),
      /// Boezemkanaal
      'channel_Boezem': gettext('Bosom channel'),
      'channel_Primair': gettext('Primary channel'),
      'crossprofile': gettext('Crossprofile'),
      'culvert': gettext('Culvert'),
      'groundwaterstation': gettext('Groundwater station'),
      'manhole': gettext('Manhole'),
      'measuringstation': gettext('Measuring station'),
      'orifice': gettext('Orifice'),
      'outlet': gettext('Outlet'),
      'overflow': gettext('Overflow'),
      'pipe': gettext('Pipe'),
      'pumpstation': gettext('Pump station'),
      'weir': gettext('Weir'),
      'pressurepipe': gettext('Pressure pipe'),
      'sluice':gettext('Sluice'),
      'wastewatertreatmentplant': gettext('Wastewater treatment plant'),
      'levee': gettext('Levee'),
      'leveecrosssection': gettext('Levee cross section'),
      'leveereferencepoint': gettext('Levee reference point'),
      'monitoringwell': gettext('Monitoring well'),
      'pump': gettext('Pump'),
      'filter': gettext('Filter')
    }[input] || input;
  };

}]);

/**
 * Expects a string of '<anything - ...> - <source> - <value>' or only '<value>'
 * Return the last part (value).
 */
angular.module('lizard-nxt-filters')
  .filter('discreteRasterType', function () {
  return function (input) {
    if (input) {
      var labelParts = input.split(' - ');
      return labelParts[labelParts.length - 1];
    }
    else {
      return '';
    }
  };
});

/**
 * Expects a string of '<anything - ...> - <source> - <value>' or only '<value>'
 * Try to return the 2nd to last part (source), if it does not have so many
 * parts, return empty string.
 */
angular.module('lizard-nxt-filters')
  .filter('discreteRasterSource', function () {
  return function (input) {
    if (input) {
    var labelParts = input.split(' - ');
    var output = labelParts[labelParts.length - 2];
    if (output === undefined) { output = ''; }
    return output;
    }
    else {
      return '';
    }
  };
});


'use strict';

/**
 * @ngdoc service
 * @name Underscore
 * @description
 * # Wrapper for underscore
 * Discloses underscore as service for dependency injection.
 */
angular.module('lodash', [])
  .service('Lodash', function () {
    return window._; 
  });


/**
 * @ngdoc service
 * @class LeafletService
 * @memberof app
 * @name LeafletService
 * @description Trivial wrapper for global Leaflet object.
 *
 * Perhaps in the future this can be done with CommonJS style requires.
 */
angular.module('lizard-nxt')
  .service('LeafletService', [function () {
  if (L) {
    // Leaflet global variable to speed up vector layer,
    // see: http://leafletjs.com/reference.html#path-canvas
    window.L_PREFER_CANVAS = true;

    // Set max margin of latLng.equals method. This way
    // the vectorservice is able to return the features
    // within 0.0001 degree of the click.
    L.LatLng.MAX_MARGIN = 0.0001;

    return L;
  } else {
    throw new Error('Leaflet can not be found');
  }
}]);

/*
 Copyright (c) 2012, Smartrak, David Leaver
 Leaflet.utfgrid is an open-source JavaScript library that provides utfgrid interaction on leaflet powered maps.
 https://github.com/danzel/Leaflet.utfgrid
*/
(function (window, undefined) {

  L.Util.ajax = function (url, cb) {
    // the following is from JavaScript: The Definitive Guide
    // and https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest_in_IE6
    if (window.XMLHttpRequest === undefined) {
      window.XMLHttpRequest = function () {
        /*global ActiveXObject:true */
        try {
            return new ActiveXObject("Microsoft.XMLHTTP");
        }
        catch  (e) {
            throw new Error("XMLHttpRequest is not supported");
        }
      };
    }
    var response, request = new XMLHttpRequest();
    request.open("GET", url, true); // async
    request.withCredentials = true;
    // request.open("GET", url, false); // sync
    request.onreadystatechange = function () {
      /*jshint evil: true */
      if (request.readyState === 4 && request.status === 200) {
        if (window.JSON) {
            response = JSON.parse(request.responseText);
        } else {
            response = eval("(" + request.responseText + ")");
        }
        cb(response);
      }
    };
    request.send();
  };


  L.UtfGrid = L.Class.extend({

    includes: L.Mixin.Events,
    options: {
      subdomains: 'abc',

      minZoom: 0,
      maxZoom: 18,
      tileSize: 256,

      resolution: 4,

      useJsonP: true,
      pointerCursor: true
    },

    //The thing the mouse is currently on
    _mouseOn: null,

    isLoading: false,

    initialize: function (url, options) {
      L.Util.setOptions(this, options);

      this._url = url;
      this._cache = {};
      // We keep track of the tiles which are at least partially within
      // the current spatial extent.
      this._extentCache = {};

      //Find a unique id in window we can use for our callbacks
      //Required for jsonP
      var i = 0;
      while (window['lu' + i]) {
          i++;
      }
      this._windowKey = 'lu' + i;
      window[this._windowKey] = {};

      var subdomains = this.options.subdomains;
      if (typeof this.options.subdomains === 'string') {
          this.options.subdomains = subdomains.split('');
      }
    },

    onAdd: function (map) {
      this._map = map;
      this._container = this._map._container;

      this._update();

      var zoom = this._map.getZoom();

      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
        return;
      }

      map.on('click', this._click, this);
      map.on('mousemove', this._move, this);
      map.on('moveend', this._update, this);

      this._tileLoaded(); // Check whether more tiles need loading
    },

    onRemove: function () {
      this._map.off('click', this._click, this);
      this._map.off('mousemove', this._move, this);
      this._map.off('moveend', this._update, this);
      // I am free, I'm free at last
      this._cache = {};
      if (this.options.pointerCursor) {
        this._container.style.cursor = '';
      }
    },

    _click: function (e) {
      this.fire('click', this._objectForEvent(e));
    },
    _move: function (e) {
      var on = this._objectForEvent(e);

      if (on.data !== this._mouseOn) {
        if (this._mouseOn) {
          this.fire('mouseout', { latlng: e.latlng, data: this._mouseOn });
          if (this.options.pointerCursor) {
            this._container.style.cursor = '';
          }
        }
        if (on.data) {
          this.fire('mouseover', on);
          if (this.options.pointerCursor) {
            this._container.style.cursor = 'pointer';
          }
        }

        this._mouseOn = on.data;
      } else if (on.data) {
        this.fire('mousemove', on);
      }
    },

    _objectForEvent: function (e) {

      var map = this._map;
      if (!map) {
        // This layer has not been not added to the map yet
        return { latlng: e.latlng, data: null };
      }

      var point = map.project(e.latlng),
        tileSize = this.options.tileSize,
        resolution = this.options.resolution,
        x = Math.floor(point.x / tileSize),
        y = Math.floor(point.y / tileSize),
        gridX = Math.floor((point.x - (x * tileSize)) / resolution),
        gridY = Math.floor((point.y - (y * tileSize)) / resolution),
          max = map.options.crs.scale(map.getZoom()) / tileSize;

      x = (x + max) % max;
      y = (y + max) % max;

      var data = this._cache[map.getZoom() + '_' + x + '_' + y];
      if (!data) {
        return { latlng: e.latlng, data: null };
      }

      var idx = this._utfDecode(data.grid[gridY].charCodeAt(gridX)),
        key = data.keys[idx],
        result = data.data[key];

      if (!data.data.hasOwnProperty(key)) {
        result = null;
      }

      return { latlng: e.latlng, data: result};
    },

    //Load up all required json grid files
    //TODO: Load from center etc
    _update: function () {

      var bounds = this._map.getPixelBounds(),
          zoom = this._map.getZoom(),
          tileSize = this.options.tileSize;

      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
        return;
      }

      var nwTilePoint = new L.Point(
            Math.floor(bounds.min.x / tileSize),
            Math.floor(bounds.min.y / tileSize)
          ),
          seTilePoint = new L.Point(
            Math.floor(bounds.max.x / tileSize),
            Math.floor(bounds.max.y / tileSize)
          ),
          max = this._map.options.crs.scale(zoom) / tileSize;

      this._extentCache = {}; // empty the _extentCache

      //Load all required ones
      for (var x = nwTilePoint.x; x <= seTilePoint.x; x++) {
        for (var y = nwTilePoint.y; y <= seTilePoint.y; y++) {

          var xw = (x + max) % max, yw = (y + max) % max;
          var key = zoom + '_' + xw + '_' + yw;

          if (!this._cache.hasOwnProperty(key)) {
            // We prepare the new tiles that are to be rendered:
            this._cache[key] = null;
            this._extentCache[key] = null;
            this._loadTile(zoom, xw, yw);
          } else {
            // We keep the old tiles that are still rendered:
            this._extentCache[key] = this._cache[key];
          }
        }
      }
    },

    _tileLoaded: function () {
      var isLoading = false;
      for (var i in this._cache) {
        if (this._cache[i] === null) { isLoading = true; }
      }
      this.isLoading = isLoading;
      if (!this.isLoading) { this.fireEvent('load'); }
    },

    _loadTile: function (zoom, x, y) {
      var url = L.Util.template(this._url, L.Util.extend({
        s: L.TileLayer.prototype._getSubdomain.call(this, { x: x, y: y }),
        z: zoom,
        x: x,
        y: y
      }, this.options));

      var key = zoom + '_' + x + '_' + y;

      this.isLoading = true;

      var self = this;

      L.Util.ajax(url, function (data) {
        self._cache[key] = data;
        self._extentCache[key] = data;
        self._tileLoaded();
      });
    },

    _utfDecode: function (c) {
      if (c >= 93) {
        c--;
      }
      if (c >= 35) {
        c--;
      }
      return c - 32;
    },

    _getUniqueStructureId: function (structureData) {
      try {
        return structureData.entity_name + "$" + structureData.id;
      } catch (e) {
        throw new Error("Tried to derive a unique structure ID from incomplete data: its not gonna w0rk. Error 'e' =", e);
      }
    },

    getUniqueStructuresForExtent: function () {

      var tile,
          tileSlug,
          uniqueStructures = { data: {} };

      for (tileSlug in this._extentCache) {
        tile = this._extentCache[tileSlug];
        if (tile && tile.data) {

          var datum,
              datumSlug,
              structureKey;

          for (datumSlug in tile.data) {
            datum = tile.data[datumSlug];
            structureKey = this._getUniqueStructureId(datum);
            if (!uniqueStructures.data[structureKey])
            {
              uniqueStructures.data[structureKey] = datum;
            }
          }
        }
      }
      return uniqueStructures;
    }
  });

  L.utfGrid = function (url, options) {
    return new L.UtfGrid(url, options);
  };

}(this));

'use strict';

/**
 * @ngdoc service
 * @name LeafletVectorService
 * @description
 * # LeafletVector
 * Creates a Tiled Layer for retrieving and drawing vector data.
 */
angular.module('lizard-nxt')
.service('LeafletVectorService', [
  "LeafletService",
  "VectorService",
  "UtilService",
  "State",
  function (LeafletService, VectorService, UtilService, State) {

  var MarkerClusterLayer = LeafletService.MarkerClusterGroup.extend({

    /**
     * @function
     * @description adds functionality to original Add function
     * of Leaflet.
     */
    onAdd: function (map) {
      LeafletService.MarkerClusterGroup.prototype.onAdd.call(this, map);

      this._map = map;

      this.addMarker = this.addLayer;
      this.removeMarker = this.removeLayer;
      this.hasMarker = this.hasLayer;
      this.markers = [];

      this.addData();

      var layer = this;

      this.on('clusterclick', function (e) {
        var features = [];
        e.layer.getAllChildMarkers().forEach(function (marker) {
          features.push(marker.options.feature);
        });
        layer.options.callbackClick(e, features);
      });

      this.on('click', function (e) {
        var features = [e.layer.options.feature];
        layer.options.callbackClick(e, features);
      });

    },

    addData: function () {

      var color = this.options.color,
          layer = this;

      // TODO: when the vector service returns data we need to sync the time.
      // But this is async and this function is called by leaflet's onAdd. So
      // this, as in layer (this context), is unreferenced and timeState on
      // this is lost. For now leaflet-vector-service depends on global state,
      // but really this whole async business should go somewhere else, like
      // map-service.
      VectorService.getData('leaflet', this.options.layer, {})
      .then(function (response) {
        layer.clearLayers();
        layer.markers = [];

        var pxSize = 10,
            marker;

        var icon = L.divIcon({
          iconAnchor: [pxSize, pxSize],
          html: '<svg height="' + (pxSize * 2) + '" width="' + (pxSize * 2)
            + '">'
            + '<circle cx="' + pxSize + '" cy="' + pxSize
            + '" r="' + pxSize + '" fill-opacity="0.4" fill="'
            + color + '" />'
            + '<circle cx="' + pxSize + '" cy="' + pxSize + '" r="'
            + (pxSize - 2) + '" fill-opacity="1" fill="'
            + color + '" />'
            + '<text x="' + pxSize + '" y="' + (pxSize + 5)
            + '" style="text-anchor: middle; fill: white;">'
            + 1 + '</text>'
            + '</svg>'
        });


        response.forEach(function (f) {
          var start;
          var end;

          if (f.properties.hasOwnProperty('timestamp')) {
            start = end = f.properties.timestamp;
          } else {
            start = f.properties.timestamp_start;
            end = f.properties.timestamp_end;
          }

          marker = L.marker(
            [f.geometry.coordinates[1], f.geometry.coordinates[0]],
            {
              icon: icon,
              timestamp_start: start,
              timestamp_end: end,
              feature: f
            });
          layer.addMarker(marker);
          layer.markers.push(marker);
        });

        layer.syncTime(State.temporal);
      });

    },

    /**
     * @function
     * @description Remove geojson sublayer
     * plus call original onremove event
     * @param {object} instance of Leaflet.Map
     */
    onRemove: function (map) {
      LeafletService.MarkerClusterGroup.prototype.onRemove.call(this, map);
      this.clearLayers();
      this.markers = [];
      VectorService.invalidateData(this.options.layer);
    },

    /**
     * @function
     * @description Implements opacity handler like other TileLayers
     * @params {float} amount of opacity between 0 and 1.
     */
    setOpacity: function (opacity) {
      // TODO: figure out why it is possible to call setOpacity while there is
      // no geojsonlayer.
      if (this.geojsonLayer) {
        this.geojsonLayer.setStyle({
          opacity: opacity,
          fillOpacity: opacity
        });
      }
    },

    /**
     * @function
     * @description sync the time
     */
    syncTime: function (timeState) {
      if (timeState) {
        this.timeState = timeState;
      }

      if (this.markers && this.markers.length > 0) {
        var start = this.timeState.playing ? this.timeState.at : this.timeState.start,
            end = this.timeState.playing
            ? this.timeState.at + this.timeState.aggWindow
            : this.timeState.end,
          markerTimeObject,
          mustRemoveMarker;

        this.markers.forEach(function (marker) {

          markerTimeObject = {
            timestamp_start: marker.options.timestamp_start,
            timestamp_end: marker.options.timestamp_end
          };

          mustRemoveMarker = !VectorService.isInTempExtent(markerTimeObject, {start: start, end: end});
          if (this.hasMarker(marker) && mustRemoveMarker) {
            this.removeMarker(marker);
          } else if (!this.hasMarker(marker) && !mustRemoveMarker) {
            this.addMarker(marker);
          }
        }, this);
      }

    },
  });

  return MarkerClusterLayer;

}]);

angular.module("global-state", []);


/**
 * @name dataLayers
 * @memberOf app
 * @description Contains the dataLayers set by the server. Used by the
 *              map-directive and layer-chooser directive to build layer
 *              groups.
 */
angular.module('global-state')
  .constant('dataLayers', window.data_layers);

/**
 * @name dataBounds
 * @memberOf app
 * @description Contains the bounds of the data set by the server at load
 */
angular.module('global-state')
  .constant('dataBounds', window.data_bounds);

angular.module('global-state')
  .run(function (dataLayers, dataBounds) {
    if (!dataLayers) {
      document.getElementsByTagName('body')[0].innerHTML =
      '<div class="error-message error-text" style="height: 135px">' +
        'Oops, this is not what you were looking for.' +
        'If you have any questions, please contact us. ' +
        '<a href="mailto:servicedesk@nelen-schuurmans.nl?subject=Lizard">servicedesk@nelen-schuurmans.nl</a>' +
      '</div>';
      throw new Error('No lizard-bs.js or no data layers in lizard-bs.js');
    }
  });

/**
 * Lizard-client global state object.
 */
angular.module('global-state')
  .service('State', ['dataLayers', 'UtilService', 'temporalBounds',
    function (dataLayers, UtilService, temporalBounds) {

    var state = {};

    /**
     * returns a function that returns a string representation of the provided
     * attribute of the state. When the state. does not exist, it returns a
     * function that returns "undefined". Useful to $watch the state.
     */
    state.toString = function (stateStr) {
      return function () {
        var property = state;
        angular.forEach(stateStr.split('.'), function (accessor) {
          if (property) {
            property = property[accessor];
          }
        });
        if (typeof property === 'string') {
          return property;
        } else {
          return JSON.stringify(property);
        }
      };
    };

    // Context. State.context returns 'map' or 'db', it can only be set with
    // either one of those values.
    var _context = ''; // Set on init from url or defaults to map.
    var CONTEXT_VALUES = ['map', 'dashboard', 'scenarios'];
    Object.defineProperty(state, 'context', {
      get: function () { return _context; },
      set: function (context) {
        if (CONTEXT_VALUES.indexOf(context) > -1) {
          _context = context;
        } else {
          throw new Error("Attemped to assign an illegal value ('"
            + context
            + "') to state.context. Only ["
            + CONTEXT_VALUES.join(',')
            + "] are accepted values."
          );
        }
      },
      enumerable: true
    });

    // Default language.
    state.language = 'nl';

    // State of data layer groups, stores slugs of all layergroups and the
    // active layergroups.
    state.layerGroups = {
      all: [], // Immutable representation of all layergroups
      active: [],
      gettingData: false, // Making server requests through DataService
      timeIsSyncing: false // Getting new layers and so on
    };

    // Combination of data and time syncing
    Object.defineProperty(state.layerGroups, 'isLoading', {
      get: function () {
        return state.layerGroups.timeIsSyncing || state.layerGroups.gettingData;
      },
      enumerable: false
    });

    // Box
    state.box = {};

    var _type = 'point'; // Default box type
    var TYPE_VALUES = ["point", "line", "region", "area", "multi-point"];
    Object.defineProperty(state.box, 'type', {
      get: function () { return _type; },
      set: function (type) {
        if (TYPE_VALUES.indexOf(type) > -1) {
          _type = type;
        } else {
          throw new Error("Attemped to assign an illegal value ('"
            + type
            + "') to state.box.type. Only ["
            + TYPE_VALUES.join(',')
            + "] are accepted values."
          );
        }
      },
      enumerable: true
    });

    // Spatial
    state.spatial = {
      bounds: { // leaflet bounds object, initialized with a validity check
                // function.
        isValid: function () { return false; }
      },
      view: {}, // { lat: <int>, lng:<int>, zoom:<int> }
      userHere: {}, // Geographical location of the users mouse only set by
                    // map-directive when box type is 'line'
      mapMoving: false
    };

    // there is one selected feature which is not being described here.
    // and is being set in MapDirective (in the _mouseMove function).
    // This is only relevant for drawing an intersection line in the map.
    // The location and the distance of the location to the first point of the
    // is being calculated and set on mouseOnLine for the graph.
    state.selected = {
      assets: [], // hydra-core asset id <entity>$<id>,
                  // is defined in DataService use state.selected.asset.addAsset
                  // to add and state.selected.assetremoveAsset to remove
                  // asset, or reset by calling state.selected.reset()
      geometries: [], // geojson with points, lines, polygons. Same as asset,
                      // is redefined in dataservice. use addGeometry and
                      // removegeometry on state.selected.geometries to add or
                      // remove individual geometries or use reset function.
      timeseries: [], // {<uuid>, <active>, <order>, <color>}
                      // Redefined in timeseriesService. mirrored asynchronously
                      // by timeseriesService.timeseries. Array contains all
                      // timeseries of all assets in a flat list.
      reset: function () {
        // Selected items
        state.selected.assets = [];
        state.selected.geometries = [];
        state.selected.timeseries = [];
      }
    };

    state.selected.reset();

    // Temporal
    var now = Date.now(),
        INITIAL_START_FOR_EXTENT = now + temporalBounds.start,
        INITIAL_END_FOR_EXTENT = now + temporalBounds.end;

    state.temporal = {
      at: now,
      buffering: false,
      timelineMoving: false,
      playing: false,
      start: null, // defined below
      end: null, // defined below
      relative: true // relative or absolut offset.
    };

    Object.defineProperty(state.temporal, 'aggWindow', {

      get: function () {

        var drawingWidth = 320;
        if (state.context === 'dashboard') {
          drawingWidth = angular.element('.dashboard-wrapper').width();
        }

        return UtilService.getAggWindow(
          state.temporal.start,
          state.temporal.end,
          drawingWidth
        );
      }
    });

    // State.temporal.start must be higher than MIN_TIME_FOR_EXTENT
    var _start = INITIAL_START_FOR_EXTENT;
    Object.defineProperty(state.temporal, 'start', {
      get: function () { return _start; },
      set: function (start) {
        _start = UtilService.getMinTime(start);
        state.temporal.at = _moveAtInTemporalExtent(state.temporal);
      },
      enumerable: true
    });

    // State.temporal.end must be lower than MAX_TIME_FOR_EXTENT
    var _end = INITIAL_END_FOR_EXTENT;
    Object.defineProperty(state.temporal, 'end', {
      get: function () { return _end; },
      set: function (end) {
        _end = UtilService.getMaxTime(end);
        state.temporal.at = _moveAtInTemporalExtent(state.temporal);
      },
      enumerable: true
    });

    /**
     * Checks given temporal state object whether `at` is within extent. If not
     * returns rounded `at` at start or end of time extent depending on
     * location of original `at`
     *
     * @param  {object} ts temporal state
     * @return {int}    at in ms from epoch.
     */
    var _moveAtInTemporalExtent = function (ts) {
      var _at = ts.at;
      if ((ts.at + ts.aggWindow) > ts.end) {
        _at = UtilService.roundTimestamp(
          ts.end,
          ts.aggWindow,
          true
        ) - ts.aggWindow;
      } else if (ts.at < ts.start) {
        _at = UtilService.roundTimestamp(
          ts.start,
          ts.aggWindow,
          true // round up.
        );
      }
      return _at;
    };

    return state;
  }]);

angular.module('data-menu', [
  'global-state'
]);

//layer-directive.js

angular.module('data-menu')
  .directive("layerChooser", [function () {

  var link = function (scope) {

    // Scope gets the mapState layerGroup, here we create a new layerGroup which
    // goes into its own NxtMap to always be turned on
    scope.showOpacitySlider = true;
  };

  return {
    link: link,
    templateUrl: 'layer-chooser/layer-chooser.html',
    restrict: 'E',
  };
}]);

'use strict';

/**
 * @ngdoc service
 * @name lizard-nxt.Layer
 * @description
 * # NxtLayer
 * Factory in the lizard-nxt.
 */
angular.module('data-menu')
  .factory('NxtLayer', ['$q', 'backendDomain', function ($q, backendDomain) {

      /*
       * @constructor
       * @memberOf app.Layer
       * @description Instantiates a layer with non-readable and
       *              non-configurable properties
       * @param  {object} layer definition as coming from the server.
       * @param  {object} temporal resolution from the parent layergroup.
       */
      function NxtLayer(layer, temporalResolution) {
        Object.defineProperty(this, 'slug', {
          value: layer.slug,
          writable: false,
        });
        Object.defineProperty(this, 'type', {
          value: layer.type,
          writable: false,
        });
        Object.defineProperty(this, 'format', {
          value: layer.format,
          writable: false,
        });
        Object.defineProperty(this, 'minZoom', {
          value: layer.min_zoom,
          writable: false,
        });
        Object.defineProperty(this, 'maxZoom', {
          value: layer.max_zoom,
          writable: false,
        });
        Object.defineProperty(this, 'url', {
          value: layer.url,
          // on github.io it needs to be prepended to
          writable: (window.location.host === 'nens.github.io' ||
                     window.location.host === 'lizard.sandbox.lizard.net'),
        });
        // Physical time in millieseconds between frames.
        Object.defineProperty(this, '_temporalResolution', {
          value: temporalResolution,
          writable: true,
        });
        // Bounds are set from the layer config in lizard-bs or set from the
        // layergroup when data-layer-group-service initiates layergroups.
        Object.defineProperty(this, 'bounds', {
          value: layer.meta && layer.meta.spatial_bounds,
          writable: true,
        });
        Object.defineProperty(this, 'color', {
          value: layer.color,
          writable: false,
        });
        Object.defineProperty(this, 'aggregationType', {
          value: layer.aggregation_type,
          writable: false,
        });
        Object.defineProperty(this, 'scale', {
          value: layer.scale,
          writable: false,
        });
        Object.defineProperty(this, 'quantity', {
          value: layer.quantity,
          writable: false,
        });
        Object.defineProperty(this, 'unit', {
          value: layer.unit,
          writable: false,
        });
        Object.defineProperty(this, 'zIndex', {
          value: layer.z_index,
          writable: false,
        });
        Object.defineProperty(this, 'tiled', {
          value: layer.tiled,
          writable: false,
        });
        Object.defineProperty(this, 'options', {
          value: layer.options,
          writable: false,
        });
        Object.defineProperty(this, 'rescalable', {
          value: layer.rescalable,
          writable: false,
        });
        Object.defineProperty(this, 'loadOrder', {
          value: layer.load_order,
          writable: false,
        });

        // this allows for the demo's to be run from github.io
        if ((this.url.indexOf('api/v2') > -1) &&
            (window.location.host === 'nens.github.io' ||
             window.location.host === 'lizard.sandbox.lizard.net')) {
          this.url = backendDomain + this.url;
        }


      }

      return NxtLayer;

    }
  ]);

'use strict';

/**
 * @ngdoc service
 * @name lizard-nxt.Layer
 * @description
 * # NxtDataLayer
 * Factory in the lizard-nxt.
 */
angular.module('data-menu')
  .factory('NxtDataLayer', ['$q', '$injector', 'NxtLayer',
  function ($q, $injector, NxtLayer) {

      var SERVICES = {
        Store: 'RasterService',
        Vector: 'VectorService',
        UTFGrid: 'UtfGridService',
        WMS: 'WmsGetFeatureInfoService'
      };

      function NxtDataLayer(layer, tempRes) {
        NxtLayer.call(this, layer, tempRes);

        this._service = $injector.get(SERVICES[this.format]);
      }

      NxtDataLayer.prototype = Object.create(NxtLayer.prototype, {

        constructor: NxtDataLayer,

       /**
        * @function
        * @memberOf app.Layer
        * @description Abstract method to be overridden by the layers that
        *              implement Layer can return data (Store and vector).
        * @param  {string} callee string of the callee to keep requests
        *                         seperate.
        * @param lgSlug slug of the layer.
        * @param options options object with geom and time.
        * @param deferred the defer to resolve when getting data.
        */
        getData: {
          value: function (callee, lgSlug, temporal, layerGroupName, options, deferred) {
            if (this._filter(options)) {
              return this._buildPromise(
                callee,
                lgSlug,
                temporal,
                layerGroupName,
                options,
                deferred,
                this._service
              );
            } else { return; }
          }
        },

        /**
         * Filters getData request. If the options dictate that this layer
         * should make a request this function returns true.
         * @param {object} options to match with this layer.
         */
        _filter: {
          value: function (options) {
            if (options.type) {
              if (options.type !== this.type) {
                return false;
              }
            }
            if (options.truncate) {
              if (this.format !== 'Store'
                || this._temporalResolution === undefined
                || this._temporalResolution === 0) {
                return false;
              }
            }
            if (options.exclude) {
              if (options.exclude === this.slug) {
                return false;
              }
            }
            return true;
          }
        },

       /**
        * @function
        * @memberOf app.Layer
        * @description creates a promise for the given layer and the provided
        *              service. The service should have a getData function that
        *              returns a promise that is resolved when data is recieved.
        * @param  {string} callee string of the callee to keep requests
        *                         seperate.
        * @param lg layerGroup slug to include in the response.
        * @param layer nxtLayer definition.
        * @param options options containing geometry or time.
        * @param deffered deffered to notify when service.getData resolves.
        * @param wantedService Service to getData from.
        */
        _buildPromise: {
          value: function (callee, lgSlug, temporal, layerGroupName, options, deferred, wantedService) {

            var aggType = this.aggregationType,
                color = this.color,
                scale = this.scale,
                slug = this.slug,
                summary = this.summary,
                format = this.format,
                type = this.type,
                quantity = this.quantity,
                unit = this.unit;

            var buildSuccesCallback = function (data) {
              deferred.notify({
                color: color,
                data: data &&
                  (typeof(data) === 'object' && data.hasOwnProperty('data'))
                  ? data.data
                  : data,
                format: format,
                id: options.id,
                layerGroupSlug: lgSlug,
                layerGroupName: layerGroupName,
                temporal: temporal,
                layerSlug: slug,
                aggType: aggType,
                summary: summary,
                scale: scale,
                type: type,
                quantity: quantity,
                unit: unit
              });
            };

            var buildErrorCallback = function (msg) {
              deferred.notify({
                data:  null,
                type: type,
                layerGroupSlug: lgSlug,
                layerSlug: slug
              });
            };

            // Pass layer options to the services making the request.
            // RasterServices uses this to add options.styles.
            var extendedOpts = angular.extend({}, options, this.options);
            extendedOpts.agg = this.aggregationType;

            return wantedService.getData(callee, this, extendedOpts)
              .then(buildSuccesCallback, buildErrorCallback);
          }
        }

      });

      return NxtDataLayer;

    }
  ]);


/**
 * @ngdoc service
 * @class LayerGroup
 * @memberof app
 * @name LayerGroup
 * @summary LayerGroup abstracts the notion of layers out of the app.
 * @description Only layergroups are approachable, from the outside world
 *              LayerGroup defines a group of layers which are loaded at
 *              initialization of the page. They can be toggled on/off and
 *              queried for data. Layergroup draws all its layers and returns
 *              data for all layers.
 */
angular.module('data-menu')
  .factory('DataLayerGroup', [
  'NxtLayer', 'NxtDataLayer', 'UtilService', '$q', '$http', 'Lodash',
  function (NxtLayer, NxtDataLayer, UtilService, $q, $http, _) {

    // this is the 0 Lat and 0 Long, and should never be zoomed to
    var NULL_ISLAND = {'east': 0, 'south': 0, 'north': 0, 'west': 0};

    /*
     * @constructor
     * @memberOf app.LayerGroup
     * @description Instantiates a layerGroup with non-readable and
     *              non-configurable properties
     * @param  {object} layergroup definition as coming from the server
     */
    function LayerGroup(layerGroup, callbackFns) {
      Object.defineProperty(this, 'temporal', {
        value: layerGroup.temporal,
        writable: false,
      });
      Object.defineProperty(this, 'temporalResolution', {
        value: layerGroup.temporal_resolution,
        writable: false,
      });
      Object.defineProperty(this, 'name', {
        value: layerGroup.name,
        writable: false,
      });
      Object.defineProperty(this, 'order', {
        value: layerGroup.order,
        writable: false,
      });
      Object.defineProperty(this, 'baselayer', {
        value: layerGroup.baselayer,
        writable: false,
      });
      Object.defineProperty(this, 'slug', {
        value: layerGroup.slug,
        writable: false,
      });
      Object.defineProperty(this, 'defaultActive', {
        value: layerGroup.active,
        writable: false,
      });
      Object.defineProperty(this, '_dataLayers', {
        value: [],
        writable: true,
      });
      Object.defineProperty(this, 'mapLayers', {
        value: [],
        writable: true,
      });
      Object.defineProperty(this, '_opacity', {
        value: layerGroup.opacity,
        writable: true,
      });
      Object.defineProperty(this, '_active', {
        value: false,
        writable: true,
      });
      Object.defineProperty(this, 'spatialBounds', {
        value: undefined,
        writable: true,
      });
      Object.defineProperty(this, 'temporalBounds', {
        value: {'start': 0, 'end': 0},
        writable: true,
      });


      this.instantiateLayers(layerGroup.layers, layerGroup.temporal_resolution);

      // Let the map-service know there is a new layergroup
      if (this.callbackFns) {
        this.callbackFns.onCreateLayerGroup(this);
      }
    }

    LayerGroup.prototype = {

      constructor: LayerGroup,

      instantiateLayers: function (layers, tempRes) {
        // Instantiate a Layer for every servserside layer of
        // the layergroup. There are layers that are drawn on the
        // map by the map-servie that go in mapLayers, layers that
        // are just used for data purposes are put in dataLayers
        // and layers that do both.

        angular.forEach(layers, function (layer) {

          if (layer.format === 'UTFGrid'
            || layer.format === 'Vector'
            || (layer.format === 'WMS' && layer.get_feature_info)) {
            var nxtLayer = new NxtDataLayer(layer, tempRes);
            this._dataLayers.push(nxtLayer);
            this.mapLayers.push(nxtLayer);
            // NOTE: crappy solution, we should set meta to None or
            // empty to do better checking.
            if (typeof layer.meta !== "string") {
              this.temporalBounds = layer.meta.temporal_bounds;
              this.spatialBounds = layer.meta.spatial_bounds;
            }
          }
          else if (layer.format === 'Store') {
            this._dataLayers.push(new NxtDataLayer(layer, tempRes));
            if (layer.meta) {
              this.temporalBounds = layer.meta.temporal_bounds;
              this.spatialBounds = layer.meta.spatial_bounds;
            }
          }
          else if (layer.format === 'TMS'
            || (layer.format === 'WMS' && !layer.get_feature_info)) {
            this.mapLayers.push(new NxtLayer(layer, tempRes));
          }

        }, this);

        // This layergroup solemnly swears to never visit NULL_ISLAND
        // https://en.wikipedia.org/wiki/Null_Island
        if (_.isEqual(this.spatialBounds, NULL_ISLAND)) {
          this.spatialBounds = undefined;
        }

      },

     /**
      * @function
      * @memberOf app.LayerGroup.prototype
      * @description toggles a layergroup on the given map.
      * @param  {object} map Leaflet map to toggle this layer on
      */
      toggle: function (map) {
        this._active = !this._active;
        if (this.callbackFns && this.callbackFns.onToggleLayerGroup) {
          this.callbackFns.onToggleLayerGroup(this);
        }
      },

      /**
       * Returns true if the current layerGroup (i.e. "this") is active and
       * false otherwise.
       */
      isActive: function () {
        return this._active;
      },

      isTemporal: function () {
        return this.temporal;
      },

      /**
       * Returns true iff the current layerGroup (i.e. "this") has only layers
       * with format 'Vector'.
       */
      isEventLayerGroup: function () {
        if (this.mapLayers.length > 0) {
          return this.mapLayers.every(function (mapLayer) {
            return mapLayer.format === 'Vector';
          });
        } else {
          return false;
        }

      },

      getColorForEventLayerGroup: function () {
        return this.mapLayers[0].color;
      },

     /**
      * @function
      * @memberOf app.LayerGroup.prototype
      * @description Returns a promise that notifies with data for every layer
      *              of the layergroup that is appplicable (i.e: rain and
      *              several vector layers). It resolves when all data is in.
      * @param  {string} callee string of the callee to keep requests seperate.
      * @param  {object} options with geom, start, end and other properties that
      *                          are send to the data-services.
      * @return  {object} notifies with data per layer and resolves with value
      *                    true when layergroup was active, or false when
      *                    layergroup was inactive.
      */
      getData: function (callee, options) {
        var lgSlug = this.slug,
            lgActive = this._active,
            temporal = this.temporal,
            layerGroupName = this.name,
            deferred = $q.defer(),
            promises = [];

        if (!this._active) {
          deferred.resolve({
            slug: this.slug,
            active: this._active,
            temporal: temporal
          });
          return deferred.promise;
        }
        else {
          angular.forEach(this._dataLayers, function (layer) {
            promises.push(layer.getData(
              callee,
              lgSlug,
              temporal,
              layerGroupName,
              options,
              deferred
            ));
          });
        }

        // Bear with me: the promises from the individual getData's(),
        // notify() the defer from LayerGroup.getData() on resolve.
        // When all the individual promises have resolved, this defer
        // should be resolved. It resolves with 'true' to indicate activity
        // of layer. No need to keep a counter of the individual promises.
        $q.all(promises).then(function () {
          deferred.resolve({
            slug: lgSlug,
            active: lgActive,
            temporal: temporal
          });
        });

        return deferred.promise;
      },


      /**
       * @function
       * @memberof app.LayerGroup
       * @param {float} new opacity value
       * @return {void}
       * @description Changes opacity in layers that have
       * an opacity to be set
       */
      setOpacity: function (newOpacity) {
        if (typeof newOpacity !== 'number' ||
            newOpacity < 0 && newOpacity > 1) {
          throw new Error(newOpacity + "is not a valid opacity value, it is"
            + "either of the wrong type or not between 0 and 1");
        }
        this._opacity = newOpacity;
        if (this.callbackFns && this.callbackFns.onOpacityChange) {
          this.callbackFns.onOpacityChange(this);
        }
      },

      /**
       * @function
       * @member app.LayerGroup
       * @return {float} opacity from 0 to 1.
       * @description retrieve opacity from layer
       */
      getOpacity: function () {
        return this._opacity;
      },

      /**
       * calls double click callback function when layergroup item in menu
       * is double clicked. Used by the map to rescale.
       */
      dblClick: function () {
        if (this.callbackFns && this.callbackFns.onDblClick) {
          this.callbackFns.onDblClick(this);
        }
      }

    };

    return LayerGroup;
  }
]);

'use strict';


/**
 * @ngdoc service
 * @class NxtData /
 * @memberof app
 * @name NxtData
 * @requires $q, dataLayers, LayerGroup and State
 * @summary Encapsulates layergroups
 * @description NxtData service encapsulates layergroups from the server side
 *              configuration of layergroups. It enables to perform actions
 *              on all layergroups simultaneously. When provided with a string
 *              representation of the service containing the global map it
 *              it performs these actions on the map from this service, else
 *              it needs a map object when calling toggleLayerGroup and
 *              syncTime.
 */

angular.module('data-menu')
  .service('DataService', [
    '$q',
    'AssetService',
    'dataLayers',
    'DataLayerGroup',
    'LayerAdderService',
    'State',

    function (
      $q,
      AssetService,
      dataLayers,
      DataLayerGroup,
      LayerAdderService,
      State
    ) {

      // Attributes ////////////////////////////////////////////////////////////

      // Event callbacks are used to performa actions on the map when the
      // state of layergroups changes, may contain a onOpacityChange, OnDblClick
      // and on layerGroupToggled callback functions.
      Object.defineProperty(this, 'eventCallbacks', {
        set: function (newCallBacks) {
          DataLayerGroup.prototype.callbackFns = newCallBacks;
        }
      });

      var instance = this;

      /**
       * Creates a new layerGroup and adds to the layerGroups
       * @param  {object} lgConfig config of layergroup
       * @return {object} layerGroup instance
       */
      this.createLayerGroup = function (lgConfig) {
        return this.layerGroups[lgConfig.slug] = new DataLayerGroup(lgConfig);
      };

      /**
       * @function
       * @memberof app.NxtMapService
       * @param  {object} nonLeafLayers object from database
       * @description Throw in layers as served from the backend
       */
      this._createLayerGroups = function (serverSideLayerGroups) {
        var layerGroups = {};
        angular.forEach(serverSideLayerGroups, function (sslg) {

          var utf = false;

          angular.forEach(sslg.layers, function (layer) {
            if (layer.format === 'UTFGrid') {
              utf = true;
            }
          }, this);

          var lg = new DataLayerGroup(sslg);

          if (utf) { this.utfLayerGroup = lg; }

          this.layerGroups[lg.slug] = lg;

        }, this);
        return this.layerGroups;
      };

      this.layerGroups = {};

      var layerGroups = this._createLayerGroups(dataLayers);

      this.baselayerGroups = _.filter(layerGroups, function (lgValue, lgKey) {
        return lgValue.baselayer;
      });

      // Callback for when assets are being retrieved from api
      var assetChange = function (asset) {
        if (asset) {
          instance.assets.push(asset);
        }

        // A-synchronously remove assets no longer in selection.
        instance.assets = AssetService.removeOldAssets(_assets, instance.assets);

        // Deduplicate instance.assets asynchronous.
        instance.assets = _.uniqWith(instance.assets, _.isEqual);

        instance.getGeomDataForAssets(instance.oldAssets, instance.assets);

        if (instance.onAssetsChange) {
          instance.onAssetsChange();
        }

        console.log('DataService.assets:', instance.assets);
      };

      // Define assets on State and update DataService.assets.
      var setAssets = function (assetsIn) {
        // Dedupe assets in selection synchronous.
        var assets = _.uniq(assetsIn);
        instance.oldAssets = angular.copy(instance.assets);

        // Synchronously remove assets no longer in selection.
        instance.assets = AssetService.removeOldAssets(assets, instance.assets);

        AssetService.updateAssets(instance.assets, _assets, assets)
        .forEach(function (assetPromise) {
          assetPromise.then(assetChange);
        });
        _assets = assets;

        console.log('State.selected.assets:', State.selected.assets);

        rebindAssetFunctions();
      };


      // Rebind add and remove because selected.assets might have been
      // redefined when calling state.selected.assets = []
      var rebindAssetFunctions = function () {
        State.selected.assets.addAsset = addAsset;
        State.selected.assets.removeAsset = removeAsset;
      };

      var addAsset = function (asset) {
        var newAssets = angular.copy(_assets);
        newAssets.push(asset);
        setAssets(newAssets);
      };

      var removeAsset = function (asset) {
        var newAssets = angular.copy(_assets);
        newAssets.splice(_assets.indexOf(asset), 1);
        setAssets(newAssets);
      };

      instance.assets = instance.oldAssets = [];
      var _assets = [];
      Object.defineProperty(State.selected, 'assets', {
        get: function () { return _assets; },
        set: setAssets,
        enumerable: true
      });

      State.selected.assets.addAsset = addAsset;
      State.selected.assets.removeAsset = removeAsset;

      /**
       * Return true if geometry is of same type (point, line etc) and has the
       * same coordinates.
       *
       * @param  {object}  one   geometry
       * @param  {object}  other geometry
       * @return {Boolean}
       */
      var isDuplicateGeometry = function (one, other) {
        var oneg = one.geometry;
        var otherg = other.geometry;
        if (oneg.type === otherg.type) {
          return _.every(oneg.coordinates, function (coord, i) {
            return coord === otherg.coordinates[i];
          });
        }
        else {
          return false;
        }
      };

      // Define geometries on State and update DataService.geometries.
      var setGeometries = function (geometriesIn) {
        // Dedupe geometries in selection synchronous.
        var geometries = _.uniqWith(geometriesIn, isDuplicateGeometry);
        instance._updateGeometries(_geometries, angular.copy(geometries))
        .then(function (geometries) {
          // Dedupe instance.geometries asynchronous.
          instance.geometries = _.uniqWith(geometries, isDuplicateGeometry);
          console.log('DataService.geometries:', instance.geometries);

          if (instance.onGeometriesChange) {
            instance.onGeometriesChange();
          }

        });
        _geometries = geometries;
        console.log('State.selected.geometries:', State.selected.geometries);
        State.selected.geometries.addGeometry = addGeometry;
        State.selected.geometries.removeGeometry = removeGeometry;
      };

      var addGeometry = function (geometry) {
        var newGeoms = angular.copy(_geometries);
        newGeoms.push(geometry);
        setGeometries(newGeoms);
      };

      var removeGeometry = function (geometry) {
        var newGeometries = angular.copy(_geometries);
        var index = -1;
        _geometries.forEach(function(geom, i) {
          if (geom.geometry.coordinates[0] === geometry.geometry.coordinates[0]
          && geom.geometry.coordinates[1] === geometry.geometry.coordinates[1]
          && geom.geometry.coordinates[2] === geometry.geometry.coordinates[2]) {
            index = i;
          }
        });
        newGeometries.splice(index, 1);
        setGeometries(newGeometries);
      };

      instance.geometries = [];
      var _geometries = [];
      Object.defineProperty(State.selected, 'geometries', {
        get: function () { return _geometries; },
        set: setGeometries
      });

      State.selected.geometries.addGeometry = addGeometry;
      State.selected.geometries.removeGeometry = removeGeometry;

      // Immutable representation of all layergroups set on State.layerGroups
      Object.defineProperty(State.layerGroups, 'all', {
        get: function () {
          return Object.keys(layerGroups);
        },
        set: function (newLayerGroups) {

          // Remove layergroups not in newLayergroups
          _.forEach(
            instance.layerGroups,
            function (lg, slug) {
              if (newLayerGroups.indexOf(slug) === -1) {
                instance.removeLayerGroup(lg);
              }
            }
          );

          // Request new layegroups from server.
          var nonExistent = _.difference(
            newLayerGroups,
            Object.keys(instance.layerGroups)
          );

          LayerAdderService.getNonExistentLayerGroups(
            nonExistent,
            instance
          );

        }
      });

      this.REJECTION_REASONS = {};

      Object.defineProperty(this.REJECTION_REASONS, 'OVERRIDDEN', {
        value: 'overridden',
        writeable: false,
        configurable: false
      });

      // List of slugs of active layerGroups, two-way.
      Object.defineProperty(State.layerGroups, 'active', {
        get: function () {
          return Object.keys(layerGroups).filter(function (layerGroup) {
            return layerGroups[layerGroup].isActive();
          });
        },
        set: function (newActivelayerGroups) {

          angular.forEach(layerGroups, function (_lg, slug) {
            // Turn layers on or off.
            if (newActivelayerGroups.indexOf(slug) !== -1 && !_lg.isActive()) {
              this.toggleLayerGroup(_lg);
            } else if (newActivelayerGroups.indexOf(slug) === -1 && _lg.isActive()) {
              this.toggleLayerGroup(_lg);
            }
          }, instance);

          var nonExistent = _.difference(
            newActivelayerGroups,
            Object.keys(instance.layerGroups)
          );

          LayerAdderService.getNonExistentActiveLayerGroups(
            nonExistent,
            instance
          );

        }
      });

      // Define temporal here so DataService can update assets, geometries etc.
      var _timelineMoving = State.temporal.timelineMoving;
      Object.defineProperty(State.temporal, 'timelineMoving', {
        get: function () { return _timelineMoving; },
        set: function (value) {
          _timelineMoving = value;
          if (!value) {
            instance.refreshSelected();
          }
        }
      });

      this._dataDefers = {}; // Per callee a list with a defer for every time
                             // getData gets called before the last one
                             // resolves.


      // Methods //////////////////////////////////////////////////////////////

      /**
       * @function
       * @memberOf app.NxtMap
       * @description Toggles a layergroup when layergroups should be toggled
       *              takes into account that baselayers should toggle eachother
       * @param  layerGroup layergroup that should be toggled
       */
      this.toggleLayerGroup = function (layerGroup) {
        // turn layer group on
        if (!(layerGroup.baselayer && layerGroup.isActive())) {
          layerGroup.toggle();
          instance.refreshSelected();
        }
        if (layerGroup.baselayer) {
          angular.forEach(this.layerGroups, function (_layerGroup) {
            if (_layerGroup.baselayer
              && _layerGroup.isActive()
              && _layerGroup.slug !== layerGroup.slug
              )
            {
              _layerGroup.toggle();
            }
          });
        }
      };

      /**
       * Adds the provided layerGroups to the layerGroups
       * @param {object} layerGroup instance
       */
      this.addLayergroup = function (layerGroup) {
        return this.layerGroups[layerGroup.slug] = layerGroup;
      };

      /**
       * Removes the provided layerGroups from nxt
       * @param {object} layerGroup instance
       */
      this.removeLayerGroup = function (layerGroup) {
        delete this.layerGroups[layerGroup.slug];
        return this.layerGroups;
      };

      /**
       * Gets data from all layergroups.
       *
       * @param  {object} options
       * @param  {str} callee that gets a list of defers for every time getdata
       *                      is called before a request finishes.
       * @param  {defer} recursiveDefer optional. When supplied is notified with
       *                                data. Used for recursively calling get
       *                                data with data from waterchain of a
       *                                previous getData call.
       * @return {object} notifies with data from layergroup and resolves when
       *                   all layergroups and the timeseries returned data.
       */
      this.getData = function (callee, options, recursiveDefer) {
        var defer = $q.defer();

        if (recursiveDefer === undefined) {
          this.reject(callee, this.REJECTION_REASONS.OVERRIDDEN);
          if (!this._dataDefers[callee]) {
            this._dataDefers[callee] = []; // It is a list because $q.all can not
          }                                // be deregistered.
          var defers = this._dataDefers[callee];
          defers.push(defer); // add to list
        }

        var promises = [];
        var instance = this;
        angular.forEach(this.layerGroups, function (layerGroup) {
          promises.push(
            layerGroup.getData(callee, options).then(null, null, function (response) {

              if (recursiveDefer) {
                recursiveDefer.notify(response);
              } else {
                defer.notify(response);
              }

            })
          );
        });

        $q.all(promises).then(function () {
          finishDefers();
        });

        /**
         * @function finishDefers
         * @memberof DataService
         * @summary Checks if current defer is the last one, if so resolves the
         * defer and clears the defers
         */
        var finishDefers = function () {
          // If this defer is the last one in the list of defers the getData
          // is truly finished, otherwise the getData is still getting data for
          // the callee.
          if (recursiveDefer) {
            defer.resolve();
          }
          else if (defers.indexOf(defer) === defers.length - 1) {
            State.layerGroups.gettingData = false;
            defer.resolve(); // Resolve the last one, the others have been
                             // rejected.
            defers.length = 0; // Clear the defers, by using .length = 0 the
                               // reference to this._dataDefers persists.
          }
        };

        State.layerGroups.gettingData = true;
        return defer.promise;
      };

      /**
       * Rejects call for data and sets loading to false.
       */
      this.reject = function (callee, reason) {
        State.layerGroups.gettingData = false;
        if (this._dataDefers[callee]) {
          this._dataDefers[callee].forEach(function (defer) {
            defer.reject(reason);
          });
        }
      };

      this.refreshSelected = function () {
        this.geometries.forEach(function (geom) {

          angular.forEach(geom.properties, function (v, s) {
            if (!this.layerGroups[s].isActive()) {
              delete geom.properties[s];
            }
          }, this);

          this.getGeomData(geom)
          .then(function(newGeo) {
            instance.geometries.forEach(function (old, i) {
              if (_.isEqual(old.geometry.coordinates, newGeo.geometry.coordinates)) {
                instance.geometries[i] = newGeo;
                console.log('DataService.geometries:', instance.geometries);
              }
            });
          });

        }, this);

        this.assets.forEach(function (asset) {

          this.getGeomData(asset)
          .then(function(newAsset) {
            instance.assets.forEach(function (old, i) {
              if (old.entity_name === newAsset.entity_name && old.id === newAsset.id) {
                instance.assets[i] = newAsset;
              }
            });
          });

        }, this);

      };

      this._updateGeometries = function (oldGeoms, newGeoms) {

        instance.geometries = instance.geometries.filter(function (geom) {
          return newGeoms.filter(function (oldGeom) {
            var oC = oldGeom.geometry.coordinates;
            var nC = geom.geometry.coordinates;
            return _.isEqual(oC, nC);
          }).length;
        });

        if (newGeoms.length > 0) {
          return this.getGeomData(newGeoms[newGeoms.length -1])
          .then(function(newGeo) {
            var dupe = false;
            instance.geometries.forEach(function (old, i) {
              if (_.isEqual(old.geometry.coordinates, newGeo.geometry.coordinates)) {
                dupe = true;
                instance.geometries[i] = newGeo;
              }
            });
            if (!dupe) {
              instance.geometries.push(newGeo);
            }
            return instance.geometries;
          });
        }
        else {
          var defer = $q.defer();
          defer.resolve(instance.geometries);
          return defer.promise;
        }

      };

      this.getGeomDataForAssets = function (oldAssets, assets) {
        var newAssets = assets.filter(function (asset) {
          return !oldAssets.filter(function (oldAsset) {
            return oldAsset.entity_name === asset.entity_name && oldAsset.id === asset.id;
          }).length;
        });

        newAssets.forEach(function (asset) {
          this.getGeomData(asset)
          .then(function(geo) {
            asset.geometry = geo.geometry;
            asset.properties = geo.properties;
          });
        }, this);
      };

      this.getGeomData = function (geo) {
        var defer = $q.defer();

        var promises = [];
        var instance = this;

        var options = {
          start: State.temporal.start,
          end: State.temporal.end
        };

        if (geo.geometry.type === 'Point') {
          options.geom = L.latLng(geo.geometry.coordinates[1], geo.geometry.coordinates[0]);
        }

        else if (geo.geometry.type === 'LineString') {
          var coords = geo.geometry.coordinates;
          options.geom = [
            L.latLng(coords[0][1], coords[0][0]),
            L.latLng(coords[1][1], coords[1][0])
          ];
        }

        else if (geo.geometry.type === 'Polygon' && geo.id) {
          options.id = geo.id;
        }

        if (geo.geometry.type === 'Polygon') {
          options.geom = L.geoJson(geo).getBounds();
        }

        angular.forEach(this.layerGroups, function (layerGroup) {
          if (

            // UTF has a special status and is not queried in this loop.
            (instance.utfLayerGroup && (layerGroup.slug === instance.utfLayerGroup.slug))

            // One too many dimension
            || (layerGroup.temporal && geo.geometry.type === 'LineString')

          ) {
            return;
          }

          promises.push(
            layerGroup.getData('DataService', options).then(null, null, function (response) {
              // async so remove anything obsolete.
              geo.properties = geo.properties || {};
              geo.properties[response.layerGroupSlug] = geo.properties[response.layerGroupSlug] || {};
              // Replace data and merge everything with existing state of
              // property.
              geo.properties[response.layerGroupSlug].data = [];
              _.merge(geo.properties[response.layerGroupSlug], response);
              if (!instance.layerGroups[response.layerGroupSlug].isActive()
                && layerGroup.slug in Object.keys(geo.properties)) {

                  geo.properties[layerGroup.slug] = null;

              }
            })
          );
        });

        $q.all(promises).then(function () {
            geo.properties = geo.properties || {};
            State.layerGroups.gettingData = false;
            defer.resolve(geo);
            defer = undefined; // Clear the defer
        });

        State.layerGroups.gettingData = true;
        return defer.promise;
      };

      /**
       * @function
       * @memberOf app.NxtMap
       * @description Sets the layergroups to the state they came from the
       *              server. Is called by the urlCtrl when no layergroup
       *              info is found on the server
       */
      this.setLayerGoupsToDefault = function () {
        angular.forEach(this.layerGroups, function (layerGroup) {
          if (layerGroup.defaultActive && !layerGroup.isActive()) {
            this.toggleLayerGroup(layerGroup);
          } else if (!layerGroup.defaultActive && layerGroup.isActive()) {
            this.toggleLayerGroup(layerGroup);
          }
        }, this);
      };

    }
  ]);

/**
 * Service to handle timeseries retrieval.
 */
angular.module('data-menu')
  .service("AssetService", ['State', '$q', '$http',
    function (State, $q, $http) {

      /**
       * Removes all the ts from the selection of the asset. It should not be
       * possible to select ts of assets.
       *
       * @param  {object} asset
       */
      var removeTSofAsset = function (asset) {
        State.selected.timeseries = _.differenceBy(
          State.selected.timeseries,
          asset.timeseries,
          'uuid'
        );
      };

      /**
       * @param {string} entity - name of the entity
       * @param {string} id -  id of the enitity
       * returns {object} promise - thenable with result of the asset API
       */
      var getAsset = function (entity, id) {
        return $http({
          url: 'api/v2/' + entity + 's' + '/' + id + '/',
          method: 'GET'
        })

        .then(function (response) {
          response.data.entity_name = entity;
          return response.data;
        });
      };

      /**
       * Removes assets from service when not selected.
       *
       * @param  {array}  selectedAssets State.selected.asssets.
       * @param  {array}  currentAssets  DataService.assets
       * @return {array}                 Updated DataService.assets.
       */
      this.removeOldAssets = function (selectedAssets, currentAssets) {
        return currentAssets.filter(function (asset) {
          var assetId = asset.entity_name + '$' + asset.id;
          var keep = selectedAssets.indexOf(assetId) !== -1;
          if (!keep) {
            removeTSofAsset(asset);
          }
          return keep;
        });
      };

      /**
       * Updates assets by making requests to asset api.
       *
       * @param  {array}  assets       array of assets as from api
       * @param  {array}  oldSelection old array of assetId of selected assets
       * @param  {array}  newSelection new array of assetId of selected assets
       */
      this.updateAssets = function (assets, oldSelection, newSelection) {

        var newAssets = newSelection.filter(function (assetId) {
          return oldSelection.indexOf(assetId) === -1;
        });

        if (newAssets) {
          return _.map(newAssets, function (asset) {
            var entity = asset.split('$')[0];
            var id = asset.split('$')[1];

            return getAsset(entity, id);
          });
        }

        else {
          var defer = $q.defer();
          defer.resolve();
          return [defer.promise];
        }

      };

  }

]);

/**
 * Service to handle layer-group retrieval.
 */
angular.module('data-menu')
  .service("LayerAdderService", ['$resource', function ($resource) {

      /* Provide a resource for interacting with the layergroups endpoint of
       * the API.
       *
       * Use a reconfigured 'query' so it actually returns an array of items.
       */
      var layerGroups = $resource('/api/v2/layergroups/:slug/', {}, {
        'query': {
          method:'GET',
          isArray:false
        }
      });

      /**
       * Get layergroups from the API.
       * @param {dict} params - A dictionary of request params (e.g.
       *                        {'page_size': 10}).
       * @param {function} success - Execute this function on a successful GET.
       * @param {function} error - Execute this function on an unsuccessful
       *                           GET.
       */
      this.fetchLayerGroups = function (params, success, error) {
        layerGroups.query(params, success, error);
      };

      /**
       * Get single layergroup from the API.
       * @param {string} params - slug for layergroup you are looking for.
       * @param {function} success - Execute this function on a successful GET.
       * @param {function} error - Execute this function on an unsuccessful
       *                           GET.
       */
      this.fetchLayerGroup = function (slug, success, error) {
        layerGroups.get({slug: slug}, success, error);
      };


      /**
       * Gets active layergroups. First creates a stub so layergroups.all does
       * not make the same request and turns layergroups off.
       *
       * Creates stubs for provided newActives, makes request, adds to ds.layer-
       * Groups and toggles layergroup to active.
       *
       * @param  {array}  newActives list of slugs.
       * @param  {DataService} ds.
       */
      this.getNonExistentActiveLayerGroups = function (newActives, ds) {

        var addLayerFromURL = function (layerGroup) {
          // Create the layergroup.
          var newLayerGroup = ds.createLayerGroup(layerGroup);
          // Turn the layergroup on.
          ds.toggleLayerGroup(newLayerGroup);
        };

        // Create a stub lg for every active layegroup. Layergroup.all will
        // ignore these.
        newActives.forEach(function (slug) {
          ds.layerGroups[slug] = {
            stub: true,
            isActive: function () { return true; },
            getOpacity: function () { return 0; },
            layers: [],
            mapLayers: []
          };
        });

        newActives.forEach(function (newLg) {
          // Get active layers from url and toggle them.
          this.fetchLayerGroup(
            newLg, addLayerFromURL, function (e) {
              // this is the error callback, which fails silently.
              console.log('Can\'t find what you\'re looking for: ', e);
          });
        }, this);

      };

      /**
       * Gets layergroups and adds to ds.layerGroups for lg slugs.
       *
       * @param  {array}  newInactives list of slugs.
       * @param  {DataService} ds.
       */
      this.getNonExistentLayerGroups = function (newInactives, ds) {

        var addLayer = function (layergroup) {
          ds.createLayerGroup(layergroup);
        };

        newInactives.forEach(function (newLg) {
          // Get missing layergroups.
          this.fetchLayerGroup(
            newLg, addLayer, function (e) {
              // this is the error callback, which fails silently.
              console.log('Can\'t find what you\'re looking for: ', e);
          });
        }, this);

      };


      return this;
    }
  ]);

'use strict';
/**
 * Removes all but last asset. If no assets, it removes all but last
 * geometry, else all geometries. Result, one selected element.
 */
angular.module('data-menu')
.service("rmAllButLastAssetAndGeometry", ['State',
function (State) {

  return function () {
    State.selected.assets.forEach(function (asset) {
      if (State.selected.assets.length > 1) {
        State.selected.assets.removeAsset(asset);
      }
    });
    if (State.selected.assets.length === 0) {
      State.selected.geometries.forEach(function (geom) {
        if (State.selected.geometries.length > 1) {
          State.selected.geometries.removeGeometry(geom);
        }
      });
    }
    else {
      State.selected.geometries = [];
    }
  };

}]);

/**
 * @ngdoc
 * @class areaCtrl
 * @memberOf app
 * @name areaCtrl
 * @description
 * area is the object which collects different
 * sets of aggregation data. If there is no activeObject,
 * this is the default collection of data to be shown in the
 * client.
 *
 * Contains data of all active layers with an aggregation_type
 *
 */
angular.module('data-menu')
  .controller('DatamenuController',
              ['$scope', 'DataService', 'State', 'MapService', 'UtilService',
               function ($scope, DataService, State, MapService, UtilService) {

    this.layerGroups = DataService.layerGroups;

    this.toggleLayerGroup = DataService.toggleLayerGroup;

    this.layerAdderEnabled = false;

    this.box = State.box;

    this.enabled = false;

    this.state = State.layerGroups;

    // move this function to service.
    this.zoomToBounds = function (spatialBounds, temporalBounds) {

      // zoom to spatial bounds
      MapService.fitBounds(spatialBounds);

      // zoom to temporal bounds
      if (temporalBounds.start !== temporalBounds.end) {
        // Use 10% padding around bounds to include everything on timeline.
        var padding = (temporalBounds.end - temporalBounds.start) / 10;
        State.temporal.start = temporalBounds.start - padding;
        State.temporal.end = temporalBounds.end + padding;
        State.temporal.at = temporalBounds.start;
        UtilService.announceMovedTimeline(State);
      }
    };
  }
]);


'use strict';

/**
 * Data menu directives
 *
 * Overview
 * ========
 *
 * Defines the data menu.
 */
angular.module('data-menu')
  .directive('datamenu', [function () {

    var link = function (scope, element, attrs) {
    };

    return {
      link: link,
      restrict: 'E',
      replace: true,
      templateUrl: 'data-menu/data-menu.html'
    };

  }
]);

/**
 * @module
 * @memberof datamenu
 * @description Show the layers in the data menu.
 */
angular.module('data-menu')
  .directive('layerSwitcher', ['DataService', function (DataService) {

    var link = function (scope, element, attrs) {

      scope.removeLayerGroup = function (layergroup) {
        // Turn the layergroup off.
        if (layergroup.isActive()) {
          scope.menu.toggleLayerGroup(layergroup);
        }
        // Remove the layergroup.
        DataService.removeLayerGroup(layergroup);
      };
    };

    return {
      link: link,
      restrict: 'E',
      scope: {
        layerGroup: '=',
        menu: '='
      },
      templateUrl: 'data-menu/layer-switcher.html'
    };

  }
]);

/**
 * @module
 * @memberof datamenu
 * @description Add more layers to the data menu.
 */
angular.module('data-menu')
  .directive('layerAdder',
             ['LayerAdderService', 'DataService', 'notie', 'gettextCatalog',
              function (LayerAdderService,
                        DataService,
                        notie,
                        gettextCatalog) {

    var link = function (scope, element, attrs) {


      /**
       * Throw an alert and error when something went wrong with fetching the
       * layer groups.
       * @param {dict} httpResponse - The httpResponse headers returned by the
       *                              GET request.
       */
      var fetchLayerGroupsError = function(httpResponse) {
        notie.alert(
          3, gettextCatalog.getString(
            "Oops! Something went wrong while fetching the layers."));
        throw new Error(
          httpResponse.status + " - "
          + "Could not retrieve layers:"
          + " " + httpResponse.config.url
          + ".");
      };

      /**
       * Fill the layer adder list with all the layer groups returned by the
       * GET request, existing layer groups in the portal excluded.
       * @param {array} allLayerGroups - The array of layer group objects
       *                                 returned by the GET request.
       * @param {dict} responseHeaders - Not actually used but required
       *                                 by $resource.
       */
      var fetchLayerGroupsSuccess = function (
          allLayerGroups, responseHeaders) {
        scope.availableLayerGroups = allLayerGroups;
      };

      /**
       * Add the selected layergroup to the portal.
       * @param {object} layerGroup - The layer group that was selected by the
       *                              user to be added to the portal.
       */
      scope.addLayerGroupToPortal = function (layerGroup) {
        // Create the layergroup.
        var newLayerGroup = DataService.createLayerGroup(layerGroup);
        // Turn the layergroup on.
        scope.menu.toggleLayerGroup(newLayerGroup);
        // Go back to the layer chooser menu.
        scope.menu.layerAdderEnabled = !scope.menu.layerAdderEnabled;
      };

      /**
       * Get available layer groups from the API.
       * Filter the currently selected layer groups from the available layer
       * groups.
       * Update the front-end to reflect a successful GET or throw an alert
       * on error.
       *
       * @param {object} query - Optional parameter which accepts an object
       *                         with query parameters for the API request.
       */
      var fetchLayerGroups = function (query) {
        if (typeof query === "undefined") {
          query = {};
        }

        // Generate a list of currently selected layer groups.
        var menuLayerGroupSlugs = _.join(
          _.map(
            _.values(scope.menu.layerGroups),
            'slug'),
          ',');

        query.exclude_slugs = menuLayerGroupSlugs;

        LayerAdderService.fetchLayerGroups(
          query,
          fetchLayerGroupsSuccess,
          fetchLayerGroupsError);
      };

      /**
       * Fetch layer groups on initialization of the module.
       */
      fetchLayerGroups();

      /**
       * Fire a layer groups query for every key entered in the filter/search
       * input.
       */
      scope.$watch('searchLayerGroups', function(newValue, oldValue) {
        fetchLayerGroups({'q': newValue});
      });

      scope.$watch('layerGroupsCurrentPage', function (currentPage) {
        fetchLayerGroups({'q': scope.searchLayerGroups, 'page': currentPage});
      });
    };

    return {
      link: link,
      restrict: 'E',
      scope: {
        menu: '='
      },
      templateUrl: 'data-menu/layer-adder.html'
    };

  }
]);

/**
 * @memberof datamenu
 * @description Makes the data menu items
 */
angular.module('data-menu')
  .directive('datamenuItem', ['State', 'rmAllButLastAssetAndGeometry', function (State, rmAllButLastAssetAndGeometry) {

  var link = function (scope, elem, attrs) {

    /**
     * Leaves all points when going from point to multi-point. Removes all but
     * last asset when going from multi-point to point and removes everything
     * when coming or going to line, region or area.
     */
    scope.changeBoxType = function () {
      if (scope.type === 'point' && scope.boxType === 'multi-point') {
        rmAllButLastAssetAndGeometry();
      }
      // TODO: enable line with others, only clicklayer is bitching.
      else if (!(scope.boxType === 'point' && scope.type === 'multi-point')) {
        State.selected.geometries = [];
        State.selected.assets = [];
      }
      scope.boxType = scope.type;
    };

  };

  return {
    link: link,
    restrict: 'E',
    replace: true,
    scope: {
      boxType: '=',
      type: '@',
      icon: '@'
    },
    templateUrl: 'data-menu/data-menu-item.html'
  };
}]);

'use strict';

/**
 * @ngdoc controller
 * @class UrlController
 * @memberof app
 * @name UrlController
 * @summary Sets and gets the url to the state and vice versa.
 * @description UrlController reacts to $locationChangeSucces to read
 * the url and configure lizard-nxt state accordingly. Writes state
 * changes to url. At initial load of app, url leads. Afterwards the
 * state leads the url.
 */
angular.module('lizard-nxt')
.controller('UrlController', [
  '$scope',
  '$timeout',
  'LocationGetterSetter',
  'UrlState',
  'UtilService',
  'dataBounds',
  'defaultLocale',
  'DataService',
  'MapService',
  'NxtRegionsLayer',
  'State',
  'LeafletService',
  'gettextCatalog',
  'FavouritesService',
  function (
    $scope,
    $timeout,
    LocationGetterSetter,
    UrlState,
    UtilService,
    dataBounds,
    defaultLocale,
    DataService,
    MapService,
    NxtRegionsLayer,
    State,
    LeafletService,
    gettextCatalog,
    FavouritesService
  ) {

    // Configuration object for url state.
    var state = {
      language: {
        part: 'path',
        index: 0
      },
      context: { // Locally used name for the state
        value: 'map', // default
        part: 'path', // Part of the url where this state is stored,
        index: 1, // Position of the state in the part
      },
      layerGroups: {
        part: 'path',
        index: 2,
      },
      boxType: {
        part: 'path',
        index: 3,
      },
      geom: {
        part: 'path',
        index: 4,
      },
      mapView: {
        part: 'at',
        index: 0,
      },
      timeState: {
        part: 'at',
        index: 1,
      },
    };

   /**
    * @function
    * @memberOf app.UrlController
    * @summary Enables or disables layerGroups on the basis of the url.
    * @description Takes the layerGroups as defined in the url to turn
    *              layerGroups on afterwards it initializes all other
    *              layerGroups. This is done here so MapService does not turn
    *              on layerGroups which are turned of later by this controller.
    * @param {string} String representation of layerGroups on url
    */
    var enablelayerGroups = function (layerGroupString) {
      if (layerGroupString) {
        // Either layerGroups are on url
        State.layerGroups.active = layerGroupString.split(',');
        // Or layerGroups are not on url, turn default layerGroups on
      } else if (State.layerGroups.active.length === 0){
        DataService.setLayerGoupsToDefault();
      }
      UrlState.setlayerGroupsUrl(state, State.layerGroups.active);
    };

   /**
    * @function
    * @memberOf app.UrlController
    * @summary Sets the mapView on the url or the url on the mapView
    * @description If mapView as string from the url is a parseable
    *              mapView, the map is set to this view. Else the map
    *              is set to bounds of data as defined by the server.
    * @param {string} String representation of mapView on url
    */
    var enableMapView = function (mapView) {
      var defaultBounds = LeafletService.latLngBounds(
        L.latLng(dataBounds.south, dataBounds.east),
        L.latLng(dataBounds.north, dataBounds.west)
      );

      if (mapView) {
        var view = UrlState.parseMapView(mapView);
        if (view) {
          State.spatial.view = {
            lat: view.latLng[0],
            lng: view.latLng[1],
            zoom: view.zoom
          };
        } else {
          State.spatial.bounds = defaultBounds;
        }
      } else {
        State.spatial.bounds = defaultBounds;
      }
    };

    /**
     * Attempts to set the language based on what is provided, what is the
     * Injected default value or the hardcoded value in this function.
     *
     * If all fails, their will be no translation and all text will be in
     * English.
     *
     * @param {str} lang language code according to ISO-639-1.
     */
    var setLanguage = function (lang) {
      var defaultLang = State.language;

      if (lang === undefined && defaultLocale) {
        lang = defaultLocale.slice(0,2); // language is the first 2 places of
                                         // locale e.g.: nl_NL;
      } else if (lang === undefined) {
        lang = defaultLang;
      }

      // Check if this language exists, otherwise use the default.
      if (!gettextCatalog.strings[lang]
        && lang !==gettextCatalog.baseLanguage) {
        lang = defaultLang;
      }

      gettextCatalog.setCurrentLanguage(lang);

      // Store language in global state object. Among other, it is used for
      // searchresults.
      State.language = lang;
    };

    /**
     * set layer(s) when these change.
     */
    $scope.$watch(State.toString('layerGroups.active'),
      function (n, o) {
        if (n === o) { return true; }
        UrlState.setlayerGroupsUrl(state, State.layerGroups.active);
      }
    );

    /**
     * Set location when map moved.
     */
    $scope.$watch(State.toString('spatial.bounds'), function (n, o) {
      if (n === o || !State.spatial.view.lat) { return true; }
      UrlState.setCoordinatesUrl(state,
        State.spatial.view.lat,
        State.spatial.view.lng,
        State.spatial.view.zoom
      );
    });

    /**
     * Set timeState, when timeState changed. The helper serves eliminating
     * redundant code, within this file.
     */
    var setTimeStateUrlHelper = function () {
      if (!State.temporal.timelineMoving) {
        if (Date.now() - State.temporal.start > 7 * UtilService.day) {
          State.temporal.relative = false;
        } else {
          State.temporal.relative = true;
        }
        UrlState.setTimeStateUrl(
          state,
          State.temporal.start,
          State.temporal.end,
          State.temporal.relative
        );
      }
    };

    /**
     * Set timeState, when timeState changed in response to panning/zooming the
     * timeline and in response to the user clicking the 3 timeline buttons.
     */
    $scope.$watch(State.toString('temporal.timelineMoving'), function (n, o) {
      if (n === o) { return true; }
      setTimeStateUrlHelper();
    });

    /*
     * Set boxType when box.type changed
     */
    $scope.$watch(State.toString('box.type'), function (n, old) {
      if (n === old) { return true; }
      LocationGetterSetter.setUrlValue(
        state.boxType.part, state.boxType.index, State.box.type
      );

      if (['point', 'line', 'region', 'multi-point'].indexOf(old) !== -1) {
        // Remove geometry from url
        LocationGetterSetter.setUrlValue(
          state.geom.part, state.geom.index, undefined);
      }

    });

    /*
     * Set context when context changed
     */
    $scope.$watch(State.toString('context'), function (n, old) {
      if (n === old) { return true; }
      state.context.update = true;

      LocationGetterSetter.setUrlValue(
        state.context.part, state.context.index, State.context
      );
    });

    $scope.$watch(State.toString('selected'), function (n, o) {
      if (n === o) { return true; }
      UrlState.setSelectedUrl(state, State.selected);
    });

    /**
     * @function
     * @description Checks if the url is a `favourite url`. And then proceeds to
     * fetch the favourites as it is asked.
     * return {object} - thennable promise which resolves to true/false
     */
    var favouritesFromUrl = function () {
      var firstUrlPart = LocationGetterSetter.getUrlValue(
        'path', 0);
      if (firstUrlPart !== 'favourites') {
        return false;
      } else {
        var favouriteUUID = LocationGetterSetter.getUrlValue(
          'path',
          1
        );
        return favouriteUUID;
      }
    };

    /**
     * Set the state from the url on init or set the url from the default state
     * when the url is empty.
     */
    var setStateFromUrl = function (favouriteURL) {
      var language;
      var boxType;
      var geom;
      var layerGroupsFromURL;
      var mapView;
      var time;
      var context;
      if (!favouriteURL) {
        language = LocationGetterSetter.getUrlValue(
          state.language.part,
          state.language.index
        );
        boxType = LocationGetterSetter.getUrlValue(
          state.boxType.part,
          state.boxType.index
        );
        geom = LocationGetterSetter.getUrlValue(
          state.geom.part,
          state.geom.index
        );
        layerGroupsFromURL = LocationGetterSetter.getUrlValue(
          state.layerGroups.part,
          state.layerGroups.index
        );
        mapView = LocationGetterSetter.getUrlValue(
          state.mapView.part,
          state.mapView.index
        );
        time = LocationGetterSetter.getUrlValue(
          state.timeState.part,
          state.timeState.index
        );
        context = LocationGetterSetter.getUrlValue(
          state.context.part,
          state.context.index
        );
      }

      setLanguage(language);

      LocationGetterSetter.setUrlValue(
        state.language.part,
        state.language.index,
        gettextCatalog.getCurrentLanguage()
      );

      // If language === 'favourites' something went wrong with the favourite
      // ignore it and default.
      if (context && language !== 'favourites') {
        $scope.transitionToContext(context);
      } else if (!favouriteURL) {
        LocationGetterSetter.setUrlValue(
          state.context.part, state.context.index, state.context.value);
        $scope.transitionToContext(state.context.value);
      }

      if (boxType) {
        State.box.type = boxType;
      } else {
        LocationGetterSetter.setUrlValue(
          state.boxType.part, state.boxType.index, State.box.type);
      }

      if (geom) {
        State.selected = UrlState.parseSelection(geom, State.selected);
        if (boxType === 'region') {
          NxtRegionsLayer.setActiveRegion(parseInt(geom));
        }
      }

      enablelayerGroups(layerGroupsFromURL);
      enableMapView(mapView);

      if (time) {
        State.temporal = UrlState.parseTimeState(time, State.temporal);
      } else {
        state.timeState.update = false;
        UrlState.setTimeStateUrl(
          state,
          State.temporal.start,
          State.temporal.end,
          State.temporal.relative
        );
      }

      UtilService.announceMovedTimeline(State);

    };


    var favouriteUUID = favouritesFromUrl();
    if (favouriteUUID) {
      FavouritesService.getFavourite(
        favouriteUUID,
        function (favourite, getResponseHeaders) {
          FavouritesService.applyFavourite(favourite);
          setStateFromUrl(true);
        },
        function () {
          setStateFromUrl(false);
        }
      );
    }
    else {
      setStateFromUrl(false);
    }

  }
]);


/**
 * @class LocationGetterSetter
 * @memberOf app
 *
 * @summary Lower level service to set $location.
 *
 * @description
 * Provides a setter and getter function to manipulate parts of the url to
 * keep the url synchronised with the actual application state. That way
 * you can use the url to share application state.
 */
angular.module('lizard-nxt')
  .service('LocationGetterSetter', ['$location', function ($location) {

    var _getPath, _getPathParts,

    service = {

     /**
      * @function
      * @memberOf angular.module('lizard-nxt').LocationGetterSetter
      * @description returns the value in the path of url at the specified part
      * @param {str} part, part url looking for currently <path | @>
      * @param {str} index location in the part
      * @return {str} value
      */
      getUrlValue: function (part, index) {
        if (!(part === 'path' || part === 'at')) {
          throw new Error(String(part) + ' is not a supported part of the url');
        }
        var pathParts = _getPathParts(part);
        var value = pathParts[index] === '' ? undefined : pathParts[index];
        return value;
      },

     /**
      * @function
      * @memberOf angular.module('lizard-nxt').LocationGetterSetter
      * @description sets the value in the path of url at the specified part
      * @param {str} part, part url looking for currently <path | @>
      * @param {str} index location in the part
      * @param {str} value
      */
      setUrlValue: function (part, index, value) {
        if (!(part === 'path' || part === 'at')) {
          throw new Error(String(part) + ' is not a supported part of the url');
        }
        if (value && !(typeof(value) === 'string' || typeof(value) === 'number')) {
          throw new Error(String(value) + ' cannot be set on the url');
        }
        var halfPath, otherHalf, parts = _getPathParts(part);
        if (!value && parts.length - 1 === index) {
          parts.splice(index, 1); // remove if no value and index is last one.
        } else {
          parts[index] = value; //replace
        }
        halfPath = parts.join('/');
        if (part === 'path') {
          otherHalf = _getPath('at') ? '@' + _getPath('at') : '';
          $location.path('/' + halfPath + otherHalf);
        } else {
          otherHalf = _getPath('path') ? _getPath('path') + '@' : '@';
          $location.path('/' + otherHalf + halfPath);
        }
      }
    };

   /**
    * @function
    * @memberOf angular.module('lizard-nxt')
  .LocationGetterSetter
    * @description returns the part of the path without first slash.
    * @param {str} part, part url looking for currently <path | @>
    * @return {str} the part the path.
    */
    _getPath = function (part) {

      var paths,
          pathPart,
          path = $location.path();

      paths = path.split('@'); //splits path in two at the @.
      pathPart = paths[part === 'path' ? 0 : 1] || ''; //gets before @ when 'path' after when 'at'
      // we do not want the first slash
      pathPart = part === 'path' ? pathPart.slice(1) : pathPart;
      return pathPart;
    };

   /**
    * @function
    * @memberOf angular.module('lizard-nxt')
  .LocationGetterSetter
    * @description splits the part of the path further in individual values.
    * @param {str} part of the path without first slash.
    * @return {array} the values in the part of the path.
    */
    _getPathParts = function (part) {
      var pathPart = _getPath(part);
      if (!pathPart) { return []; }
      return pathPart.split('/');
    };
    return service;
  }]);


/**
 * @ngdoc service
 * @class UrlState
 * @name UrlState
 * @description Higher level functions to parse and set URL.
 */
angular.module('lizard-nxt')
  .service("UrlState", ["LocationGetterSetter", "UtilService", function (LocationGetterSetter, UtilService) {

    // Amount of decimals of coordinates stored in url.
    var COORD_PRECISION = 4;

    var service = {

     /**
      * @function
      * @memberOf UrlState
      * @description Sets the points or the here on the url when
      *              respectively point or line is specified as type.
      * @param {object} state config object
      * @param {str} type box.type
      * @param {object} here leaflet LatLng object
      * @param {array} points array of leaflet LatLng objects
      */
      setgeomUrl: function (state, type, here, points) {
        var pointsStr = '';
        if (type === 'line') {
          angular.forEach(points, function (point) {
            pointsStr += point.lat.toFixed(COORD_PRECISION) + ',' + point.lng.toFixed(COORD_PRECISION) + '-';
          });
          pointsStr = pointsStr.substring(0, pointsStr.length - 1);
        } else {
          pointsStr = here === undefined
            ? ''
            : here.lat.toFixed(COORD_PRECISION) + ',' + here.lng.toFixed(COORD_PRECISION);
        }
        LocationGetterSetter.setUrlValue(state.geom.part, state.geom.index, pointsStr);
      },

     /**
      * @function
      * @memberOf UrlState
      * @description Sets the start and end epoch ms on the url
      * @param {object} state config object
      * @param {int} start time in ms
      * @param {int} end time in ms
      * @param {bool} relative time or absolute
      */
      setTimeStateUrl: function (state, start, end, relative) {
        var startDate = new Date(start);
        var endDate = new Date(end);

        if (relative) {
          var now = Date.now(),
              past = now - start,
              future = now - end;

          past = UtilService.getTimeIntervalAsText(start, now);
          future = UtilService.getTimeIntervalAsText(now, end);

          var pastString = '-' + past.days + 'Days' + past.hours + 'Hours';
          var futureString = '';

          if (future.days !== '' && future.hours !== '') {
            futureString = '+' + future.days + 'Days' + future.hours + 'Hours';
          }

          LocationGetterSetter.setUrlValue(
            state.timeState.part,
            state.timeState.index,
            pastString + futureString
          );
        } else {
          var startDateString = startDate.toDateString()
          .slice(4) // Cut off day name
          .split(' ') // Replace spaces by hyphens
          .join(',');
          var endDateString = endDate.toDateString()
          .slice(4) // Cut off day name
          .split(' ') // Replace spaces by hyphens
          .join(',');
          LocationGetterSetter.setUrlValue(
          state.timeState.part,
          state.timeState.index,
          startDateString + '-' + endDateString);
        }
      },

     /**
      * @function
      * @memberOf UrlState
      * @description Sets the mapView coordinates on the url.
      * @param {object} state config object
      * @param {object} lat leaflet Latitude object
      * @param {object} lng leaflet Lng object
      * @param {int} zoom level
      */
      setCoordinatesUrl: function (state, lat, lng, zoom) {
        var COORD_PRECISION = 4;
        var newHash = [
          parseFloat(lat).toFixed(COORD_PRECISION),
          parseFloat(lng).toFixed(COORD_PRECISION),
          zoom
        ].join(',');
        LocationGetterSetter.setUrlValue(
          state.mapView.part,
          state.mapView.index,
          newHash);
      },

      /**
       * @function
       * @memberOf UrlState
       * @description Sets the selected items part of the url
       * @param {object} state config object
       * @param {object} selected object (containing, assets, and geoms)
       */
      setSelectedUrl: function (state, selected) {
        var newHash = angular.copy(selected.assets);
        var n = Math.pow(10, COORD_PRECISION);
        var coords;
        angular.forEach(selected.geometries, function (geom) {
          if (geom.geometry.type === 'Point') {
            coords = angular.copy(geom.geometry.coordinates);
            coords.forEach(function (point, i) {
              coords[i] = Math.round(point * n) / n;
            });
            newHash.push(coords.join(','));
          }
          if (geom.geometry.type === 'LineString') {
            var points = [];
            coords = angular.copy(geom.geometry.coordinates);
            angular.forEach(coords, function (point) {
              point.forEach(function (pos, i) {
                point[i] = Math.round(pos * n) / n;
              });
              points.push(point.join(','));
            });
            newHash.push(points.join('-'));
          }
          if (geom.geometry.type === 'Polygon' && geom.id) {
            newHash.push(geom.id);
          }
        });

        LocationGetterSetter.setUrlValue(
          state.geom.part,
          state.geom.index,
          newHash.join('+')
        );
      },

      /**
       * @function
       * @memberOf UrlState
       * @description Sets the layer slugs on the url.
       * @param {object} state config object
       * @param {object} layerGroups list
       */
      setlayerGroupsUrl: function (state, layerGroups) {
        if (layerGroups === undefined) { return; }
        LocationGetterSetter.setUrlValue(
          state.layerGroups.part,
          state.layerGroups.index,
          layerGroups.toString()
        );
      },
      /**
       * @function
       * @memberOf UrlState
       * @description Sets the layer slugs on the url.
       * @param  {str} time time value of the url
       * @param  {object} timeState nxt timeState
       * @return {object} nxt timeState
       */
      parseTimeState: function (time, timeState) {
        var times, msStartTime, msEndTime;
        if (time.split('Days').length > 1) {
          times = time.split('-')[1].split('+');
          var past = times[0];
          var future = times[1];

          msStartTime = UtilService.parseDaysHours(past);
          msEndTime = UtilService.parseDaysHours(future);

          timeState.start = Date.now() - msStartTime;
          timeState.end = Date.now() + msEndTime;
        } else {
          // Browser independent. IE requires datestrings in a certain format.
          times = time.replace(/,/g, ' ').split('-');
          msStartTime = Date.parse(times[0]);
          // bail if time is not parsable, but return timeState
          if (isNaN(msStartTime)) { return timeState; }
          timeState.start = msStartTime;

          msEndTime = Date.parse(times[1]);
          if (isNaN(msEndTime)) { return timeState; }
          if (msEndTime <= timeState.start) {
            msEndTime = timeState.start + 43200000; // half a day
          }
          timeState.end = msEndTime;
        }

        return timeState;
      },
      /**
       * @function
       * @memberOf UrlState
       * @description returns the mapview value parsed to
       *              latlonzoom
       * @param  {str} mapView
       * @return {object_or_false} Lat lon zoom object or false
       *                               when not valid.
       */
      parseMapView: function (mapView) {
        var latlonzoom = mapView.split(',');
        if (latlonzoom.length === 3
          && parseFloat(latlonzoom[0])
          && parseFloat(latlonzoom[1])
          && parseFloat(latlonzoom[2])) {
          return {
            latLng: [parseFloat(latlonzoom[0]), parseFloat(latlonzoom[1])],
            zoom: parseFloat(latlonzoom[2]),
            options: {reset: true, animate: true}
          };
        } else {
          return false;
        }
      },

      parseSelection: function (geom, selection) {
        var selections = geom.split('+');
        selections.forEach(function (selected) {
          if (selected.split('$').length === 2) {
            selection.assets.addAsset(selected);
          }

          else {
            var geometry = {
              geometry: {
                type: 'LineString'
              }
            };
            var coordinates = [];

            if (selected.split('-').length > 1) {
              // Line
              var points = selected.split('-');
              angular.forEach(points, function (pointStr) {
                var point = pointStr.split(',');
                if (parseFloat(point[0]) &&
                    parseFloat(point[1])) {
                  coordinates.push([Number(point[0]), Number(point[1])]);
                }
              });
              geometry.geometry.coordinates = coordinates;
              selection.geometries.addGeometry(geometry);
            }

            else if (selected.split(',').length > 1) {
              geometry = {
                geometry: {
                  type: 'Point'
                }
              };
              var point = selected.split(',');
              if (parseFloat(point[0]) &&
                  parseFloat(point[1])) {
                coordinates = [Number(point[0]), Number(point[1])];
                geometry.geometry.coordinates = coordinates;
                selection.geometries.addGeometry(geometry);
              }
            }

          }
        });

        return selection;
      },
      update: function (state) {
        var u = true;
        angular.forEach(state, function (value) {
          if (!value.update) {
            u = false;
          }
        });
        return u;
      }
    };

    return service;

  }
]);

angular.module('map', [
  'global-state',
  'data-menu'
]);

'use strict';

/**
 * @ngdoc service
 * @name map.NxtRegionsLayer
 * @description
 * Adds a leaflet geojson layer to draw regions.
 */
angular.module('map')
.factory('NxtRegionsLayer', [
  'CabinetService',
  'LeafletService',
  function (CabinetService, LeafletService) {

    // Leaflet geojson layer.
    var regionsLayer;

    // String of feature.properties.name that should be active.
    var activeRegionId;

    // ILayer of last region that recieved click.
    var previousActiveLayer;

    var deafaultRegionStyle = {
      weight: 2,
      opacity: 0.6,
      color: '#7f8c8d', // asbestos
      fillOpacity: 0
    };

    var mouseOverStyle = {
      fillColor: '#e74c3c', // alizarin
      fillOpacity: 0.1
    };

    var activeRegionStyle = {
      weight: 4,
      fillColor: '#e74c3c', // alizarin
      color: '#c0392b', // pomegranate
      dashArray: '6',
      fillOpacity: 0.1
    };

    /**
     * Draws regions as a L.geoJson layer on the map. Sets click function. And
     * Fires click if activeRegionId is not falsy.
     *
     * @param  {geojson}  regions
     * @param  {funciton} clickCb callback fires when layer is clicked.
     */
    var addRegions = function (MapService, regions, clickCb) {
      MapService.removeLeafletLayer(regionsLayer);
      regionsLayer = LeafletService.geoJson(regions, {
        // Style function must be included in order to overwrite style on click.
        style: function (feature) {
          return deafaultRegionStyle;
        },
        onEachFeature: function (d, layer) {
          layer.on({
            mouseover: function (e) {
              var layer = e.target;

              layer.setStyle(mouseOverStyle);

            },
            mouseout: function (e) {
              if (e.target.feature.id !== activeRegionId) {
                regionsLayer.resetStyle(e.target);
              }
            },
            click: function (e) {

              if (previousActiveLayer) {
                regionsLayer.resetStyle(previousActiveLayer);
              }

              var newActiveLayer = e.target;
              newActiveLayer.setStyle(activeRegionStyle);

              clickCb(this);

              activeRegionId = newActiveLayer.feature.id;
              previousActiveLayer = newActiveLayer;
            }
          });
        }
      });
      MapService.addLeafletLayer(regionsLayer);
      if (activeRegionId) { setActiveRegion(activeRegionId); }
    };

    /**
     * Removes the regions from the map and sets activeRegioString to null.
     */
    var removeRegions = function (MapService) {
      activeRegionId = null;
      MapService.removeLeafletLayer(regionsLayer);
    };

    /**
     * Sets the activeRegion, by firing a click when regionsLayer exists, or
     * sets activeRegionId that triggers a call of this function onload.
     *
     * @param {string} region feature.id of region.
     */
    var setActiveRegion = function (region) {
      if (regionsLayer) {
        var layer = _getRegion(regionsLayer, region);
        if (layer) {
          layer.fire('click');
        }
        else {
          activeRegionId = null;
        }
      } else {
        activeRegionId = region;
      }
    };

    var getActiveRegion = function () {
      return activeRegionId;
    };

    /**
     * Gets region layer with properties.name === regionName of the currently
     * drawn regions.
     *
     * @param  {L.GeoJson} lGeo        Leaflet L.GeoJson instance.
     * @param  {string} regionName     Properties.name of region
     * @return {L.ILayer} Region layer or undefined if not found
     */
    var _getRegion = function (lGeo, regionId) {
      var region;
      lGeo.eachLayer(function (layer) {
        if (layer.feature.id === regionId) {
          region = layer;
        }
      });
      return region;
    };

    return {
      add: addRegions,
      remove: removeRegions,
      setActiveRegion: setActiveRegion,
      getActiveRegion: getActiveRegion
    };

  }]
);

'use strict';

/**
 * @ngdoc service
 * @name lizard-nxt.Layer
 * @description
 *
 * Non tiled wms layers use a bounding box to make request to a wms for one tile
 * which is displayed as a leaflet image overlay. Nxt-non-tiled-wms-layer is
 * used to create a wms layer that is animatable. When synced to time, it builds
 * a buffer of images, fills the buffer with new images or turns one of the
 * images from the buffer on and start loading a new image in the place of the
 * previous.
 *
 * Usage: add animation functionality to an instance NxtLayer by using
 * NxtNonTiledWMSLayer.create(<layer>);
 *
 */
angular.module('map')
.factory('NxtNonTiledWMSLayer', [
  'NxtLayer',
  'LeafletService',
  'RasterService',
  'UtilService',
  '$http',
  '$q',
  function (NxtLayer, LeafletService, RasterService, UtilService, $http, $q) {

      /**
       * @function
       * @memberof app.LayerGroup
       * @param {L.Class} Leaflet layer.
       * @description Adds layer to map
       */
      var addLeafletLayer = function (map, leafletLayer) { // Leaflet NxtLayer
        if (map.hasLayer(leafletLayer)) {
          throw new Error(
            'Attempted to add layer' + leafletLayer._id
            + 'while it was already part of the map'
          );
        } else {
          map.addLayer(leafletLayer);
        }
        return leafletLayer;
      };

      /**
       * @function
       * @memberof app.LayerGroup
       * @param  {L.Class} Leaflet map
       * @param  {L.Class} Leaflet layer
       * @description Removes layer from map
       */
      var removeLeafletLayer = function (map, leafletLayer) { // Leaflet NxtLayer
        if (map.hasLayer(leafletLayer)) {
          map.removeLayer(leafletLayer);
        } else {
          throw new Error(
            'Attempted to remove layer' + leafletLayer._id
            + 'while it was NOT part of provided the map'
          );
        }
      };

      return {
        create: function (layer) {

          // Array of imageoverlays used as buffer.
          Object.defineProperty(layer, '_imageOverlays', {
            value: [],
            writable: true,
          });
          // Formatter used to format a data object.
          Object.defineProperty(layer, '_formatter', {
            value: d3.time.format.utc("%Y-%m-%dT%H:%M:%S"),
            writable: true,
          });
          // Base of the image url without the time.
          Object.defineProperty(layer, '_imageUrlBase', {
            value: '',
            writable: true,
          });
          // Lookup to store which data correspond to which imageOverlay.
          Object.defineProperty(layer, '_frameLookup', {
            value: {},
            writable: true,
          });
          // Length of the buffer, set in the initialization. Ideally the buffer
          // is small to get up to speed fast, for slow connections or high
          // frequent images it should be large. When having a very sparse
          // resolution, animation will also move slowly, so there is no need
          // for a big buffer.
          Object.defineProperty(layer, '_bufferLength', {
            value: layer._temporalResolution >= 3600000 ? 2 : 6,
            writable: true,
          });
          // Number of rasters currently underway.
          Object.defineProperty(layer, '_nLoadingRasters', {
            value: 0,
            writable: true,
          });

          angular.extend(layer, {

            /**
             * @description Adds one imageOverlay with the current time to the map.
             * @return a promise that resolves when the image has loaded. Usefull
             *         for sequential loading of layers.
             */
            add: function (map, optionalDefer) {

              var defer = optionalDefer || $q.defer(),
                  opacity = this._opacity,
                  date = new Date(this._mkTimeStamp(this.timeState.at)),
                  store = this._determineStore(this.timeState);

              var options = {
                layers: store.name,
                format: 'image/png',
                version: '1.1.1',
                minZoom: layer.min_zoom || 0,
                maxZoom: 19,
                opacity: layer.opacity,
                zIndex: layer.zIndex,
                crs: LeafletService.CRS.EPSG3857,
                time: this._formatter(date)
              };

              options = angular.extend(options, layer.options);

              // This breaks styles with negative values
              // and for the moment only applies to radar.
              if (this.slug.split('/')[0] === 'radar') {
                this.options.styles = this.options.styles.split('-')[0]
                  + '-'
                  + store.name.split('/')[1];
              }

              this._imageOverlays = [
                LeafletService.tileLayer.wms(layer.url, options)
              ];

              // defer is passed to loadlistener to be resolved when done.
              this._addLoadListener(
                this._imageOverlays[0].addTo(map),
                this.timeState.at,
                defer
              );

              return defer.promise;
            },

            /**
             * @summary    Sets the new timeState on the layer. And updates the layer
             *             to the new time.
             *
             * @parameter timeState nxt object containing current time on at.
             * @parameter map leaflet map to add layers to.
             *
             * @return a promise that resolves when the layer has finished
             *         syncing. It is considered finished when it finishes loading
             *         a new buffer or when it was able to set a new frame from its
             *         buffer.
             */
            syncTime: function (timeState, map) {
              var defer = $q.defer();

              this.timeState = timeState;

              // this only works for stores with different aggregation levels
              // for now this is only for the radar stores
              // change image url based on timestate.
              var store = this._determineStore(this.timeState);

              this._temporalResolution = store.resolution;

              // This breaks styles with negative values
              // and for the moment only applies to radar.
              if (this.slug.split('/')[0] === 'radar') {
                this.options.styles = this.options.styles.split('-')[0]
                  + '-'
                  + store.name.split('/')[1];
              }

              // Continue when layers need to update to new time.
              if (this._imageOverlays.length) {
                this._syncToNewTime(timeState, map, defer);
              }

              return defer.promise;
            },

            /**
             * @description removes all _imageOverlays from the map. Removes
             *              listeners from the _imageOverlays, the _imageOverlays
             *              from this layer and removes the references to
             *              the _imageOverlays.
             */
            remove: function (map) {
              for (var i in this._imageOverlays) {
                if (map.hasLayer(this._imageOverlays[i])) {
                  this._imageOverlays[i].off('load');
                  map.removeLayer(this._imageOverlays[i]);
                }
              }
              this._nLoadingRasters = 0;
              this._imageOverlays = [];
              this._frameLookup = {};
            },

            /**
             * @description sets the provided opacity to the layer and all the
             *              _imageOverlays that have an opacity other than 0. Sets
             *              the opacity to nearly 0 when the provided opacity is
             *              exactly 0 in order to distinguish layers that are off
             *              and layers that have are transparant.
             */
            setOpacity: function (opacity) {
              if (opacity === 0) { opacity = 0.1; }
              this._opacity = opacity;
              angular.forEach(this._frameLookup, function (frameIndex) {
                if (this._imageOverlays[frameIndex].options.opacity !== 0) {
                  this._imageOverlays[frameIndex].setOpacity(this._opacity);
                }
              }, this);
              return;
            },

            /**
             * Takes a new timeState and delegates to sync functions for
             * animation or non-animation.
             * @param  {object} map         leaflet map
             * @param  {int}    currentDate ms from epoch
             * @param  {object} defer       defer to resolve when done
             */
            _syncToNewTime: function (timeState, map, defer) {
              var currentDate = this._mkTimeStamp(timeState.at);
              if (timeState.playing) {
                this._animateSyncTime(map, currentDate, defer);
              }
              else {
                this._tiledSyncTime(map, currentDate, defer);
              }
            },

            /**
             * syncToTime with a tiled layer. Simpy removes everything and uses
             * add method to create a new tiled layer
             * @param  {object} map         leaflet map
             * @param  {int}    currentDate ms from epoch
             * @param  {object} defer       defer to resolve when done
             */
            _tiledSyncTime: function (map, currentDate, defer) {
              this.remove(map);
              this.add(map, defer);
            },

            /**
             * syncToTime with imageOverlays for animation. See syncTime docstr
             * for more info.
             *
             * @decription When there are not enough or the imageOverlays have
             *             an outdated bounds, more overlays are added to the
             *             map. The curent timeState.at is rounded
             *             to the nearest date value present on the wms server. The
             *             currentDate value is used to lookup the index of the
             *             frame in the _frameLookup. The _frameLookup contains all
             *             the dates that are present in the buffer and the index
             *             of the imageoverlay it is stored on:
             *
             *               { <date in ms from epoch> : <index on _imageOverlays> }
             *
             *               length is 0, 1 or _bufferLength.
             *
             *             The date is either: 1. present in the lookup in case the
             *             index is defined or 2. not present in case this frame is
             *             not loaded yet.
             *
             *             When 1. The imageOverlay with index <currentOverlayIndex>
             *             is set to _opacity and the defer is resolved. The image
             *             sources of the _imageOverlays with opacity !== 0 are set
             *             to the next date not in the _frameLookup, the opacity is
             *             set to 0 and the reference is removed from the
             *             _frameLookup. A loadListener adds a new reference to the
             *             _frameLookup when the layer finishes loading a new frame.
             *
             *             When 2. All references are removed and all layers get a
             *             new source. When the new source is different than the one
             *             it currently has, the loadListener is removed and a new
             *             one source and loadlistener are added. When all layers
             *             have loaded, the first layer's opacity is set to _opacity
             *             and the defer is resolved.
             *
             * @param  {object} map         leaflet map
             * @param  {int}    currentDate ms from epoch
             * @param  {object} defer       defer to resolve when done
             */
            _animateSyncTime: function (map, currentDate, defer) {
              var newBounds = this._getAnimationBounds(map);

              if (this._imageOverlays.length < this._bufferLength
                || newBounds.getNorth() !== this._animationBounds.getNorth()
                || newBounds.getWest() !== this._animationBounds.getWest()) {
                this._animationBounds = newBounds;

                // add leaflet layers to fill up the buffer and set imageUrlBase
                // which depends on the bounds of the map and the layer and the
                // store that corresponds to the timeState.

                var store = this._determineStore(this.timeState);

                var options = {
                  bounds: this._animationBounds,
                  size: this._getImageSize(map, this._animationBounds)
                };

                this._imageUrlBase = RasterService.buildURLforWMS(
                  this,
                  map,
                  store.name,
                  this.timeState.playing,
                  options
                );

                this._imageOverlays = this._createImageOverlays(
                  map,
                  this._bufferLength,
                  this._animationBounds
                );
              }

              var currentOverlayIndex = this._frameLookup[currentDate];

              if (currentOverlayIndex === undefined) {
                // Ran out of buffered frames
                this._imageOverlays = this._fetchNewFrames(
                  currentDate,
                  this._imageOverlays,
                  defer
                );
              }

              else {
                this._progressFrame(currentOverlayIndex);
                // Done!
                defer.resolve();
              }

            },

            /**
             * @description Adds new imageoverlays.
             * @param  {L.Map} map.
             * @param  {overlays} overlays current overlays to add to.
             * @param  {bounds} bounds   bounds of overlays.
             * @param  {int} buffer   amount of imageOverlays to include.
             * @return {array} array of L.imageOverlays.
             */
            _createImageOverlays: function (map, buffer, bounds) {
              // detach all listeners and references to the imageOverlays.
              this.remove(map);
              // create new ones.
              for (var i = this._imageOverlays.length; i < buffer; i++) {
                this._imageOverlays.push(
                  addLeafletLayer(map, LeafletService.imageOverlay('', bounds))
                );
              }
              return this._imageOverlays;
            },

            /**
             * Takes the bounds of the map and creates an intersection of the
             * layer and the map for animation.
             *
             * @param  {L.Map} map with getBounds
             * @return {L.LatLngBounds} leaflet bounds of intersection
             */
            _getAnimationBounds: function (map) {
              var mapBounds = map.getBounds();

              var smallestSoutWest = LeafletService.latLng(
                Math.max(this.bounds.south, mapBounds.getSouth()),
                Math.max(this.bounds.west, mapBounds.getWest())
              );

              var smallesNorthEast = LeafletService.latLng(
                Math.min(this.bounds.north, mapBounds.getNorth()),
                Math.min(this.bounds.east, mapBounds.getEast())
              );

              return LeafletService.latLngBounds(
                smallestSoutWest,
                smallesNorthEast
              );

            },

            /**
             * Determines the pixel size of the imageoverlay on the map.
             *
             * @param  {L.Map} map
             * @param  {L.LatLngBounds} animationBounds intersection of map
             *                          bounds and layer bounds.
             *
             * @return {object}  object with x and y size in horizontal (x) and
             *                               vertical (y) direction.
             */
            _getImageSize: function (map, animationBounds) {
              var bottomLeft = map.latLngToContainerPoint(
                animationBounds.getSouthWest()
              );

              var topRight = map.latLngToContainerPoint(
                animationBounds.getNorthEast()
              );

              return {
                x : topRight.x - bottomLeft.x,
                y: bottomLeft.y- topRight.y
              };
            },

            /**
             * Local helper that returns a rounded timestamp
             */
            _mkTimeStamp: function (t) {
              var result = UtilService.roundTimestamp(t, this._temporalResolution, false);
              return result;
            },

            /**
             * @description based on the temporal window. The time between
             * timestate.start and timestate.end determines which store is to be used.
             * This only works for radar stuff.
             *
             */
            _determineStore: function (timeState) {

              if (this.slug.split('/')[0] !== 'radar') {
                return {
                  name: layer.slug,
                  resolution: layer._temporalResolution
                };
              }

              var resolutionHours = (timeState.aggWindow) / 60 / 60 / 1000;

              var aggType = this.slug.split('/');

              if (resolutionHours >= 24) {
                aggType[1] = 'day';
              } else if (resolutionHours >= 1 && resolutionHours < 24) {
                aggType[1] = 'hour';
              } else {
                aggType[1] = '5min';
              }
              var resolutions = {
                '5min': 300000,
                'hour': 3600000,
                'day': 86400000
              };

              return {
                name: aggType.join('/'),
                resolution: resolutions[aggType[1]]
              };

            },


            /**
             * @description Removes old frame by looking for a frame that has an
             *              opacity that is not 0 and setting it to 0, deleting it
             *              from the lookup and replacing the image source. NewFrame
             *              is turned on by setting opacity to _opacity.
             * @param {int} currentOverlayIndex index of the overlay in
             *              _imageOverlays.
             */
            _progressFrame: function (currentOverlayIndex) {
              angular.forEach(this._frameLookup, function (frameIndex, key) {

                if (this._imageOverlays[frameIndex].options.opacity !== 0
                  && frameIndex !== currentOverlayIndex) {
                  // Delete the old overlay from the lookup, it is gone.
                  delete this._frameLookup[key];
                  this._replaceUrlFromFrame(frameIndex);
                }
              }, this);

              var newFrame = this._imageOverlays[currentOverlayIndex];
              // Turn on new frame
              newFrame.setOpacity(this._opacity);
            },

            /**
             * @description Replaces the image source of the provided frame. Turns
             *              frame off by setting opacity to 0. When new url is
             *              different from previous, removes loadlistener, replaces
             *              url and adds new loadlistener. When new url is the same
             *              puts the old one back in the frameLookup and turns it
             *              back on when thge first of the list. When defer is
             *              provided passes it on the loadlistener that resolves it
             *              whenn all layers finished loading.
             * @param {int} currentOverlayIndex index of the overlay in
             * @param {defer} defer <optional> gets resolved when image is loaded
             *                      and _nLoadingRasters === 0.
             */
            _replaceUrlFromFrame: function (frameIndex, defer) {
              var url = this._imageUrlBase + this._formatter(new Date(this._nxtDate));
              var frame = this._imageOverlays[frameIndex];
              frame.off('load');
              frame.setOpacity(0);
              if (url !== frame._url) {
                this._addLoadListener(frame, this._nxtDate, defer);
                frame.setUrl(url);
              }
              else {
                var index = this._imageOverlays.indexOf(frame);
                this._frameLookup[this._nxtDate] = index;
                if (index === 0) {
                  this._imageOverlays[0].setOpacity(this._opacity);
                }
              }
              this._nxtDate += this._temporalResolution;
            },

            /**
             * @description Removes all references, sets _nLoadingRasters to 0. And
             *              calls replaceUrlFromFrame for every frame in the
             *              provided overlays
             *
             * @param {int} currentData in ms from epoch
             * @param {array} overlays L.ImageOverlay s
             * @param {defer} defer that gets resolved when all frames finished
             *                      loading.
             */
            _fetchNewFrames: function (currentDate, overlays, defer) {
              this._nxtDate = currentDate;
              this._frameLookup = {};
              this._nLoadingRasters = 0;

              angular.forEach(overlays, function (overlay, i) {
                this._replaceUrlFromFrame(i, defer);
              }, this);

              return overlays;
            },

            /**
             * @description Adds loadlistener to the provided overlay. On load a
             *              reference to the image is added to the _frameLookup,
             *              turns first layer on when defer was provided and
             *              resolves defer when provided and all images are loaded.
             * @param {L.ImageOverlay} overlay to add listener to
             * @param {int} data in ms from epoch the overlay belongs to.
             * @param {object} defer defer to resolve when all layers finished
             *                       loading.
             */
            _addLoadListener: function (overlay, date, defer) {
              this._nLoadingRasters++;
              overlay.addOneTimeEventListener("load", function () {
                this._nLoadingRasters--;
                var index = this._imageOverlays.indexOf(overlay);
                this._frameLookup[date] = index;
                if (defer && index === 0) {
                  this._imageOverlays[0].setOpacity(this._opacity);
                }
                if (defer && this._nLoadingRasters === 0) {
                  defer.resolve();
                }
              }, this);
            }
          });

          return layer;

        }

      };

    }
  ]);

'use strict';

/**
 * @ngdoc service
 * @name map.Layer
 * @description
 * # NxtLayer
 * Additional methods used to extend nxtLayer with leaflet/map specific methods.
 */
angular.module('map')
  .factory('NxtMapLayer', ['$q', '$http', function ($q, $http) {

      return {

        add: function (map) {
          var defer = $q.defer();
          if (this._leafletLayer) {
            this._addLeafletLayer(map, this._leafletLayer);
            this._leafletLayer.on('load', function () {
              defer.resolve();
            });
          }
          else {
            defer.resolve();
          }
          return defer.promise;
        },

        remove: function (map) {
          if (this._leafletLayer) {
            this._removeLeafletLayer(map, this._leafletLayer);
          }
        },

        /**
         * @function
         * @description rescales layer and updates url
         */
        rescale: function (bounds) {
          if (this.rescalable) {
            var url = this.url +
              '?request=getlimits&layers=' + this.slug +
              '&width=16&height=16&srs=epsg:4326&bbox=' +
              bounds.toBBoxString();
            var self = this;
            $http.get(url).success(function (data) {
              self.limits = ':' + data[0][0] + ':' + data[0][1];
              // strip existing domain if already present.
              self.options.styles = self.options.styles.split(':')[0];
              self._leafletLayer.setParams({
                styles: self.options.styles + self.limits
              });
              self._leafletLayer.redraw();
            });
          }
        },

        setOpacity: function (opacity) {
          if (this._leafletLayer && this._leafletLayer.setOpacity) {
            this._leafletLayer.setOpacity(opacity);
          }
        },

        syncTime: function (timeState) {
          if (this.format !== 'Vector') { return; }
          this._leafletLayer.syncTime(timeState);
          return;
        },

        /**
         * @function
         * @memberof app.layerService
         * @param  {L.Class} Leaflet map
         * @param  {L.Class} Leaflet layer
         * @description Removes layer from map
         */
        _addLeafletLayer: function (map, leafletLayer) {
          if (map.hasLayer(leafletLayer)) {
            throw new Error(
              'Attempted to add layer' + leafletLayer._id
              + 'while it was already part of the map'
            );
          } else {
            map.addLayer(leafletLayer);
          }
        },

        /**
         * @function
         * @memberof app.layerService
         * @param  {L.Class} Leaflet map
         * @param  {L.Class} Leaflet layer
         * @description Removes layer from map
         */
        _removeLeafletLayer: function (map, leafletLayer) { // Leaflet NxtLayer
          if (map.hasLayer(leafletLayer)) {
            map.removeLayer(leafletLayer);
          }
        }

      };

    }
  ]);

'use strict';

/**
 * @ngdoc service
 * @class MapService
 * @memberof app
 * @name MapService
 * @requires NxtMap
 * @summary stores global NxtMap instance of the app.
 */

angular.module('map')
.service('MapService', ['$rootScope', '$q', 'LeafletService', 'LeafletVectorService','CabinetService', 'DataService', 'NxtNonTiledWMSLayer', 'NxtRegionsLayer', 'NxtMapLayer', 'State',
  function ($rootScope, $q, LeafletService, LeafletVectorService, CabinetService, DataService, NxtNonTiledWMSLayer, NxtRegionsLayer, NxtMapLayer, State) {

    var service = {

      _map: {}, // exposure is legacy, we should not mingle with the leaflet
                // map instance outside of the map component.

      remove: function () {
        service._map.remove();
      },

      /**
       * Initializes the map service
       * @param  {DOMelement} element      used by leaflet as the map container.
       * @param  {object} mapOptions       passed to leaflet for the map
       * @param  {object} eventCallbackFns used on leaflet map events [onmove etc]
       */
      initializeMap: function (element, mapOptions, eventCallbackFns) {
        service._map = createLeafletMap(element, mapOptions);
        this.initializeLayers(State.temporal);
        this._initializeNxtMapEvents(eventCallbackFns);
        // Map-services is dependant on the dataservice. This is to prevent
        // a bunch of complicated and slow watches and still keep the data-
        // service as the data authority.
        DataService.eventCallbacks = {
          onCreateLayerGroup: this.initializeLayer,
          onToggleLayerGroup: this._toggleLayers,
          onOpacityChange: this._setOpacity,
          onDblClick: this._rescaleContinuousData
        };
        // Turn active layergroups on.
        angular.forEach(State.layerGroups.active, function (lgSlug) {
          this._toggleLayers(DataService.layerGroups[lgSlug]);
        }, this);
      },

      /**
       * Syncs all layer groups to provided timeState object.
       * @param  {object} timeState   State.temporal object, containing start,
       *                              end, at and aggwindow.
       * @param  {object} optionalMap map object to sync the data to.
       * @return {object}             promise that resolves layergroups synced.
       */
      syncTime: function (timeState) {
        var defer = $q.defer();
        var promises = [];
        angular.forEach(DataService.layerGroups, function (layerGroup) {
          if (layerGroup.isActive()) {
            angular.forEach(layerGroup.mapLayers, function (layer) {
              var p = layer.syncTime(timeState, service._map);
              if (p) {
                promises.push(p);
              }
            });
          } else {
            angular.forEach(layerGroup.mapLayers, function (layer) {
              layer.timeState = timeState;
            });
          }
        });
        var that = this;
        $q.all(promises).then(function () {
          State.layerGroups.timeIsSyncing = false;
          defer.resolve();
          return defer.promise;
        });
        if (promises.length > 0) {
          State.layerGroups.timeIsSyncing = true;
        }
        return defer.promise;
      },

      /**
       * @function
       * @memberOf map.MapService
       * @description sets leaflet View based on panZoom
       * @param {object} panZoom Hashtable with, lat, lng, zoom
       */
      setView: function (panZoom) {
        if (panZoom.hasOwnProperty('lat') &&
            panZoom.hasOwnProperty('lng') &&
            panZoom.hasOwnProperty('zoom'))
        {
          service._map.setView(new LeafletService.LatLng(
            panZoom.lat, panZoom.lng), panZoom.zoom);
        } else {
          service._map.setView.apply(service._map, arguments);
        }
      },

      /**
       * @function
       * @memberOf map.MapService
       * @description fits leaflet to extent
       * @param  {array} extent Array with NW, NE, SW,SE
       */
      fitBounds: function (bounds) {
        if (service._map instanceof LeafletService.Map) {
          if (bounds instanceof LeafletService.LatLngBounds) {
            service._map.fitBounds(bounds);
          }
          else if (bounds.hasOwnProperty('south')
            && bounds.hasOwnProperty('north')
            && bounds.hasOwnProperty('east')
            && bounds.hasOwnProperty('west')) {
            service._map.fitBounds(L.latLngBounds(
              L.latLng(bounds.south, bounds.east),
              L.latLng(bounds.north, bounds.west)));
          }
        }
      },

      getView: function () {
        return {
          lat: service._map.getCenter().lat,
          lng: service._map.getCenter().lng,
          zoom: service._map.getZoom()
        };
      },

      getBounds: function () {
        return service._map.getBounds();
      },

      line: {
        geometry: {
          type: 'LineString',
          coordinates: []
        }
      },

      /**
       * @description legacy function.
       */
      latLngToLayerPoint: function (latlng) {
        return service._map.latLngToLayerPoint(latlng);
      },

      _setAssetOrGeomFromUtfOnState: function (latLng) {
        State.selected.assets = [];
        State.selected.geometries = [];
        DataService.utfLayerGroup.getData('dataService', {'geom': latLng})
        .then(null, null, function (response) {

          var data = response.data;
          if (response.data) {
            // Create one entry in selected.assets.
            var assetId = data.entity_name + '$' + data.id;
            State.selected.assets = [assetId];
            State.selected.geometries = [];
          }

          else {
            State.selected.assets = [];
            service._setGeomFromUtfToState(latLng);
          }
        });
      },

      _setGeomFromUtfToState: function (latLng) {
        // Create one entry in selected.geometries.
        State.selected.geometries = [{
          geometry: {
            type: 'Point',
            coordinates: [latLng.lng, latLng.lat]
          }
        }];
      },


      /**
       * @function
       * @description Checks whether asset is already in the assets container
       * @params {array} list of assets
       * @params {number} id of asset that you want to append
       */
      _isUniqueAssetId: function (assets, assetId) {
        // dedupe the shiz
        var unique = true;
        assets.filter(function (item, index) {
          if (item === assetId) {
            unique = false;
            return item;
          }
        });
        return unique;
      },

      _addAssetOrGeomFromUtfOnState: function (latLng) {

        DataService.utfLayerGroup.getData('dataService', {'geom': latLng})
        .then(null, null, function (response) {

          var data = response.data;
          if (data) {
            // Create one entry in selected.assets.
            var assetId = data.entity_name + '$' + data.id;
            if (service._isUniqueAssetId(State.selected.assets, assetId)) {
              State.selected.assets.addAsset(assetId);
            }
          }

          else {
            service._addGeomFromUtfToState(latLng);
          }
        });
      },

      _addGeomFromUtfToState: function (latLng) {
        // Create one entry in selected.geometries.
        State.selected.geometries.addGeometry({
          geometry: {
            type: 'Point',
            coordinates: [latLng.lng, latLng.lat]
          }
        });
      },

      /**
       * Callback for the map when clicked.
       * @param  {[type]} latLng [description]
       * @return {[type]}        [description]
       */
      spatialSelect: function (latLng) {
        var utfSlug;
        if (DataService.utfLayerGroup){
          utfSlug = DataService.utfLayerGroup.slug;
        }
        if (State.box.type === 'point') {
          if (State.layerGroups.active.indexOf(utfSlug) !== -1) {
            this._setAssetOrGeomFromUtfOnState(latLng);
          }
          else {
            this._setGeomFromUtfToState(latLng);
          }
        }

        else if (State.box.type === 'multi-point') {
          if (State.layerGroups.active.indexOf(utfSlug) !== -1) {
            service._addAssetOrGeomFromUtfOnState(latLng);
          }
          else {
            this._addGeomFromUtfToState(latLng);
          }
        }
        else if (State.box.type === 'line') {
          if (this.line.geometry.coordinates.length === 2
            || State.selected.geometries.length > 0) {
            State.selected.geometries = [];
            this.line.geometry.coordinates = [];
          }
          if (this.line.geometry.coordinates.length < 2) {
            this.line.geometry.coordinates.push([latLng.lng, latLng.lat]);
          }
          if (this.line.geometry.coordinates.length === 2) {
            State.selected.geometries.addGeometry(this.line);
          }
        }
      },

      getRegions: function () {

        /**
         * Callback for clicks on regions. Calls fillRegion.
         *
         * @param  {object} leaflet ILayer that recieved the click.
         */
        var clickCb = function (layer) {
          for (var key in layer.feature.properties) {
            var newkey = key === 'type' ? 'regionType' : key;
            layer.feature[newkey] = layer.feature.properties[key];
          }
          layer.feature.properties = {};
          State.selected.geometries = [layer.feature];
        };

       CabinetService.regions.get({
          z: State.spatial.view.zoom,
          in_bbox: State.spatial.bounds.getWest()
            + ','
            + State.spatial.bounds.getNorth()
            + ','
            + State.spatial.bounds.getEast()
            + ','
            + State.spatial.bounds.getSouth()
        })
        .then(function (regions) {
          NxtRegionsLayer.add(service, regions.results, clickCb);
        });
      },

      removeRegions: function () {
        NxtRegionsLayer.remove(this);
      },

      /**
       * @function
       * @memberOf map.MapService
       * @description Initiate map events
       * @return {void}
       */
      _initializeNxtMapEvents: function (cbs) {
        var map = service._map;
        var conditionalApply = function (fn, e) {
          if (!$rootScope.$$phase) {
            $rootScope.$apply(fn(e, map));
          } else {
            fn(e, map);
          }
        };

        map.on('click',     function (e) { conditionalApply(cbs.onClick, e); });
        map.on('movestart', function (e) { conditionalApply(cbs.onMoveStart, e); });
        map.on('mousemove', function (e) { conditionalApply(cbs.onMouseMove, e); });
        map.on('moveend',   function (e) { conditionalApply(cbs.onMoveEnd, e); });
      },

      /**
       * @function
       * @memberOf map.MapService
       * @param  {object} Leaflet map
       * @param  {object} Leaflet layer
       * @description Removes layer from map
       */
      addLeafletLayer: function (leafletLayer) {
        if (service._map.hasLayer(leafletLayer)) {
          throw new Error(
            'Attempted to add layer' + leafletLayer._id
            + 'while it was already part of the map'
          );
        } else {
          service._map.addLayer(leafletLayer);
        }
      },

      /**
       * @function
       * @memberOf map.MapService
       * @param  {object} Leaflet map
       * @param  {object} Leaflet layer
       * @description Removes layer from map
       */
      removeLeafletLayer: function (leafletLayer) { // Leaflet NxtLayer
        if (service._map.hasLayer(leafletLayer)) {
          service._map.removeLayer(leafletLayer);
        }
      },


      _toggleLayers: function (lg) {
        if (lg.isActive() && lg.mapLayers.length > 0) {
          service.syncTime(State.temporal);
          addLayersRecursively(service._map, lg.mapLayers, 0);
        }
        else {
          angular.forEach(lg.mapLayers, function (layer) {
            if (layer._leafletLayer) {
              layer._leafletLayer.off('load');
              layer._leafletLayer.off('loading');
            }
            layer.remove(service._map);
          });
        }
        if (lg.getOpacity()) {
          angular.forEach(lg.mapLayers, function (layer) {
            layer.setOpacity(lg.getOpacity());
          });
        }
      },

      /**
       * @memberOf map.MapService
       * @param {object} layer passed
       * @description determine if raster layer can be rescaled
       */
      _rescaleContinuousData: function (lg) {
        var bounds = service._map.getBounds();
        angular.forEach(lg.mapLayers, function (layer) {
          layer.rescale(bounds);
        });
      },


      /**
       * @function
       * @memberOf map.MapService
       * @param {float} new opacity value
       * @return {void}
       * @description Changes opacity in layers that have
       * an opacity to be set
       */
      _setOpacity: function (lg) {
        if (lg.isActive()) {
          angular.forEach(lg.mapLayers, function (layer) {
            layer.setOpacity(lg.getOpacity());
          });
        }
      },

      zoomIn: function () {
        service._map.setZoom(service._map.getZoom() + 1);
      },

      zoomOut: function () {
        service._map.setZoom(service._map.getZoom() - 1);
      },

      /**
       * Initializes map layers for every layergroup.mapLayers.
       * @param  {object} timeState used to set an initial time on layers
       */
      initializeLayers: function (timeState) {
        angular.forEach(DataService.layerGroups, function (lg, lgSlug) {
          this.initializeLayer(lg);
        }, this);
      },

      initializeLayer: function (lg) {
        sortLayers(lg.mapLayers);
        angular.forEach(lg.mapLayers, function (layer, lSlug) {
          if (layer.tiled) {
            layer._leafletLayer = initializers[layer.format](layer);
            angular.extend(layer, NxtMapLayer);
          } else if (layer.format === 'WMS') {
            if (!layer.bounds) { layer.bounds = lg.spatialBounds; }
            layer = NxtNonTiledWMSLayer.create(layer);
          }
        });
      },

      getLeafletLayer: function (id) {
        return service._map._layers[id];
      }

    };



    /**
     * @function
     * @memberOf map.MapService
     * @param  {array} Array of nxt layers
     * @return {array} Array of object sorted by property loadOrder in
     *                 descending order.
     * @description Sorts layers by descending loadOrder
     */
    var sortLayers = function (layers) {
      layers.sort(function (a, b) {
        if (a.loadOrder > b.loadOrder) {
          return -1;
        }
        if (a.loadOrder < b.loadOrder
          || a.loadOrder === null) {
          return 1;
        }
        // a must be equal to b
        return 0;
      });
      return layers;
    };

    /**
     * @function
     * @memberOf map.MapService
     * @param  {object} map Leaflet map to add layers to
     * @param  {array} Array of nxt layers
     * @param  {int} i index to start from
     * @description Adds the layers with the loadorder of layers[i]. Catches
     *              the returned promises and calls itself with the nxt index.
     *              When all layers are loaded it adds a listener to the last
     *              layer with the highest loadOrder.
     */
    var addLayersRecursively = function (map, layers, i) {
      var currentLoadOrder = layers[i].loadOrder;
      // Wrap contains the promises and the nxt index.
      var wrap = loadLayersByLoadOrder(map, layers, i, currentLoadOrder);
      // If there is more, wait for these layers to resolve
      // and start over with the remaining layers.
      if (wrap.i < layers.length) {
        startOverWhenDone(wrap.promises, map, layers, wrap.i);
      }
      // When done, add listener to the last layer with the max loadOrder
      // that is drawn on the map.
      else if (layers.length > 1) {
        var index = getIndexOfLeadingLayer(layers);
        if (typeof(index) === 'number') {
          addLoadListenersToLayer(map, layers, index);
        }
      }
    };


    /**
     * @function
     * @memberOf map.MapService
     * @param  {object} map Leaflet map to add layers to.
     * @param  {array} layers Array of nxt layers.
     * @param  {int} i index to start from.
     * @param  {int} loadOrder Current load order to add layers.
     * @return {object} next index and list of promises that resolve when layer
     *                       is fully loaded.
     * @description Adds the layers from index i with the given loadorder to the
     *              map. Returns the current index and a list of promises for
     *              all the added layers when a layer with a lower loadorder is
     *              found.
     */
    var loadLayersByLoadOrder = function (map, layers, i, loadOrder) {
      // Add all layers with the current load order
      var promises = [];
      while (i < layers.length
        && layers[i].loadOrder === loadOrder) {
        promises.push(layers[i].add(map));
        i++;
      }
      return {
        i: i,
        promises: promises
      };
    };

    /**
     * @function
     * @memberOf map.MapService
     * @param  {array} layers Array of nxt layers.
     * @return {int} Index of the last layer with the highest loadOrder.
     * @description Loops through the sorted layers and returns the index of the
     *              last layer in the array with the highest loadOrder.
     */
    var getIndexOfLeadingLayer = function (layers) {
      var index;
      var highestLoadingOrder = 0;
      for (var i = 0; i < layers.length; i++) {
        if (layers[i].tiled
          && (layers[i].loadOrder > highestLoadingOrder
          || layers[i].loadOrder === highestLoadingOrder)) {
          index = i;
          highestLoadingOrder = index;
        }
      }
      return index;
    };

    /**
     * @function
     * @memberOf map.MapService
     * @param  {array} Array of promises.
     * @param  {object} map Leaflet map to add layers to.
     * @param  {array} layers Array of nxt layers.
     * @param  {int} i index to start from.
     * @description Takes a list of promises and calls addLayersRecursively when
     *              all promises have resolved.
     */
    var startOverWhenDone = function (promises, map, layers, i) {
      $q.all(promises).then(function () {
        addLayersRecursively(map, layers, i);
      });
    };

    /**
     * @function
     * @memberOf map.MapService
     * @param  {object} map Leaflet map to add layers to.
     * @param  {array} layers Array of nxt layers.
     * @param  {int} i index to start from.
     * @description Adds listeners that call when load starts and finished to
     *              the layer at index i of layers. Callbacks remove layers of
     *              the map after index i when load starts and adds layers after
     *              index i recursively when load finishes.
     */
    var addLoadListenersToLayer = function (map, layers, i) {
      var layer = layers[i];
      var j = i + 1;

      var removeAllAfterI = function () {
        for (j; j < layers.length; j++) {
          layers[j].remove(map);
        }
      };

      var reAdd = function () {
        addLayersRecursively(map, layers, i + 1);
      };

      layer._leafletLayer.off('load');
      layer._leafletLayer.off('loading');
      layer._leafletLayer.on('loading', removeAllAfterI);
      layer._leafletLayer.on('load', reAdd);
    };

    /**
     * @function
     * @memberOf map.MapService
     * @param  {dynamic} mapElem can be string or Element.
     * @param  {options} Options (bounds, attribution etc.)
     * @return {L.NxtMap}   Leaflet.NxtMap instance
     * @description Creates a Leaflet map based on idString or Element.
     */
    var createLeafletMap = function (mapElem, options) { // String or Element.

      var leafletMap = LeafletService.map(mapElem, options);

      return leafletMap;
    };

    /**
     * Initializers for every layer format
     */
    var initializers = {

      MAXZOOMLEVEL: 21,

      TMS: function (nonLeafLayer) {

        var layerUrl = nonLeafLayer.url + '/{slug}/{z}/{x}/{y}{retina}.{ext}';

        // Mapbox layers support retina tiles, our own do not yet. Check whether
        // tiles are from mapbox source.
        var retinaSupport = /tiles.mapbox/g.test(nonLeafLayer.url);

        var layer = LeafletService.tileLayer(
          layerUrl, {
            retina: retinaSupport && L.Browser.retina ? '@2x' : '',
            slug: nonLeafLayer.slug,
            minZoom: nonLeafLayer.minZoom || 0,
            maxZoom: nonLeafLayer.maxZoom || this.MAXZOOMLEVEL,
            detectRetina: retinaSupport,
            zIndex: nonLeafLayer.zIndex,
            ext: 'png'
          });

        return layer;
      },

      WMS: function (nonLeafLayer) {
        var _options = {
          layers: nonLeafLayer.slug,
          format: 'image/png',
          version: '1.1.1',
          minZoom: nonLeafLayer.minZoom || 0,
          maxZoom: nonLeafLayer.maxZoom || this.MAXZOOMLEVEL,
          crs: LeafletService.CRS.EPSG3857,
          opacity: nonLeafLayer.opacity,
          zIndex: nonLeafLayer.zIndex
        };
        _options = angular.extend(_options, nonLeafLayer.options);

        return LeafletService.tileLayer.wms(nonLeafLayer.url, _options);
      },

      UTFGrid: function (nonLeafLayer) {

        var url = nonLeafLayer.url + '/{slug}/{z}/{x}/{y}.{ext}';

        var layer = new LeafletService.UtfGrid(url, {
          ext: 'grid',
          slug: nonLeafLayer.slug,
          name: nonLeafLayer.slug,
          useJsonP: false,
          minZoom: nonLeafLayer.minZoom || 0,
          maxZoom: nonLeafLayer.maxZoom || this.MAXZOOMLEVEL,
          order: nonLeafLayer.zIndex,
          zIndex: nonLeafLayer.zIndex
        });
        return layer;
      },

      Vector: function (nonLeafLayer) {
        var options = {
          layer: nonLeafLayer,
          color: nonLeafLayer.color,
          showCoverageOnHover: false,  // When you mouse over a cluster it shows
                                       // the bounds of its markers.
          zoomToBoundsOnClick: true,   // When you click a cluster we zoom to
                                       // its bounds.
          spiderfyOnMaxZoom: false,    // When you click a cluster at the bottom
                                       // zoom level we  do not spiderfy it
                                       // so you can see all of its markers.
          maxClusterRadius: 80,        // The maximum radius that a cluster will
                                       // cover from the central marker
                                       // (in pixels). Default 80. Decreasing
                                       // will make more and smaller clusters.
                                       // Set to 1 for clustering only when
                                       // events are on the same spot.
          animateAddingMarkers: false, // Enable for cool animations but its
                                       // too slow for > 1000 events.
          iconCreateFunction: function (cluster) {
            var size = cluster.getAllChildMarkers().length,
                pxSize;

            if (size > 1024) {
              pxSize = 30;
            } else if (size > 256) {
              pxSize = 26;
            } else if (size > 64) {
              pxSize = 22;
            } else if (size > 32) {
              pxSize = 20;
            } else if (size > 16) {
              pxSize = 18;
            } else if (size > 8) {
              pxSize = 16;
            } else if (size > 4) {
              pxSize = 14;
            } else {
              pxSize = 12;
            }

            // Return two circles, an opaque big one with a smaller one on top
            // and white text in the middle. With radius = pxSize.
            return L.divIcon({
              iconAnchor: [pxSize, pxSize],
              html: '<svg height="' + (pxSize * 2) + '" width="' + (pxSize * 2)
                    + '">'
                    + '<circle cx="' + pxSize + '" cy="' + pxSize
                    + '" r="' + pxSize + '" fill-opacity="0.4" fill="'
                    + nonLeafLayer.color + '" />'
                    + '<circle cx="' + pxSize + '" cy="' + pxSize + '" r="'
                    + (pxSize - 2) + '" fill-opacity="1" fill="'
                    + nonLeafLayer.color + '" />'
                    + '<text x="' + pxSize + '" y="' + (pxSize + 5)
                    + '" style="text-anchor: middle; fill: white;">'
                    + size + '</text>'
                    + '</svg>'
            });
          },
          callbackClick: function (e, features) {
            service.spatialSelect(e.latlng);
          }
        };

        return new LeafletVectorService(options);
      }

    };

    return service;
  }]);

'use strict';

/**
 * Map directive
 *
 * Overview
 * ========
 *
 * Defines the map. Directive does all the watching and DOM binding, MapDirCtrl
 * holds all the testable logic. Ideally the directive has no logic and the
 * MapDirCtrl is independent of the rest of the application.
 *
 */
angular.module('map')
  .directive('map', [
  'MapService',
  'DataService',
  'ClickFeedbackService',
  'UtilService',
  'State',
  function (
    MapService,
    DataService,
    ClickFeedbackService,
    UtilService,
    State
  ) {

    var link = function (scope, element, attrs) {

      var mapSetsBounds = false,
          mapSetsView = false;

      /**
       * Init is called when directive is compiled and listeners are attached
       * Alligns state with map.
       */
      var init = function () {
        if (Object.keys(State.spatial.view).length !== 0) {
          mapSetsView = true;
          MapService.setView(State.spatial.view);
        }
        else if (Object.keys(State.spatial.bounds).length !== 0) {
          mapSetsBounds = true;
          MapService.fitBounds(State.spatial.bounds);
        }
      };

       /**
        * @function
        * @memberOf app.map
        * @description small clickhandler for leafletclicks
        * @param  {event}  e Leaflet event object
        */
      var _clicked = function (e) {
        if (State.box.type === 'point'
          || State.box.type === 'multi-point'
          || State.box.type === 'line') {
          MapService.spatialSelect(e.latlng);
        }
        if (State.box.type === 'line'
          && MapService.line.geometry.coordinates.length === 2) {
          ClickFeedbackService.emptyClickLayer(MapService);
          lineCleanup('click');
        }
      };

      /**
       * @function
       * @memberOf app.map
       */
      var _moveStarted = function (e) {
        State.spatial.mapMoving = true;
      };

      var circleAlongLine;
      var lineCleanup = function (origin) {
        if (circleAlongLine) {
          ClickFeedbackService.removeLeafletLayerWithId(MapService, circleAlongLine);
          circleAlongLine = undefined;
        }
        State.selected.mouseOnLine = null;
        if (origin !== 'click') {
          MapService.line.geometry.coordinates = [];
        }
      };

      var feedbackBulb = function (mouseHover) {
        if (!State.selected.geometries[0]) { return; }
        var coords = State.selected.geometries[0].geometry.coordinates;
        if (coords.length === 2) {
          var point = UtilService.pointAlongLine(
            mouseHover,
            L.latLng(coords[0][1],coords[0][0]),
            L.latLng(coords[1][1], coords[1][0])
          );
          if (circleAlongLine) {
            ClickFeedbackService.updateCircle(MapService, point, circleAlongLine);
            // fugly. sorry, not sorry.
            State.selected.mouseOnLine = L.latLng(
              coords[0][1],
              coords[0][0])
            .distanceTo(point);

          } else {
            circleAlongLine = ClickFeedbackService.drawCircle(MapService, point, true, 15);
          }
        }
      };

      /**
       * @function
       * @memberOf app.map
       */
      var _mouseMove = function (e) {
        if (State.box.type === 'line') {
          var coords = MapService.line.geometry.coordinates;
          if (coords.length === 0 && State.selected.geometries.length !== 0) {
            // Line is the first and only geometry.
            coords = State.selected.geometries[0].geometry.coordinates;
          }

          var start = (coords.length > 0) ? L.latLng(coords[0][1], coords[0][0]) : null;
          var end = e.latlng;

          if (coords.length === 1) {
            ClickFeedbackService.emptyClickLayer(MapService);
            ClickFeedbackService.drawLine(
              MapService,
              start,
              end
            );
          }
          feedbackBulb(e.latlng);
        } else {
          lineCleanup();
        }
      };

      /**
       * @function
       * @memberOf app.map
       */
      var _moveEnded = function (e, map) {
        State.spatial.mapMoving = false;
        // Moveended is fired on teardown of map and map.getBounds() returns a
        // bounds object of size zero. We want to keep the bounds.
        if (State.context === 'map') {
          mapSetsBounds = true;
          mapSetsView = true;
          State.spatial.bounds = map.getBounds();
          State.spatial.view = MapService.getView();
        }
      };

      MapService.initializeMap(element[0], {
          attributionControl: false,
          minZoom: 2,
          maxZoom: 21,
          zoomControl: false,
          addZoomTitles: true,
        }, {
          onClick: _clicked,
          onMoveStart: _moveStarted,
          onMoveEnd: _moveEnded,
          onMouseMove: _mouseMove
        }
      );

      /**
       * Watch state spatial view and update the whole shebang.
       */
      scope.$watch(State.toString('spatial.view'), function (n, o) {
        if (n !== o && !mapSetsBounds) {
          MapService.setView(State.spatial.view);
          State.spatial.bounds = MapService.getBounds();
        } else {
          mapSetsView = false;
        }
      });

      /**
       * Watch bounds of state and update map bounds when state is changed.
       */
      scope.$watch(State.toString('spatial.bounds'), function (n, o) {
        if (n !== o && !mapSetsBounds) {
          MapService.fitBounds(State.spatial.bounds);
          State.spatial.view = MapService.getView();
        } else {
          mapSetsBounds = false;
        }
        if (State.box.type === 'area') {
          var b = State.spatial.bounds;
          State.selected.geometries = [];
          State.selected.geometries.addGeometry(L.rectangle(b).toGeoJSON());
        }
        else if (State.box.type === 'region') {
          MapService.getRegions(State.spatial.bounds);
        }
      });

      /**
       * Watch temporal.at of app and update maplayers accordingly.
       *
       * Used for animation and clicks on timeline or changes from url-ctrl.
       */
      scope.$watch(State.toString('temporal.at'), function (n, o) {
        if (n === o) { return; }
        MapService.syncTime(State.temporal);
      });

      /**
       * Watch timelineMoving to update maplayers to new time domain when.
       *
       * Used for drag of timeline or changes from url-ctrl.
       */
      scope.$watch(State.toString('temporal.timelineMoving'), function (n, o) {
        if (n === o) { return; }
        MapService.syncTime(State.temporal);
      });

      /**
       * Watch timelineMoving to maplayers to time domain.
       *
       * Used to turn maplayers to a none animating state. When animation stops.
       */
      scope.$watch(function () { return State.temporal.playing; }, function (newValue) {
        if (newValue) { return; }
        MapService.syncTime(State.temporal);
      });

      scope.$watch(State.toString('selected.geometries'), function (n, o) {
        if (n === o) { return true; }
        if (State.box.type === 'line' && State.selected.geometries[0] === undefined) {
          lineCleanup();
        }
      });

      scope.$watch(State.toString('box.type'), function (n, o) {
        if (n === o) { return true; }

        if (n !== 'line' && o === 'line') {
          lineCleanup();
          ClickFeedbackService.emptyClickLayer(MapService);
        }

        var selector;
        switch (n) {
        case "point":
          selector = "";
          MapService.removeRegions();
          break;
        case "multi-point":
          selector = "";
          MapService.removeRegions();
          break;
        case "line":
          selector = "#map * {cursor: crosshair;}";
          MapService.removeRegions();
          break;
        case "region":
          selector = "";
          MapService.getRegions(State.spatial.bounds);
          break;
        case "area":
          selector = "#map * {cursor: -webkit-grab; cursor: -moz-grab; cursor: grab; cursor: hand;}";
          MapService.removeRegions();
          State.selected.geometries = [];
          var b = State.spatial.bounds;
          State.selected.geometries.addGeometry(L.rectangle(b).toGeoJSON());
          break;
        default:
          return;
        }
        UtilService.addNewStyle(selector);


      });

      init();

      // Remove all references to current map.
      element.on('$destroy', function () {
        MapService.remove();
        ClickFeedbackService.remove();
      });


    };

    return {
      restrict: 'E',
      replace: true,
      template: '<div id="map" class="map"></div>',
      link: link
    };
  }
]);

angular.module('timeseries', [
]);

/**
 * Service to handle timeseries retrieval.
 */
angular.module('timeseries')
.service("TimeseriesService", [
  '$q',
  'State',
  '$http',
  'notie',
  'UtilService',
  'DataService',
  'WantedAttributes',
  function ($q, State, $http, notie, UtilService, DataService, WantedAttributes) {

    var GRAPH_WIDTH = 320; // Width of drawing area of box graphs.

    // Contains timeseries metadata and data as comes from api. It mirrors
    // State.seletected.timeseries.
    this.timeseries = [];

    this.minPoints = GRAPH_WIDTH; // default

    var service = this;

    var _timeseries = [];
    Object.defineProperty(State.selected, 'timeseries', {
      get: function () { return _timeseries; },
      set: function (timeseries) {
        console.log('State.selected.timeseries:', timeseries);
        _timeseries = timeseries;
        service.syncTime(timeseries);
      },
      enumerable: true
    });

    this.syncTime = function (timeseries) {
      var promise = {};

      var actives = State.selected.timeseries.map(function (ts) {
        return ts.active && ts.uuid;
      });

      // Return empty timeseries when empty selection
      if (actives.length === 0) {
        var defer = $q.defer();
        defer.resolve([]);
        promise = defer.promise;
      }

      else {
        promise = this._getTimeseries(
          actives,
          State.temporal,
          service.minPoints
        );
      }

      promise.then(function (ts) {
        service.timeseries = ts;
        console.log('TimeseriesService.timeseries:', service.timeseries);
      })


      .then(function (results) {
        // Called asynchronously, so check if timeseries is still in state and
        // active.
        return _.filter(
          results,
          function (ts) { return _.some(
            State.selected.timeseries,
            function (stateTs) {
              return ts.uuid === stateTs.uuid && stateTs.active;
            });
          });

      })

      .then(function (ts) {

        if (service.onTimeseriesChange) {
          service.onTimeseriesChange();
        }
        // accomadate chaining;
        return ts;

      });
      return promise;
    };

    var localPromise = {};

    /**
     * Color is stored with the ts metadata in asset.timeseries of every asset
     * in DataService.assets. This function searches in the selected timeseries
     * in timeseriesService.timeseries to update the color.
     *
     * @param  {object} changedTS timeseries metadata object
     */
    this.onColorChange = function (changedTS) {
      var ts = _.find(service.timeseries, function (o) {
        return o.id === changedTS.uuid;
      });
      if (ts) {
        ts.color = changedTS.color;
        service.onTimeseriesChange();
      }
    };



    /**
     * @function
     * @memberOf timeseries.TimeseriesService
     * @description gets timeseries from service
     *
     * @param {str} objectID asset identifyer. <entityname>$<id>
     * @param {int} start get timeserie data from in epoch ms
     * @param {int} end get timeserie data till in epoch ms
     * @param {int} minPoints mutual exlcusive with aggWindow, for lines, ask
     *                        for minimally the graphs width amount of pixels.
     * @param {int} aggWindow mutual exclusive with minPoints, for barcharts,
     *                        as for timestate.aggWindow so timeseries are
     *                        aggregated to a sensible size.
     *
     */
    this._getTimeseries = function (uuids, timeState, minPoints) {
      // Cancel consecutive calls.
      if (localPromise.reject) {
        localPromise.resolve({data: {results: []}});
      }

      localPromise = $q.defer();

      var id = uuids.join(',');
      var params = {
        uuid: id,
        start: timeState.start ? parseInt(timeState.start, 10): undefined,
        end: timeState.end ? parseInt(timeState.end, 10): undefined,
      };

      if (minPoints) {
        params.min_points = minPoints;
      } else {
        params.window = timeState.aggWindow;
      }

      return $http({
        url: 'api/v2/timeseries/',
        method: 'GET',
        params: params,
        timeout: localPromise.promise
      })

      .then(function (response) {
        return response.data.results;
      }, errorFn)

      .then(filterTimeseries, errorFn)
      .then(formatTimeseriesForGraph, null);
    };

    var errorFn = function (err) {
      if (err.status === 420 || err.status === -1) {
        // Cancel normal operations
        return $q.reject(err);
      }
      else if (err.status >= 500 && err.status < 600) {
        notie.alert(3, 'Lizard encountered a problem retrieving your timeseries.', 3);
        // Cancel normal operations
        return $q.reject(err);
      }
      window.Raven.captureException(err);
      return err; // continue anyway
    };

    this.initializeTimeseriesOfAsset = function (asset) {
      var colors = UtilService.GRAPH_COLORS;
      State.selected.timeseries = _.unionBy(
        State.selected.timeseries,
        asset.timeseries.map(function (ts, i) {
          return {
            uuid: ts.uuid,
            active: false,
            order: 0,
            color: colors[i % (colors.length - 1)]
          };
        }),
        'uuid'
      );
      return asset;
    };

    /**
     * Looks up timeseries in State.selected.timeseries and copies color and order.
     * TimeseriesService.timeseries are not persistent when toggled.
     * asset.timeseries is persistent till a user removes it from selection.
     *
     * @param {object} graphTimeseries timeseriesSerivce.timeseries timeseries
     *                                 object.
     */
    var addColorAndOrderAndUnitAndTresholds = function (graphTimeseries) {
      var EMPTY = '...';
      var ts; // initialize undefined and set when found.
      var assetOfTs;

      _.forEach(DataService.assets, function (asset) {
        ts = _.find(asset.timeseries, { 'uuid': graphTimeseries.id });
        assetOfTs = asset;
        return ts === undefined; // Break out early
      });

      if (ts) {
        graphTimeseries.parameter = ts.parameter || EMPTY;
        graphTimeseries.unit = ts.unit || EMPTY;
        graphTimeseries.location = ts.location || EMPTY;
        if (ts.reference_frame) {
          graphTimeseries.unit += ' (' + ts.reference_frame + ')';
        }
        graphTimeseries.thresholds = [];
      }

      if (assetOfTs) {
        var threshold = {value: null, name: ''};
        _.forEach(
          WantedAttributes[assetOfTs.entity_name].rows,
          function (attr) {
            if (attr.valueSuffix === ' (' + graphTimeseries.unit + ')') {
              var value = parseFloat(assetOfTs[attr.attrName]);
              if (!isNaN(value)) {

                var name = assetOfTs.name === '' ? '...' : assetOfTs.name;

                threshold = {
                  value: value,
                  name: name + ': ' + attr.keyName
                };
                graphTimeseries.thresholds.push(threshold);
              }
            }
          }
        );
      }

      var tsState = _.find(
        State.selected.timeseries,
        { 'uuid': graphTimeseries.id }
      );

      // In db with crosssections it is possible to not have state of a ts.
      if (tsState) {
        graphTimeseries.color = tsState.color;
        graphTimeseries.order = tsState.order;
      }

      return graphTimeseries;
    };

    var formatTimeseriesForGraph = function (timeseries) {

      var graphTimeseriesTemplate = {
        id: '', //uuid
        data: [],
        unit: '',
        color: '', // Defined on asset.timeseries
        order: '', // Defined on asset.timeseries
        valueType: '',
        labels: {
          x: '',
          y: ''
        },
        keys: { x: 'timestamp', y: { y0: 'min', y1: 'max' } }
      };

      var result = [];
      timeseries.forEach(function (ts) {
        var graphTimeseries = angular.copy(graphTimeseriesTemplate);
        graphTimeseries.data = ts.events;
        graphTimeseries.id = ts.uuid;
        graphTimeseries.valueType = ts.value_type;
        graphTimeseries = addColorAndOrderAndUnitAndTresholds(graphTimeseries);
        result.push(graphTimeseries);
      });
      return result;

    };

    var filterTimeseries = function (results) {

      // maximum number of timeseries events, more probably results in a
      // memory error.
      var MAX_NR_TIMESERIES_EVENTS = 25000;

      var filteredResult = [];

      angular.forEach(results, function (ts) {
        var msg = '';
        if (ts.events === null) {
          filteredResult.push(ts);
        } else if (ts.events.length < MAX_NR_TIMESERIES_EVENTS) {

          if (ts.parameter_referenced_unit === null) {
            ts.parameter_referenced_unit = {};
          }

          filteredResult.push(ts);

        // Else: output a message to the console and an error to sentry.
        } else if (ts.events.length > MAX_NR_TIMESERIES_EVENTS) {
          msg = 'Timeseries: '
            + ts.uuid
            + ' has: '
            + ts.events.length
            + ' events, while '
            + MAX_NR_TIMESERIES_EVENTS
            + ' is the maximum supported amount';
          window.Raven.captureException(new Error(msg));
          console.info(msg);
        }
      });

      return filteredResult;
    };

  }

]);

'use strict';
/**
 * Timeseries directive.
 */
angular.module('timeseries')
.directive('timeseries', ['TimeseriesService', 'State',
  function (TimeseriesService, State) {
  return {
    link: function (scope) {

      scope.$watch('asset', function () {
        TimeseriesService.initializeTimeseriesOfAsset(scope.asset);

        if (State.context === 'map') {
          scope.timeseries.change();
        }

      });


      scope.$on('$destroy', function () {

        if (State.selected.assets.length > 1 && State.context === 'map') {
          _.forEach(State.selected.timeseries, function (ts) {
            ts.active = false;
          });
          TimeseriesService.syncTime();
        }

      });

    },
    restrict: 'E', // Timeseries can be an element with single-select or
                    // multi select as an attribute or without in which
                    // case it only sets the color and order of timeseries of
                    // new assets.
    scope: true // Share scope with select directive
  };
}]);

/**
 * Timeseries directive.
 */
angular.module('timeseries')
.config([ // stop the sanitation -- > SO: http://stackoverflow.com/questions/15606751/angular-changes-urls-to-unsafe-in-extension-page
  '$compileProvider',
  function($compileProvider) {
    $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|http):/);
  }])


.directive('timeseriesSingleSelect', ['State', 'TimeseriesService',
  function (State, TimeseriesService) {
  return {
    link: function (scope) {

      var selectTimeseries = function () {
        var selectedTimeseries = scope.timeseries.selected.uuid;

        scope.timeseries.selected.url = window.location.protocol + '//'
            + window.location.host + '/api/v2/timeseries/' + selectedTimeseries
            + '/data/?format=csv&start=' + Math.round(scope.timeState.start)
            + '&end=' + Math.round(scope.timeState.end);

        State.selected.timeseries.forEach(function (ts) {
          if (_.find(scope.asset.timeseries, {uuid: ts.uuid})) {
            ts.active = ts.uuid === selectedTimeseries;
          }
        });

        TimeseriesService.syncTime().then(getContentForAsset);

      };


      var getContentForAsset = function (timeseries) {
        scope.content = timeseries.filter(function (ts) {
          return _.some(scope.asset.timeseries, {uuid: ts.id});
        });
      };

      scope.timeseries = {
        selected: {uuid: 'empty'},
        change: function () {
          selectTimeseries();
        }
      };


      scope.$watch('asset', function () {

        var setFirstTSAsSelected = function () {
          scope.timeseries.selected = scope.asset.timeseries[0];
        };

        var activeTs = _.find(State.selected.timeseries, {active: true});
        if (activeTs) {
           var tsInAsset = _.find(
            scope.asset.timeseries,
            function (ts) { return ts.uuid === activeTs.uuid;}
          );
          if (tsInAsset) {
            scope.timeseries.selected = tsInAsset;
          }
          else {
            setFirstTSAsSelected();
          }
        }
        else {
          setFirstTSAsSelected();
        }

        scope.timeseries.change();

      });

      /**
       * Get new ts when time changes
       */
      scope.$watch('timeState.timelineMoving', function (newValue, oldValue) {
        if (!newValue && newValue !== oldValue) {
          TimeseriesService.syncTime().then(getContentForAsset);
        }
      });

    },
    restrict: 'A',
    templateUrl: 'timeseries/timeseries.html',
    scope: true // Share scope with timeseries directive
  };
}]);

angular.module('image-carousel', [
]);

'use strict';
/**
 * Timeseries directive.
 */
angular.module('image-carousel')
  .directive('imageCarousel', ['State', 'UtilService','$timeout',
    function (State, UtilService, $timeout) {
  return {
      link: function (scope, element) {

        if (scope.context === 'map') {
          scope.dimensions = {
            maxWidth: '370px',
            maxHeight: '400px'
          };
        }
        else if (scope.context === 'dashboard') {
          scope.$watch('graphDims', function () {
            var d = scope.graphDims;
            scope.dimensions = {
              'max-width': d.width,
              'max-height': d.height
            };
            scope.itemDimensions = {
              width: d.width,
              height: d.height
            };
          });
        }

        /**
         * Replace dataset lazyloadsrc with the real src to trigger browser to
         * load image.
         * @param  {DOM element} el img
         */
        var loadImage = function (el) {
          var src = el.dataset.lazyLoadSrc;
          el.src = src;
        };

        var tempChanged;
        var carouselChanged;
        var canceler;

        /**
         * Prevents slide carousel from being triggered and sets the right
         * image to active after the first digest renders the whole ng-repeat
         * tree.
         */
        var setImagesToTimeAfterDigest = function () {
          if (carouselChanged) {
            carouselChanged = false;
          }
          else {
            tempChanged = true;
            var i = UtilService.bisect(
              scope.images,
              'timestamp',
              scope.temporal.at
            );

            canceler = $timeout(function () {
              var activeElement = element
                .find('.carousel-inner')
                .children()[i];
              if (activeElement) {
                var activeImg = activeElement.children[0];
                // First shift carousel, then start loading the image. The
                // browser might already have the image, and we should not show
                // two at the same time.
                element.carousel(i);
                loadImage(activeImg);
              }
            }, 0, false);
          }
        };

        scope.slide = function (direction) {
          if (scope.images.length) {
            element.carousel(direction);
          }
        };

        /**
         * On sliding through carousel, set time
         */
        element.on('slide.bs.carousel', function (event) {
          if (tempChanged) {
            tempChanged = false;
          }
          else {
            carouselChanged = true;
            loadImage(event.relatedTarget.children[0]);
            var timestamp = event.relatedTarget.children[0].dataset.timestamp;
            State.temporal.at = Number(timestamp);
          }
        });

        scope.$watch('temporal.at', function (n, o) {
          if (n === o) { return; }
          if (canceler) { $timeout.cancel(canceler); }
          setImagesToTimeAfterDigest();
        });

        scope.$watchCollection('images', function (images) {
          if (canceler) { $timeout.cancel(canceler); }
          element.find('.item').removeClass('active');
          if (images.length) {
            setImagesToTimeAfterDigest();
          }
        });

        scope.$on('destroy', function () {
          if (canceler) { $timeout.cancel(canceler); }
        });

      },
      restrict: 'E',
      scope: {
        context: '@', // bind to string attribute
        height: '=',
        temporal: '=',
        images: '=', // timeseries like images: {
                     //   url: <string>,
                     //   timestamp: <epoch>
                     // },
        graphDims: '=dimensions'
      },
      templateUrl: 'image-carousel/image-carousel.html',
      replace: true
    };
}]);

/**
 * @module
 * @description Annotations module shows an assets annotations and adds support
 *              for adding annotations to an asset.
 */
angular.module('annotations', ['ngResource']);

/**
 * Service to handle annotations retrieval and creation.
 */
angular.module('annotations')
  .service("AnnotationsService", ['$resource', 'State',
    function ($resource, State) {

      /**
       * Date formatter that formats the date based on the timeline window.
       */
      this.formatDatetime = function () {
        var range = State.temporal.end - State.temporal.start;
        if (range > 31536000000) {  // more than a year
          return "d MMM ''''yy";
        } else if (range > 86400000) {  // more than a day
          return "d MMM";
        } else {  // less than a day
          return "H:mm:ss";
        }
      };

      /* Create a resource for interacting with the annotations endpoint of the
       * API.
       *
       * Use a reconfigured 'query' so it actually returns an array of items.
       * Use a reconfigured 'save' to be able to send an attachment file using
       * 'multipart/form-data' content-type headers.
       */
      var Annotations = $resource('/api/v2/annotations/:id/', {}, {
        'query': {
          method:'GET',
          isArray:true,
          transformResponse:
            function (data, headers) {
              return angular.fromJson(data).results;
            }
        },
        'save': {
          method: 'POST',
          transformRequest: angular.identity,
          headers: { 'Content-Type': undefined }
        }
      });

      /* Create a resource for interacting with the organisations endpoint of
       * the API.
       *
       * Use a reconfigured 'query' so it actually returns an array of items.
       */
      var Organisations = $resource('/api/v2/organisations/:uuid/', {}, {
        'query': {
          method:'GET',
          isArray:true,
          transformResponse:
            function (data, headers) {
              return angular.fromJson(data).results;
            }
        }
      });

      /**
       * Get all organisations of a user.
       * @param {function} success - Execute this function on a successful GET.
       * @param {function} error - Execute this function on a failed GET.
       */
      this.getOrganisations = function(success, error) {
        return Organisations.query({'page_size': 1000}, success, error);
      };

      /**
       * Get all annotations for an asset.
       * @param {string} model - The model name of the asset (e.g. manhole).
       * @param {integer} id - The ID of the asset.
       * @param {integer} limit - Limit the number of returned annotations.
       * @param {Date} start - Filter the annotations on a start-end date
       *                       range.
       * @param {Date} end - Filter the annotations on a start-end date range.
       * @param {function} success - Execute this function on a successful
       *                             GET.
       * @returns {array} - An array of annotations.
       */
      this.getAnnotationsForObject = function (
          model, id, limit, start, end, success) {
        return Annotations.query({
          object_type__model: model,
          object_id: id,
          limit: limit,
          start: start,
          end: end,
          ordering: '-timestamp_start'
        }, success);
      };

      /**
       * Remove an annotation from the API.
       * @param {object} annotation - The annotation to be deleted.
       * @param {function} success - Execute this function on a successful
       *                             DELETE.
       * @param {function} error - Execute this function when something goes
       *                           wrong with the DELETE.
       */
      this.deleteAnnotation = function (annotation, success, error) {
        return Annotations.delete({id: annotation.id}, success, error);
      };

      /**
       * Add a new annotation to the API.
       * @constructor
       * @param {object} asset - The asset to which the annotation is related.
       * @param {string} text - The actual annotation message.
       * @param {string} file - An optional attachment for the annotation.
       * @param {Date} timelineat - A date to use for timestamp_start and
       *                            timestamp_end.
       * @param {object} organisation - The organisation to which the
       *                                annotation is related.
       * @param {function} success - Execute this function on a successful
       *                             POST.
       * @param {function} error - Execute this function when something goes
       *                           wrong with the POST.
       * @returns {object} - The new annotation.
       */
      this.addAnnotationToObject = function (
          asset, text, file, timelineat, organisation, success, error) {

        var fd = new FormData();
        if (file) {
          fd.append('attachment', file);
        }
        if (asset.entity_name) {
          fd.append('object_type', asset.entity_name);
        }
        if (asset.id) {
          fd.append('object_id', asset.id);
        }
        fd.append('text', text);
        fd.append('timestamp', timelineat);
        fd.append('organisation', organisation.unique_id);
        fd.append('location', JSON.stringify(asset.geometry));

        return Annotations.save(fd, success, error);
      };


      /**
       * Refresh the annotationlayer if present. Event layer clear data when
       * turned off. So turn off and on.
       */
      this.refreshAnnotationLayer = function () {
        var ANNOTATION_LG_SLUG = 'annotations';
        var annotationLgIndex = State.layerGroups.active.indexOf(ANNOTATION_LG_SLUG);
        if (annotationLgIndex !== -1) {
          var oldLgs = angular.copy(State.layerGroups.active);
          var newLgs = State.layerGroups.active.filter(function (lgslug) {
            if (lgslug !== ANNOTATION_LG_SLUG) {
              return true;
            } else { return false ;}
          });

          State.layerGroups.active = newLgs;
          State.layerGroups.active = oldLgs;
        }
      };

      return this;
    }
  ]);

'use strict';
/**
 * @module
 * @description Annotations wrapper for viewing and making annotations.
 */
angular.module('annotations')
  .directive('annotations', [function () {
    var link = function (scope, element, attrs) {
      scope.annotations = [];
    };

    return {
      restrict: 'E',
      scope: {
        data: '=',
        timeState: '=',
      },
      link: link,
      templateUrl: 'annotations/templates/annotations.html'
    };
  }]);

/**
 * @module
 * @description Show asset annotations.
 */
angular.module('annotations')
  .directive('annotationsView',
             ['AnnotationsService', '$window', 'gettextCatalog', 'notie',
              function (AnnotationsService, $window, gettextCatalog, notie) {

    var link = function (scope, element, attrs) {

      /**
       * Provide a date time formatter for the annotations templates.
       */
      scope.formatDatetime = function() {
        return AnnotationsService.formatDatetime();
      };

      /**
       * Update front-end upon successful GET of the annotations.
       * @param {array} value - annotations returned by the request.
       * @param {dict} responseHeaders - Not actually used but required
       *                                       by $resource.
       */
      var fetchAnnotationsSuccess = function(value, responseHeaders) {
        scope.annotations = value;
      };

      /**
       * Get all annotations for an asset or geometry.
       * @returns {array} - An array of annotations.
       */
      var fetchAnnotations = function() {
        if (scope.data.properties && scope.data.properties.annotations) {
          var events = scope.data.properties.annotations.data;
          var annotations = scope.data.properties.annotations.data;
          fetchAnnotationsSuccess(annotations);
        }

        else if (scope.data && scope.data.entity_name && scope.data.id) {
          AnnotationsService.getAnnotationsForObject(
            scope.data.entity_name,
            scope.data.id,
            5,
            scope.timeState.start,
            scope.timeState.end,
            fetchAnnotationsSuccess
          );
        }

        else {
          scope.annotations = [];
        }

      };

      /**
       * Get annotations when asset changes.
       */
      scope.$watch('data', function () {
        fetchAnnotations();
      });

      /**
       * Update annotations when timeline has moved.
       */
      scope.$watch('timeState.timelineMoving', function (off) {
        if (!off) {
          fetchAnnotations();
        }
      });
      /**
       * Update the front-end to reflect a successful delete of an annotation.
       * Both on the map and timeline as in the box.
       * @param {object} id - The ID of the asset.
       * @param {?} value - Not actually used but required by $resource.
       * @param {dict} responseHeaders - Not actually used but required
       *                                       by $resource.
       */
      var deleteAnnotationSuccess = function(
          annotation, value, responseHeaders) {
        scope.annotations.splice(scope.annotations.indexOf(annotation), 1);
        AnnotationsService.refreshAnnotationLayer();
      };

      /**
       * Throw an alert and error when something went wrong with the deletion
       * of the annotation.
       * @param {dict} httpResponse - The httpResponse headers returned by the
       *                              DELETE.
       */
      var deleteAnnotationError = function(httpResponse) {
        console.log(httpResponse);
        notie.alert(3,
          gettextCatalog.getString(
            "Oops! Something went wrong while deleting the annotation."));
        throw new Error(
          httpResponse.status + " - "
          + "Could not delete previously retrieved annotation:"
          + " " + httpResponse.config.url
          + ".");
      };

      /**
       * Remove annotation from database when delete icon is clicked.
       * Update the front-end to reflect a successful delete or throw an alert
       * on error.
       * @param {object} annotation - The annotation to be deleted.
       */
      scope.deleteAnnotation = function (annotation) {
        AnnotationsService.deleteAnnotation(
          annotation,
          deleteAnnotationSuccess.bind(undefined, annotation),
          deleteAnnotationError);
      };
    };

    return {
      link: link,
      restrict: 'E',
      scope: {
        data: '=',
        annotations: '=',
        timeState: '='
      },
      templateUrl: 'annotations/templates/annotations-view.html'
    };
  }]);

/**
 * @module
 * @description Directive for a file field.
 */
angular.module('annotations')
.directive('fileModel', ['$parse', function ($parse) {

  var link = function(scope, element, attrs) {
    var model = $parse(attrs.fileModel);
    var modelSetter = model.assign;

    /**
     * Add the file to the scope after a change on the file input field
     * (someone selected a file on their system).
     */
    element.bind('change', function(){
      var file = element[0].files[0];
      scope.$apply(function(){
        modelSetter(scope, file);
        scope.annotationform.attachment.$setDirty();
      });
    });
  };

  return {
    restrict: 'A',
    link: link
  };
}]);

/**
 * @module
 * @description Max file size validation on file field.
 */
angular.module('annotations')
  .directive('maxFileSize', [function() {

    /**
     * Validate a file on its size with the max-file-size attribute on file
     * upload fields.
     * @param {string} scope - The scope.
     * @param {array} element - The input field HTML element.
     * @param {dict} attrs - The attributes on the input field.
     * @param {controller} ngModel - The Angular ngModel controller.
     */
    var link = function(scope, element, attrs, ngModel) {
      scope.$watch(attrs.fileModel, function() {
        var file = element[0].files[0];
        ngModel.$setValidity('maxFileSize',
                             !(file && file.size > attrs.maxFileSize));
      });
    };

    return {
      require: 'ngModel',
      link: link
    };
}]);
/**
 * @module
 * @description Create asset annotations.
 */
angular.module('annotations')
  .directive('annotationsMake',
             ['AnnotationsService', '$window', 'gettextCatalog', 'notie',
              'user',
              function (AnnotationsService, $window, gettextCatalog, notie,
                        user) {

    var link = function (scope, element, attrs) {

      scope.user = user;

      /**
       * Provide a date time formatter for the annotations templates.
       */
      scope.formatDatetime = function() {
        return AnnotationsService.formatDatetime();
      };

      /**
       * Reset (empty) the annotation form.
       * Otherwise if a user has once selected a file to upload and decides he
       * no longer wants an attachment he won't be able to remove the
       * attachment.
       */
      scope.resetForm = function() {
        scope.text = angular.copy(null);
        scope.attachment = angular.copy(null);
        angular.forEach(
          angular.element("input[type='file']"),
          function(inputElem) {
            angular.element(inputElem).val(null);
        });
        scope.annotationform.$setPristine();
      };

      /**
       * Update the front-end to reflect a successful creation of an
       * annotation.
       * @param {object} value - The newly created annotation.
       * @param {dict} responseHeaders - The response headers returned by POST.
       */
      var createAnnotationSuccess = function(value, responseHeaders){
        scope.annotations.splice(0, 0, value);
        AnnotationsService.refreshAnnotationLayer();
      };

      /**
       * Throw an alert and error when something went wrong with the creation
       * of the annotation.
       * @param {dict} httpResponse - The httpResponse headers returned by the
       *                              POST.
       */
      var createAnnotationError = function(httpResponse){
        notie.alert(3,
          gettextCatalog.getString(
            "Oops! Something went wrong while creating the annotation."));
        throw new Error(
          httpResponse.status + " - " + "Could not create annotation.");
      };

      /**
       * Create a new annotation on an asset.
       */
      scope.createAnnotation = function () {
        AnnotationsService.addAnnotationToObject(
          scope.data,
          scope.text,
          scope.attachment,
          scope.timelineat,
          scope.selectedOrganisation,
          createAnnotationSuccess,
          createAnnotationError
        );
      };

      /**
       * Update the scope to reflect a successful fetch of the user's
       * organisations.
       * @param {array} value - The organisations.
       * @param {dict} responseHeaders - The response headers returned by GET.
       */
      var getOrganisationsSuccess = function(value, responseHeaders) {
        user.organisations = value;
        scope.selectedOrganisation = user.organisations[0];
      };

      /**
       * Throw an alert and error when something went wrong with getting the
       * organisations.
       * @param {dict} httpResponse - The httpResponse headers returned by the
       *                              GET.
       */
      var getOrganisationsError = function(httpResponse) {
        notie.alert(3,
            gettextCatalog.getString(
              "Oops! Something went wrong while fetching your organisations.")
        );
        throw new Error(
          httpResponse.status + " - " + "Could not get organisations.");
      };

      /**
       *  Get the user's organisations if they haven't already been retrieved.
       */
      var getUserOrganisations = function () {
        if (!user.hasOwnProperty('organisations')) {
          AnnotationsService.getOrganisations(
            getOrganisationsSuccess, getOrganisationsError);
        } else {
          scope.selectedOrganisation = user.organisations[0];
        }
      };
      getUserOrganisations();
    };

    return {
      link: link,
      restrict: 'E',
      scope: {
        data: '=',
        annotations: '=',
        timelineat: '='
      },
      templateUrl: 'annotations/templates/annotations-make.html'
    };

  }]);

angular.module('omnibox', [
  'templates-main',
  'global-state',
  'data-menu',
  'map',
  'timeseries',
  'image-carousel'
]);

angular.module('omnibox')
.controller("OmniboxCtrl", ["DataService", "State", "$scope",
  function (DataService, State, $scope) {

    this.data = DataService;
    this.state = State;

    // Store explicit reference to context. To change context, reinstantiate
    // omnibox. This prevents errors when interacting with the map when the map
    // does not exist yet.
    this.context = State.context;

    /**
     * Adds a unique identifier to asset objects for keeping track of angular
     * scopes. Without this, the close-card-dir may remove the wrong asset.
     *
     * @param  {object} asset
     * @return {string}       asset id.
     */
    this.trackAssets = function (asset) {
      return asset.entity_name + '$' + asset.id;
    };

  }

]);

'use strict';

angular.module('omnibox')
.service("WantedAttributes", ["gettext", function (gettext) {

  this.pump = {
    rows: [
      {
        keyName: gettext("Capacity"),
        attrName: "capacity",
        ngBindValue:
          "asset.selectedAsset.capacity * 3.6 | niceNumberOrEllipsis: 2",
        valueSuffix: "  (m<sup>3</sup> / uur)",
        defaultValue: "12"
      },
      {
        /// Aanslagpeil
        keyName: gettext("Start level"),
        attrName: "start_level",
        ngBindValue:
          "asset.selectedAsset.start_level | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "-2.2"
      },
      {
        /// Afslagpeil
        keyName: gettext("Stop level"),
        attrName: "stop_level",
        ngBindValue:
          "asset.selectedAsset.stop_level | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "-2.8"
      }
    ]
  };

  this.bridge = {
    rows: [
      {
        keyName: gettext("Type"),
        attrName: "type",
        ngBindValue: "waterchain.type",
        valueSuffix: "",
        defaultValue: "Liggerbrug"
      },
      {
        keyName: gettext("Width"),
        attrName: "width",
        ngBindValue:
          "waterchain.width | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: 8
      },
      {
        keyName: gettext("Length"),
        attrName: "length",
        ngBindValue:
          "waterchain.length | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: 17
      },
      {
        keyName: gettext("Height"),
        attrName: "height",
        ngBindValue:
          "waterchain.height | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: 2
      }
    ]
  };

  this.channel_Boezem = {
    rows: [
      {
        keyName: gettext("Name"),
        attrName: "name",
        ngBindValue: "waterchain.name",
        valueSuffix: "",
        defaultValue: "Watergang"
      },
      {
        keyName: gettext("Type"),
        attrName: "type",
        ngBindValue:
          "waterchain.type",
        valueSuffix: "",
        defaultValue: "Boezem"
      }
    ]
  };

  this.crossprofile = {
    rows: [
      {
        keyName: gettext("Type"),
        attrName: "type",
        ngBindValue:
          "waterchain.type | niceNumberOrEllipsis: 2",
        valueSuffix: "",
        defaultValue: "Dwarsdoorsnede"
      }
    ]
  };

  this.culvert = {
    rows: [
      {
        keyName: gettext("Width"),
        attrName: "width",
        ngBindValue:
          "waterchain.width | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: "2"
      },
      {
        keyName: gettext("Length"),
        attrName: "length",
        ngBindValue:
          "waterchain.length | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: "8"
      },
      {
        keyName: gettext("Height"),
        attrName: "height",
        ngBindValue:
          "waterchain.height | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: "1.5"
      },
      {
        keyName: gettext("Material"),
        attrName: "material",
        ngBindValue:
          "waterchain.material | lookupCulvertMaterial",
        valueSuffix: "",
        defaultValue: "beton"
      },
      {
        keyName: gettext("Shape"),
        attrName: "shape",
        ngBindValue:
          "waterchain.shape | lookupCulvertShape",
        valueSuffix: "",
        defaultValue: "rechthoekig"
      }
    ]
  };

  this.filter = {
    rows: [
      {
        /// Bovenkant filter
        keyName: gettext("Filter top level"),
        attrName: "filter_top_level",
        ngBindValue: "asset.selectedAsset.filter_top_level | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: ""
      },
      {
        /// Onderkant filter
        keyName: gettext("Filter bottom level"),
        attrName: "filter_bottom_level",
        ngBindValue: "asset.selectedAsset.filter_bottom_level | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: ""
      },
      {
        keyName: gettext("Aquifer confinement"),
        attrName: "aquifer_confiment",
        ngBindValue: "asset.selectedAsset.aquifer_confiment",
        valueSuffix: " (m)",
        defaultValue: ""
      },
      {
        /// bodemsoort
        keyName: gettext("Litology"),
        attrName: "litology",
        ngBindValue: "asset.selectedAsset.litology",
        valueSuffix: " (m)",
        defaultValue: ""
      },

    ]
  };

  this.groundwaterstation = {
    rows: [
      {
        keyName: gettext("Name"),
        attrName: "name",
        ngBindValue: "waterchain.name",
        valueSuffix: "",
        defaultValue: ""
      },
      {
        keyName: gettext("Code"),
        attrName: "code",
        ngBindValue:
          "waterchain.code",
        valueSuffix: "",
        defaultValue: ""
      },
      {
        keyName: gettext("Surface level"),
        attrName: "surface_level",
        ngBindValue: "waterchain.surface_level",
        valueSuffix: " (m)",
        defaultValue: ""
      },
      {
        /// Bovenkant buis
        keyName: gettext("Top level"),
        attrName: "top_level",
        ngBindValue: "waterchain.top_level",
        valueSuffix: " (m)",
        defaultValue: ""
      },
      {
        /// Onderkan buis
        keyName: gettext("Bottom level"),
        attrName: "bottom_level",
        ngBindValue: "waterchain.bottom_level",
        valueSuffix: " (m)",
        defaultValue: ""
      }
    ]
  };

  this.levee = {
    rows: [
      {
        /// Kruinhoogte
        keyName: gettext("Crest height"),
        attrName: "crest_height",
        ngBindValue:
          "waterchain.crest_height | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "2"
      },
      {
        /// Bekleding
        keyName: gettext("Coating"),
        attrName: "coating",
        ngBindValue:
          "waterchain.coating",
        valueSuffix: "",
        defaultValue: "gras"
      },
      {
        keyName: gettext("Material"),
        attrName: "material",
        ngBindValue:
          "waterchain.material",
        valueSuffix: "",
        defaultValue: "zand"
      }
    ]
  };

  this.leveecrosssection = {
    rows: [
      {
        /// Naam
        keyName: gettext("Name"),
        attrName: "name",
        ngBindValue: "waterchain.name"
      }
    ]
  };

  this.leveereferencepoint = {
    rows: [
      {
        keyName: gettext("Type"),
        attrName: "type",
        ngBindValue:
          "waterchain.type",
        valueSuffix: "",
        defaultValue: "Referentiemeetpunt"
      }
    ]
  };

  this.manhole = {
    rows: [
      {
        keyName: gettext("Code"),
        attrName: "code",
        ngBindValue:
          "waterchain.code",
        valueSuffix: "",
        defaultValue: "0-7361"
      },
      {
        keyName: gettext("Surface level"),
        attrName: "surface_level",
        ngBindValue:
          "waterchain.surface_level | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "0.42"
      },
      {
        keyName: gettext("Material"),
        attrName: "material",
        ngBindValue:
          "waterchain.material",
        valueSuffix: "",
        defaultValue: "beton"
      },
      {
        keyName: gettext("Width"),
        attrName: "width",
        ngBindValue:
          "waterchain.width | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: "0.8"
      },
      {
        keyName: gettext("Shape"),
        attrName: "shape",
        ngBindValue:
          "waterchain.shape | lookupManholeShape",
        valueSuffix: "",
        defaultValue: "vierkant"
      },
      {
        /// Putbodem
        keyName: gettext("Bottom level manhole"),
        attrName: "bottom_level",
        ngBindValue:
          "waterchain.bottom_level | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "-1.6"
      }
    ],
  };

  this.measuringstation = {
    rows: [
      {
        keyName: gettext("Name"),
        attrName: "name",
        ngBindValue: "waterchain.name",
        valueSuffix: "",
        defaultValue: "KNMI"
      },
      {
        keyName: gettext("Category"),
        attrName: "category",
        ngBindValue: "waterchain.category",
        valueSuffix: "",
        defaultValue: "KNMI-AWS"
      },
      {
        keyName: gettext("Frequency"),
        attrName: "frequency",
        ngBindValue: "waterchain.frequency",
        valueSuffix: "",
        defaultValue: "1x per uur"
      },
      {
        keyName: gettext("Code"),
        attrName: "code",
        ngBindValue:
          "waterchain.code",
        valueSuffix: "",
        defaultValue: "6278"
      }
    ]
  };

  this.monitoringwell = {
    rows: [
      {
        keyName: gettext("Distance along cross section"),
        attrName: "distance_along_crosssection",
        ngBindValue:
          "waterchain.distance_along_crosssection | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: ""
      },
      {
        keyName: gettext("Well top level"),
        attrName: "well_top_level",
        ngBindValue: "waterchain.well_top_level",
        valueSuffix: "",
        defaultValue: ""
      },
      {
        keyName: gettext("Well bottom level"),
        attrName: "well_bottom_level",
        ngBindValue:
          "waterchain.well_bottom_level",
        valueSuffix: "",
        defaultValue: ""
      }
    ]
  };

  this.orifice = {
    rows: [
      {
        keyName: gettext("Code"),
        attrName: "code",
        ngBindValue:
          "waterchain.code",
        valueSuffix: "",
        defaultValue: "3105"
      },
      {
        /// Overstortbreedte
        keyName: gettext("Crest width"),
        attrName: "crest_width",
        ngBindValue:
          "waterchain.crest_width | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: "1"
      },
      {
        /// Overstorthoogte
        keyName: gettext("Crest level"),
        attrName: "crest_level",
        ngBindValue:
          "waterchain.crest_level | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "0.2"
      },
      {
        keyName: gettext("Shape"),
        attrName: "shape",
        ngBindValue:
          "waterchain.shape | truncate: 20",
        valueSuffix: "",
        defaultValue: "rechthoekig"
      }
    ]
  };

  this.outlet = {
    rows: [
      {
        keyName: gettext("Manhole id"),
        attrName: "manhole_id",
        ngBindValue:
          "waterchain.manhole_id | niceNumberOrEllipsis: 2",
        valueSuffix: "",
        defaultValue: "6-549"
      },
      {
        /// Buitenwaterstand (gemiddeld)
        keyName: gettext("Open water level (average)"),
        attrName: "open_water_level_average",
        ngBindValue:
          "waterchain.open_water_level_average | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "-0.1"
      }
    ]
  };

  this.overflow = {
    rows: [
      {
        keyName: gettext("Code"),
        attrName: "code",
        ngBindValue:
          "waterchain.code",
        valueSuffix: "",
        defaultValue: "12-72297"
      },
      {
        /// Overstortbreedte
        keyName: gettext("Crest width"),
        attrName: "crest_width",
        ngBindValue:
          "waterchain.crest_width",
        valueSuffix: " (m)",
        defaultValue: "1"
      },
      {
        /// Overstorthoogte
        keyName: gettext("Crest level"),
        attrName: "crest_level",
        ngBindValue:
          "waterchain.crest_level",
        valueSuffix: " (mNAP)",
        defaultValue: "0.2"
      }
    ]
  };

  this.pipe = {
    rows: [
      {
        keyName: gettext("Type"),
        attrName: "type",
        ngBindValue:
          "waterchain.type | lookupPipeType",
        valueSuffix: "",
        defaultValue: "gemengd stelsel"
      },
      {
        /// BOB beginpunt
        keyName: gettext("Invert level start point"),
        attrName: "invert_level_start_point",
        ngBindValue:
          "waterchain.invert_level_start_point | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "-3.1"
      },
      {
        /// BOB eindpunt
        keyName: gettext("Invert level end point"),
        attrName: "invert_level_end_point",
        ngBindValue:
          "waterchain.invert_level_end_point | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "-3.12"
      },
      {
        keyName: gettext("Length"),
        attrName: "length",
        ngBindValue:
          "waterchain.length | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: "28"
      },
      {
        keyName: gettext("Material"),
        attrName: "material",
        ngBindValue:
          "waterchain.material | pipeMaterialOrEllipsis",
        valueSuffix: "",
        defaultValue: "beton"
      },
      {
        keyName: gettext("Width"),
        attrName: "width",
        ngBindValue:
          "waterchain.width | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: "0.8"
      },
      {
        keyName: gettext("Shape"),
        attrName: "shape",
        ngBindValue:
          "waterchain.shape | lookupPipeShape",
        valueSuffix: "",
        defaultValue: "rond"
      },
      {
        keyName: gettext("Code"),
        attrName: "code",
        ngBindValue:
          "waterchain.code",
        valueSuffix: "",
        defaultValue: "0-985-0-986"
      }
    ]
  };

  this.pressurepipe = {
    rows: [
      {
        keyName: gettext("Name"),
        attrName: "name",
        ngBindValue: "waterchain.name",
        valueSuffix: "",
        defaultValue: "onbekend"
      },
      {
        keyName: gettext("Type"),
        attrName: "type",
        ngBindValue:
          "waterchain.type | lookupPressurePipeType",
        valueSuffix: "",
        defaultValue: "transportleiding"
      },
      {
        keyName: gettext("Construction year"),
        attrName: "year_of_construction",
        ngBindValue:
          "waterchain.year_of_construction",
        valueSuffix: "",
        defaultValue: "2006"
      },
      {
        keyName: gettext("Code"),
        attrName: "code",
        ngBindValue:
          "waterchain.code",
        valueSuffix: "",
        defaultValue: "776"
      },
      {
        keyName: gettext("Diameter"),
        attrName: "diameter",
        ngBindValue:
          "waterchain.diameter | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: "1.6"
      },
      {
        keyName: gettext("Shape"),
        attrName: "shape",
        ngBindValue:
          "waterchain.shape",
        valueSuffix: "",
        defaultValue: "rond"
      },
      {
        keyName: gettext("Length"),
        attrName: "length",
        ngBindValue:
          "waterchain.length",
        valueSuffix: " (m)",
        defaultValue: "154"
      },
      {
        keyName: gettext("Material"),
        attrName: "material",
        ngBindValue:
          "waterchain.material | pipeMaterialOrEllipsis",
        valueSuffix: "",
        defaultValue: "HDPE"
      }
    ]
  };

  this.pumpstation = {
    rows: [
      {
        keyName: gettext("Type"),
        attrName: "type",
        ngBindValue: "waterchain.type",
        valueSuffix: "",
        defaultValue: "gemaal"
      },
      {
        keyName: gettext("Capacity"),
        attrName: "capacity",
        ngBindValue:
          "waterchain.capacity * 3.6 | niceNumberOrEllipsis: 2",
        valueSuffix: "  (m<sup>3</sup> / uur)",
        defaultValue: "54"
      },
      {
        keyName: gettext("Name"),
        attrName: "name",
        ngBindValue: "waterchain.name",
        valueSuffix: "",
        defaultValue: "onbekend"
      },
      {
        keyName: gettext("Code"),
        attrName: "code",
        ngBindValue:
          "waterchain.code",
        valueSuffix: "",
        defaultValue: "127"
      },
      {
        /// Aanslagpeil
        keyName: gettext("Start level"),
        attrName: "start_level",
        ngBindValue:
          "waterchain.start_level | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "-2.2"
      },
      {
        /// Afslagpeil
        keyName: gettext("Stop level"),
        attrName: "stop_level",
        ngBindValue:
          "waterchain.stop_level | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "-2.8"
      }
    ]
  };

  this.pumped_drainage_area = {
    rows: [
    ]
  };

  this.sluice = {
    rows: [
      {
        keyName: gettext("Name"),
        attrName: "name",
        ngBindValue:
          "waterchain.name",
        valueSuffix: "",
        defaultValue: 'onbekend'
      }
    ]
  };

  this.wastewatertreatmentplant = {
    rows: [ //Afvalwaterzuiveringsinstallatie
      {
        keyName: gettext("Name"),
        attrName: "name",
        ngBindValue: "waterchain.name",
        valueSuffix: "",
        defaultValue: "onbekend"
      },
    ]
  };

  this.weir = {
    rows: [
      {
        keyName: gettext("Code"),
        attrName: "code",
        ngBindValue:
          "waterchain.code",
        valueSuffix: "",
        defaultValue: "473"
      },
      {
        keyName: gettext("Width"),
        attrName: "crest_width",
        ngBindValue:
          "waterchain.crest_width | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: "1.6"
      },
      {
        /// Niveau
        keyName: gettext("Crest Level"),
        attrName: "crest_level",
        ngBindValue:
          "waterchain.crest_level | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "-0.3"
      },
      {
        /// Bediening
        keyName: gettext("Control"),
        attrName: "controlled",
        ngBindValue:
          "waterchain.controlled | lookupWeirControl",
        valueSuffix: "",
        defaultValue: "RTC"
      },
    ]
  };

}]);



/**
 * Service to parse and get a list of assets from parent assets.
 *
 * It return the pumps, filters and monitoringwells as a list of assets.
 *
 * Usage: inject getNestedAssets and call getNestedAssets(parentAsset);
 *
 * @param {object} asset Parent asset.
 * @return {array} list of child assets with entity names.
 */
angular.module('omnibox')
.service('getNestedAssets', [
  function () {
    return function (asset) {

      var NESTED_ASSETS = ['pumps', 'filters', 'monitoring_wells'];
      var nestedAssets = [];

      var child = _.pickBy(asset, function (value, key) {
        return NESTED_ASSETS.indexOf(key) !== -1;
      });

      if (_.isEmpty(child)) {
        return [];
      }

      var name = Object.keys(child)[0];
      var value = child[name];

      // entity_name is singular, property name is plural. Use slice to remove
      // last 's'. Do not worry, I am an engineer.
      var attr = name.slice(0,-1).replace('_', '');

      if (typeof(value) === 'string') {
        nestedAssets = JSON.parse(value);
      } else if (typeof(value) === 'object') {
        nestedAssets = value;
      } else {
        nestedAssets = [];
      }

      nestedAssets.forEach(function (asset) {
        asset.entity_name = attr; // Store to remove asset from selection.
      });

      return nestedAssets;

    };

  }
]);

angular.module('omnibox')
  .service('DateParser', [function DateParser () {

    var moment = window.moment;

    moment().locale('nl');

    var HOUR = moment.duration(1, 'hour');
    var DAY = moment.duration(1, 'day');
    var MONTH = moment.duration(1, 'month');
    var YEAR = moment.duration(1, 'year');

    /**
     * Ordered object of date formats, with zoom intervals. First match is
     * preferred. Non specified values default to the current date, also when
     * in the future. 03-10 results in 3rd of november while 03-13 results in
     * the 13th of march.
     */
    var FORMATS_INTERVALS = {
      'DD': DAY, // 21
      // 'DD MM': DAY,  // 21-04 (Clashes with YYYY for 2000 - 2012)
      'DD MM YYYY': DAY, // 21-04-2013
      'DD MM YYYY HH': HOUR, // 21-04-2013 11
      'DD MMM': DAY, // 21 april
      'DD MMM YYYY': DAY, // 21 april 2013
      'DD MMM YYYY HH': HOUR, // 21 april 2013 11
      'MM DD': DAY, // 04-21
      'MMM': MONTH, // april 21
      'MMM DD': DAY, // april 21
      'MM YYYY': MONTH, // 04-2013
      'MMM YYYY': MONTH, // april 2013
      'YYYY': YEAR, // 2013
      'YYYY MM': MONTH, // 2013-04
      'YYYY MMM': MONTH, // 2013 april
      'YYYY MM DD': DAY, // 2013-04-21
      'YYYY MM DD HH': HOUR, // 2013-04-21 11
      'YYYY MMM DD': DAY, // 2013 april 21
      'YYYY MMM DD HH': HOUR, // 2013 april 21 11
    };

    /**
     * Lookup for display formats from ISO duration representations to display
     * format strings.
     */
    var FORMAT_STRINGS = {
      'PT1H': 'DD MMMM YYYY, HH uur',
      'P1D': 'DD MMMM YYYY',
      'P1M': 'MMMM YYYY',
      'P1Y': 'YYYY'
    };

    // add ISO date support http://en.wikipedia.org/wiki/ISO_8601
    var formatters = Object.keys(FORMATS_INTERVALS);
    formatters.push(moment.ISO_8601);

    /**
     * Takes a string and attempts to parse it using a list of formatter
     * strings. Return a moment.js moment and adds a nxt specific nxtInterval
     * containing the interval beloning to the matched format as a moment.js
     * duration and a nxtFormatString containing the format stirng that should
     * be used for display.
     *
     * Example: dString 'maa 2015' gets a moment.js duration of 1 month. And
     * a format string of 'MMMM YYYY' which will parse the moment as
     * 'Maart 2015'.
     *
     * @param  {string} dString string to match a date to.
     * @return {moment} moment with a moment duration under nxtInterval and a
     *                         display format under nxtFormatString.
     */
    var parser = function (dString) {
      var m = moment(dString, formatters);
      m.nxtInterval = FORMATS_INTERVALS[m._f] || HOUR;
      m.nxtFormatString = FORMAT_STRINGS[m.nxtInterval.toString()];
      return m;
    };

    return parser;

  }
]);

'use strict';

/**
 * @ngdoc service
 * @name lizardClientApp.SearchService
 * @description
 * # SearchService
 * Service in the lizardClientApp.
 */
angular.module('omnibox')
  .service('SearchService',
    [
    '$q',
    '$http',
    'LeafletService',
    'CabinetService',
    'DateParser',
    'DataService',
    'MapService',
    'notie',
    function SearchService (
      $q,
      $http,
      LeafletService,
      CabinetService,
      dateParser,
      DataService,
      MapService,
      notie
      ) {

    this.responseStatus = {
        OK: 'OK',
        ZERO_RESULTS: 'ZERO_RESULTS',
        OVER_QUERY_LIMIT: 'OVER_QUERY_LIMIT',
        REQUEST_DENIED: 'REQUEST_DENIED',
        INVALID_REQUEST: 'INVALID_REQUEST',
        UNKNOWN_ERROR: 'UNKNOWN_ERROR'
    };

    var localPromise = {};

    this.cancel = function () {
      if (localPromise.resolve) {
        localPromise.resolve({data: {results: []}});
      }
    };

    /**
     * Sends searchstring to date parser and geocoder resource.
     *
     * @param  {str} searchString used to query geocoder and parse date.
     * @param  {object} spatialState to use in biasing geocoder to current view.
     * @return {object} object with moment and promise
     *                        moment is a moment.js object
     *                        promise resolves with response from geocoder.
     */
    this.search = function (searchString, state) {

      var getSearch = function (params) {

        var MINIMUM_SEARCH_QUERY_LENGTH = 3;

        // Cancel consecutive calls.
        if (localPromise.resolve) {
          localPromise.resolve({data: {results: []}});
        }

        localPromise = $q.defer();

        // Only send request if searchstring is longer than 2.
        // Otherwise return zero relevant searches.
        if (params.q.length >= MINIMUM_SEARCH_QUERY_LENGTH) {
          return $http({
            url: 'api/v2/search/',
            method: 'GET',
            params: params,
            timeout: localPromise.promise
          })
          .then(function (response) {
            return response.data;
          }, errorFn);
        }
        else {
          localPromise.resolve({results: []});
          return localPromise.promise;
        }
      };

      var errorFn = function (err) {
        if (err.status === 420 || err.status === -1) {
          // Cancel normal operations
          return $q.reject(err);
        }
        else if (err.status >= 500 && err.status < 600) {
          notie.alert(3, 'Lizard encountered a problem while searching your query.', 3);
          // Cancel normal operations
          return $q.reject(err);
        }
        window.Raven.captureException(err);
        return err; // continue anyway
      };

      var bounds;
      // bounds are not available in the dashboard view.
      if (state.spatial.bounds.getSouth) {
          bounds = // Prefer results from the current viewport
            state.spatial.bounds.getSouth() + ',' +
            state.spatial.bounds.getWest() + '|' +
            state.spatial.bounds.getNorth() + ',' +
            state.spatial.bounds.getEast();
      }
      // TODO: request results in portals language and restrict results based
      // on portal by adding: components: 'country:NL'.
      var prom = CabinetService.geocode.get({
        address: searchString,
        language: state.language, // Preferred language of search results.
        bounds: bounds
      });

      var moment = dateParser(searchString);

      var search = getSearch({
        q: searchString
      });

      return {
        search: search,
        spatial: prom,
        temporal: moment
      };
    };

    /**
     * Zooms to result of geocoder. If result is precise it also simulates a
     * click on the result.
     * @param  {object} result google geocoder result.
     */
    this.zoomToGoogleGeocoderResult = function (result, state) {
      state.spatial.bounds = LeafletService.latLngBounds(
        LeafletService.latLng(result.geometry.viewport.southwest),
        LeafletService.latLng(result.geometry.viewport.northeast)
      );
      if (result.geometry.location_type === 'ROOFTOP') { // Precise location
        state.spatial.here = LeafletService.latLng(result.geometry.location);
      }
      return state;
    };

    /**
     * Zooms to API search result. If the box type is multi-point add the
     * selected search result to the other selected points, otherwise replace
     * the currently selected point.
     *
     * @param {object} result: API search result.
     * @param {object} state: the current state.
     * @return {object} state: the new state.
     */
    this.zoomToSearchResult = function (result, state) {
      var ZOOM_FOR_OBJECT = 19;

      if (state.box.type !== 'multi-point' && state.context !== 'dashboard') {
        state.selected.reset();
      }

      state.selected.assets.addAsset(
        result.entity_name + '$' + result.entity_id);

      MapService.setView({
        lat: result.view[0],
        lng: result.view[1],
        zoom: result.view[2] || ZOOM_FOR_OBJECT
      });

      return state;
    };
  }
]);

angular.module('omnibox')
.service('DBCardsService', [
  'State',
  'DataService',
  'TimeseriesService',
  function (State, DataService, TimeseriesService) {

  /**
   * Loops over all the items that can be plotted and return the count and the
   * highest order.
   *
   * @return {{count: int, order: int}}
   */
  var getActiveCountAndOrder = function () {

    var orders = [];
    var actives = 0;

    _.forEach(
      State.selected.timeseries,
      function (ts) {
        if (ts.active) {
          actives++;
          orders.push(ts.order);
        }
      }
    );

    DataService.assets.forEach(function (asset) {

      _.forEach(
        asset.properties,
        function (property) {
          if (property.active) {
            actives++;
            orders.push(property.order);
          }
        }
      );

      if (asset.entity_name === 'leveecrosssection' &&
        asset.crosssection.active) {
        actives++;
        orders.push(asset.crosssection.order);
      }
    });

    DataService.geometries.forEach(function (geometry) {
      _.forEach(
        geometry.properties,
        function (property) {
          if (property.active) {
            actives++;
            orders.push(property.order);
          }
        }
      );
    });

    return {
      count: actives,
      order: _.max(orders)
    };

  };

  var removeItemFromPlot = function (item) {
    var order = item.order;
    var uuid = item.uuid; // Timeseries have a uuid. Other plottable items do
                          // not.

    var otherItems = 0;

    if (uuid) {
      // Check if it was the last timeseries in the chart.
      otherItems += _.filter(
        State.selected.timeseries,
        function (ts) {
          return ts.active && ts.uuid !== uuid && ts.order === order;
        }
      ).length;
    }

    if (otherItems === 0) {
      State.selected.timeseries.forEach(function (ts) {
        if (ts.order > order) {
          ts.order--;

          // TimeseriesService.timeseries get an order when fetched. Set
          // this when changing order of timeseries in
          // TimeseriesService.timeseries.
          var fetchedTimeseries = _.find(
            TimeseriesService.timeseries,
            function (fts) { return fts.id === ts.uuid; }
          );
          if (fetchedTimeseries) {
            fetchedTimeseries.order = ts.order;
          }

        }
      });

      DataService.assets.forEach(function (asset) {
        if (asset.entity_name === 'leveecrosssection' &&
          asset.crosssection.active && asset.crosssection.order > order) {
          asset.crosssection.order--;
        }
        _.forEach(asset.properties, function (property) {
          if (property.order > order) { property.order--; }
        });
      });

      DataService.geometries.forEach(function (geometry) {
        _.forEach(geometry.properties, function (property) {
          if (property.order > order) { property.order--; }
        });
      });

    }

  };

  return {
    getActiveCountAndOrder: getActiveCountAndOrder,
    removeItemFromPlot: removeItemFromPlot
  };

}]);

/**
 * Template directives.
 *
 * * Timeseries
 * * Cardtitle
 * * Event aggregation
 * * Actions
 * * Cardattributes
 * * Detailswitch
 *
 */

angular.module('omnibox')
  .directive('assetCards', ['ClickFeedbackService', 'MapService', 'user',
    function (ClickFeedbackService, MapService, user) {
  return {
    link: function (scope, element) {

      scope.user = user;

      var clickId;

      var removeAsset = function (id) {
        ClickFeedbackService.removeClickFromClickLayer(id);
      };

      var setAsset = function (asset) {

        if (clickId) {
          removeAsset(clickId);
        }

        // Child assets (filters from grounwater stations) do not always have
        // a geometry.
        if (asset.geometry) {

          var feature = {
            type: 'Feature',
            geometry: asset.geometry,
            properties: {
              entity_name: asset.entity_name,
              type: asset.type || ''
            }
          };

          clickId = ClickFeedbackService.drawGeometry(
            MapService,
            feature
          );

          ClickFeedbackService.vibrateOnce(feature, clickId);

        }

      };

      scope.$watch('asset', setAsset);

      element.on('$destroy', function () {
        if (clickId) {
          removeAsset(clickId);
        }
      });


    },
    restrict: 'E',
    scope: {
      asset: '=',
      timeState: '=',
      longFormat: '=',
      showHeader: '=',
      showTimeseries: '=',
      showAnnotations: '='
    },
    replace: true,
    templateUrl: 'omnibox/templates/asset-cards.html'
  };
}]);


angular.module('omnibox')
  .directive('geometryCards', ['MapService', 'ClickFeedbackService', 'CSVService', 'user',
    function (MapService, ClickFeedbackService, CSVService, user) {
  return {
    link: function (scope, element) {

      scope.user = user;

      scope.showNoData = false;

      // expose CSV functions for export
      scope.formatLineCSV = CSVService.formatLineCSV;
      scope.getLineCSVHeaders = CSVService.getLineCSVHeaders;

      var clickId = 0;

      var destroy = function () {
        if (clickId) {
          ClickFeedbackService.removeClickFromClickLayer(clickId);
        }
      };

      scope.$watchCollection('geom.geometry.coordinates', function () {
        destroy();

        var geom = scope.geom;

        if (scope.header && geom.geometry.type === 'Point') {
          var latLng = L.latLng(
            geom.geometry.coordinates[1],
            geom.geometry.coordinates[0]
          );
          clickId = ClickFeedbackService.drawArrow(MapService, latLng);
        }

        else if (scope.header && geom.geometry.type === 'LineString') {
          var coords = geom.geometry.coordinates;
          var start = L.latLng(coords[0][1], coords[0][0]);
          var end = L.latLng(coords[1][1], coords[1][0]);
          clickId = ClickFeedbackService.drawLine(
            MapService,
            start,
            end
          );

        }
      });

      scope.$watchCollection('geom.properties', function (newProps, oldProps) {
        if (newProps) {
          scope.showNoData = !Object.keys(newProps).length;
        }
      });

      element.on('$destroy', function () {
        destroy();
      });


    },
    restrict: 'E',
    scope: {
      geom: '=',
      timeState: '=',
      header: '=',
      mouseloc: '='
    },
    replace: true,
    templateUrl: 'omnibox/templates/geometry-cards.html'
  };
}]);


angular.module('omnibox')
  .directive('cardattributes', ['WantedAttributes',
    function (WantedAttributes) {
  return {
    link: function (scope) {

      scope.wanted = WantedAttributes; },
    restrict: 'E',
    scope: {
      waterchain: '=',
      showHeader: '='
    },
    replace: true,
    templateUrl: 'omnibox/templates/cardattributes.html'
  };
}]);

angular.module('omnibox')
  .directive('cardheader', ['UtilService',
    function (UtilService) {
  return {
    link: function (scope) {
      scope.getIconClass = UtilService.getIconClass;
    },
    restrict: 'E',
    scope: {
      asset: '=',
      geom: '='
    },
    replace: true,
    templateUrl: 'omnibox/templates/card-header.html'
  };
}]);




angular.module('omnibox')
  .directive('summaryCard', ['WantedAttributes',
    function (WantedAttributes) {
  return {
    link: function (scope) { scope.wanted = WantedAttributes; },
    restrict: 'E',
    scope: {
      asset: '='
    },
    replace: true,
    templateUrl: 'omnibox/templates/summary-card.html'
  };
}]);


angular.module('omnibox')
  .directive('nestedasset', ['WantedAttributes', 'DataService', 'State', 'getNestedAssets',
    function (WantedAttributes, DataService, State, getNestedAssets) {
  return {
    link: function (scope) {

      scope.wanted = WantedAttributes;
      scope.longFormat = false;

      var NESTED_ASSETS = ['pumps', 'filters', 'monitoring_wells'];

      /**
       * Watch asset unpack json string, add entity name and select first child
       * asset.
       */
      scope.$watch('asset', function () {
        scope.list = getNestedAssets(scope.asset);
        scope.asset.selectedAsset = scope.list[0];
      });

      var removeTSofAsset = function (asset) {
        State.selected.timeseries = _.differenceBy(
          State.selected.timeseries,
          asset.timeseries,
          'uuid'
        );
      };

      scope.selectedAssetChanged = function (newAsset) {
        scope.list.forEach(function (asset) {
          if (asset.entity_name === newAsset.entity_name
            && asset.id === newAsset.id) {
            return;
          }
          else {
            removeTSofAsset(asset);
          }
        });
      };

      scope.$on('$destroy', function () {
        scope.list.forEach(function (asset) { removeTSofAsset(asset); });
      });

    },
    restrict: 'E',
    scope: {
      asset: '=',
      timeState: '=',
    },
    replace: true,
    templateUrl: 'omnibox/templates/nestedasset.html'
  };
}]);

angular.module('omnibox')
  .directive('rain', ['State', 'RasterService', function (State, RasterService) {
  return {
    link: function (scope) {

      scope.rrc = {
        active: false
      };

      scope.rain.MAX_TIME_INTERVAL = 86400000 * 365.2425 / 12; // 1 month

      var setGraphContent = function () {
        scope.graphContent = [{
          data: scope.rain.properties.rain.data,
          keys: {x: 0, y: 1},
          labels: {y: 'mm'}
        }];
      };

      scope.recurrenceTimeToggle = function () {
        scope.rrc.active = !scope.rrc.active;
        if (scope.rrc.active) { getRecurrenceTime(); }
      };


      scope.$watchCollection("rain.properties.rain.data", function (n, o) {
        setGraphContent();
        if (scope.rrc.active) {
          getRecurrenceTime();
        }
      });

      // Gets data directly from raster endpoint of raster RAW_RAIN_RASTER_UUID
      var RAW_RAIN_RASTER_UUID = '730d6675-35dd-4a35-aa9b-bfb8155f9ca7';

      scope.getRawDataUrl = function (event) {
        var coords = scope.rain.geometry.coordinates;
        // hack to make it testable on staging :(
        return 'https://demo.lizard.net/api/v2/rasters/' +
          RAW_RAIN_RASTER_UUID + '/data/' +
          '?format=csv' +
          '&start=' +
          new Date(State.temporal.start).toISOString().split('.')[0] +
          '&stop=' +
          new Date(State.temporal.end).toISOString().split('.')[0] +
          '&geom=' + 'POINT(' + coords[0] + ' ' + coords[1] +')' +
          '&srs=EPSG:4326';
      };
      // ENDHACK

      var getRecurrenceTime = function () {
        scope.rrc.data = null;

        RasterService.getData(
          'RainController',
          {slug: 'rain'},
          {
            agg: 'rrc',
            geom: L.latLng(scope.rain.geometry.coordinates[1], scope.rain.geometry.coordinates[0]),
            start: State.temporal.start,
            end: State.temporal.end
          }
        ).then(function (response) {
          scope.rrc.data = response;
        });
      };

    },
    restrict: 'E',
    scope: {
      rain: '=',
      timeState: '='
    },
    replace: true,
    templateUrl: 'omnibox/templates/rain.html'
  };
}]);

angular.module('omnibox')
  .directive('defaultpoint', ['UtilService', function (UtilService) {
  return {
    link: function (scope) {
      scope.isUrl = UtilService.isUrl;
    },
    restrict: 'E',
    scope: {
      content: '=',
      timeState: '=',
    },
    replace: true,
    templateUrl: 'omnibox/templates/defaultpoint.html'
  };
}]);

angular.module('omnibox')
  .directive('searchResults', [function () {
  return {
    restrict: 'E',
    templateUrl: 'omnibox/templates/search-results.html'
  };
}]);

'use strict';

/**
 * @description directive that displays search
 * and makes sure the right services are called.
 */
angular.module('omnibox')
  .directive('search', [
    'SearchService',
    'ClickFeedbackService',
    'MapService',
    'State',
    'UtilService',
  function (SearchService, ClickFeedbackService, MapService, State, UtilService) {

  var link = function (scope, element, attrs) {

    scope.omnibox.searchResults = {};

    scope.util = UtilService;
    scope.query = '';

    var ZOOM_FOR_OBJECT = 16;

    // Set focus on search input field.
    element.children()[0].focus();

    // Bind mapservice functions for zoom buttons;
    scope.zoomIn = MapService.zoomIn;
    scope.zoomOut = MapService.zoomOut;

    /**
     * Uses scope.query to search for results through SearchService. Response
     * from SearchService.search is an object with various results and promises.
     *
     * Currently searches for time and addresses.
     *
     * scope.omnibox.searchResults is used by search-results template.
     */
    scope.search = function () {
      scope.omnibox.searchResults = {};
      if (scope.query.length > 0) {
        var results = SearchService.search(scope.query, State);
        setResultsOnBox(results);
      } else {
        scope.cleanInput();
      }
    };

    /**
     * @description resets input field
     * on scope, because also needs to trigger on reset button,
     * not just on succesful search/zoom.
     *
     * @description - This does the following:
     *
     * (1) - Reset box.type to it's default value, "point";
     * (2) - Reset the search query to the empty string;
     * (3) - Reset box.content to an empty object;
     * (4) - Clear mapState.points arr (used for updating the Url);
     * (5) - Clear the click feedback.
     */
    scope.cleanInput = function () {
      SearchService.cancel();
      scope.query = "";
      scope.omnibox.searchResults = {};
    };

    /**
     * @description zooms to search resulit
     * @param {object} one search result.
     */
    scope.zoomToSearchResult = function (result) {
      scope.omnibox.searchResults = {};
      scope.query = "";
      State = SearchService.zoomToSearchResult(result, State);
    };

    /**
     * @description zooms to geocoder search result
     * @param {object} one search result.
     */
    scope.zoomToSpatialResult = function (result) {
      scope.omnibox.searchResults = {};
      scope.query = "";
      State = SearchService.zoomToGoogleGeocoderResult(result, State);
    };

    /**
     * Called by click on temporal result. Cleans results and search box and
     * Zooms to moment.js moment with nxtInterval.
     * @param  {moment} m moment.js moment with nxtInterval as a moment
     *                              duration.
     */
    scope.zoomToTemporalResult = function(m) {
      scope.omnibox.searchResults = {};
      scope.query = "";
      State.temporal.start = m.valueOf();
      State.temporal.end = m.valueOf() + m.nxtInterval.valueOf();
      UtilService.announceMovedTimeline(State);
    };


    var prevKey; // stores the previously pressed key.
    var prevKeyTimeout; // resets the key after TIMEOUT.
    var TIMEOUT = 300; // 300 ms

    /**
     * @description event handler for key presses.
     * checks if enter is pressed, does search.
     * @param {event} event that is fired.
     * 13 refers to the RETURN key.
     */
    scope.searchKeyPress = function ($event) {
      clearTimeout(prevKeyTimeout);
      var KEYPRESS = {
        BACKSPACE: 8,
        ENTER: 13,
        SPACE: 32,
        ESC: 27
      };

      if ($event.target.id === "searchboxinput") {
        // Intercept keyPresses *within* searchbox,do xor prevent animation
        // from happening when typing.

        if ($event.which === KEYPRESS.ESC) {
          scope.cleanInput();
        }

        else if ($event.which === KEYPRESS.SPACE) {
          // prevent anim. start/stop
          $event.originalEvent.stopPropagation();
        }

        else if ($event.which === KEYPRESS.ENTER) {
          var results = scope.omnibox.searchResults;
          if (results.temporal || results.spatial || results.api) {
            if (results.temporal) {
              scope.zoomToTemporalResult(
                scope.omnibox.searchResults.temporal
              );
            }
            else if (results.api) {
              scope.zoomToSearchResult(
                scope.omnibox.searchResults.api[0]
              );
            }
            else if (results.spatial) {
              scope.zoomToSpatialResult(
                scope.omnibox.searchResults.spatial[0]
              );
            }
            scope.cleanInput();
          }
        }
      }
    };

    /**
     * Contains the logic to go through search result and puts relevant parts on
     * box scope.
     *
     * When time is a valid moment it is synchronously put on
     * scope.omnibox.searchResults.temporal. If time is not valid it waits
     * for spatial results and puts those result on
     * scope.omnibox.searchResults.spatial. Prefers temporal results to
     * spatial results.
     *
     * @param {object} results object, with moment and promise
     * moment is a moment.js object
     * promise resolves with response from geocoder.
     */
    var setResultsOnBox = function (results) {
      var MAX_RESULTS = 3;

      if (
        results.temporal.isValid()
        && results.temporal.valueOf() > UtilService.MIN_TIME
        && results.temporal.valueOf() < UtilService.MAX_TIME
        ) {
        scope.omnibox.searchResults.temporal = results.temporal;
        // moment object.
      }

      else {
        results.spatial
          .then(function (response) {
            // Asynchronous so check whether still relevant.
            if (scope.omnibox.searchResults === undefined) { return; }

            // Either put results on scope or remove model.
            if (response.status === SearchService.responseStatus.OK) {
              var results = response.results;
              // limit to MAX_RESULTS results
              if (results.length >  MAX_RESULTS) {
                results = results.splice(0, MAX_RESULTS);
              }
              scope.omnibox.searchResults.spatial = results;
            }
            else if (
              response.status !== SearchService.responseStatus.ZERO_RESULTS
            ) {
              // Throw error so we can find out about it through sentry.
              throw new Error(
                'Geocoder returned with status: ' + response.status
              );
            }

          }
        );
      }

      results.search
        .then(function (response) {
          // Asynchronous so check whether still relevant.
          if (scope.omnibox.searchResults === undefined) { return; }
          if (response.results.length) {
            scope.omnibox.searchResults.api = response.results;
          }
        }
      );
    };

    /**
     * @description removes location model from box content
     */
    var destroySearchResultsModel = function () {
      delete scope.omnibox.searchResults;
    };

  };

  return {
    link: link,
    restrict: 'E',
    replace: true,
    templateUrl: 'omnibox/templates/search.html'
  };

}]);

'use strict';

angular.module("omnibox")
.directive("omnibox", ['$window', '$document', 'State',
  function ($window, $document, State) { return {

    /**
     * Keeps omnibox size in check and creates and maintains a scrollbar.
     */
    link: function (scope, element) {

      // In pixels
      var SEARCHBAR_FROM_TOP = 60;
      var TIMLINE_BOTTOM_MARGIN = 10;
      var OMNIBOX_BOTTOM_MARGIN = 5;
      var OMNIBOX_TOP_MARGIN = 5;

      var cards = element.find('#cards');

      window.Ps.initialize(cards[0]);

      /**
       * Sets the height of the scroll area to fit between search box and
       * timeline and updates PerfectScroll.
       */
      var setMaxHeight = function () {
        var tlHeight = $document.find('#timeline').height()
          + TIMLINE_BOTTOM_MARGIN;
        var maxHeight = $window.innerHeight
          - SEARCHBAR_FROM_TOP
          - OMNIBOX_BOTTOM_MARGIN
          - OMNIBOX_TOP_MARGIN;
        maxHeight = maxHeight - tlHeight;

        cards.css('max-height', maxHeight + 'px');
        window.Ps.update(cards[0]);
      };

      // Its is not necassary to set height exactly when digest loops, as long
      // as it occasionally happens and it should not block the ui.
      var WAIT = 300; // min ms to wait between calling throttled.
      var throttled = _.throttle(setMaxHeight, WAIT, {trailing: true});

      /**
       * Update scroll bar on every digest since we do not know about timelines
       * and searchresults and who knows.
       */
      scope.$watch(throttled);

      // Cancel throttled function and rm scroll bar.
      scope.$on('$destroy', function () {
        throttled.cancel();
        window.Ps.destroy(cards[0]);
      });

    },

    restrict: 'E',
    replace: true,
    templateUrl: 'omnibox/templates/omnibox.html'
  };

}]);


angular.module('omnibox')
  .directive('dbCards', [ 'State', 'DataService', 'DragService', 'gettextCatalog', 'notie', 'TimeseriesService', 'DBCardsService',
    function (State, DataService, DragService, gettextCatalog, notie, TimeseriesService, DBCardsService) {
  return {
    link: function (scope, element) {

      DragService.create();

      var emulateClick = function (el) {
        // other plottable item. Toggle on drag to put element in their own
        // plot.
        element.find('#' + el.dataset.uuid).click();
      };

      var getTsMetaData = function (uuid) {
        var tsMetaData;
        _.forEach(DataService.assets, function (asset) {
          tsMetaData = _.find(asset.timeseries, function (ts) {
            return ts.uuid === uuid;
          });
          return !tsMetaData;
        });
        return tsMetaData;
      };

      /**
       * Turn ts on and give it the order of the dropped plot. Ts could already
       * be part of a plot above or below it, if so rearrange existing plots.
       * And make sure ts gets the right order.
       *
       * @param  {DOM}    el      Dragged element.
       * @param  {DOM}    target  Plot in drop.
       */
      DragService.on('drop', function (el, target) {
        var order = Number(target.getAttribute('data-order'));
        var uuid = el.getAttribute('data-uuid');

        // El either represents a timeseries or another plottable item.
        //
        // NOTE: there is only one drop callback for all the possible assets. So
        // instead of searching for the ts in scope.asset.timeseries, all the
        // assets are searched.
        // timeseries
        var ts, otherGraphTS, otherCompatibleGraph;

        // timeseries representend by el.
        ts = _.find(State.selected.timeseries, function (ts) {
          return ts.uuid === uuid;
        });

        // Possible other graph in target.
        otherGraphTS = _.find(State.selected.timeseries, function (ts) {
          return ts.order === order && ts.active;
        });

        if (otherGraphTS === undefined) {
          // No other graph, just turn ts to active.
          emulateClick(el);
          el.remove();
          return;
        }

        // If ts was already active: first remove and rearrange plots in
        // dashboard, then continue adding it to the dragged plot.
        if (ts.active) {
          var otherTSInOrigninalPlot = _.find(
            State.selected.timeseries,
            function (_ts) {
              return _ts.active
                && _ts.order === ts.order
                && _ts.uuid !== ts.uuid;
            }
          );
          if (otherTSInOrigninalPlot === undefined) {
            // Plot where ts came from is now empty and removed.
            order = order < ts.order ? order : order - 1;
          }

          ts.active = false;
          DBCardsService.removeItemFromPlot(ts);
        }

        var tsMetaData = getTsMetaData(ts.uuid);
        var otherGraphTsMetaData = getTsMetaData(otherGraphTS.uuid);
        if (tsMetaData.value_type !== otherGraphTsMetaData.value_type) {
          notie.alert(2,
            gettextCatalog.getString('Whoops, the graphs are not the same type. Try again!'));
          emulateClick(el);
        } else {
          // Set new order and tell TimeSeriesService to get data.
          ts.order = order || 0; // dashboard could be empty
          ts.active = true;
          TimeseriesService.syncTime();
        }

        // Remove drag element.
        el.remove();

      });

      scope.$on('$destroy', function () {
        DragService.destroy();
      });

    },
    restrict: 'E',
    replace: true,
    templateUrl: 'omnibox/templates/db-cards.html'
  };
}]);

/**
 *
 * Adds and removes nested assets to State
 *
 */
angular.module('omnibox')
.directive('dbNestedAsset', [
  'getNestedAssets',
  'State',
  function (getNestedAssets, State) {

    var link = function (scope, element, attrs) {

      var nestedAssets = getNestedAssets(scope.asset);

      nestedAssets.forEach(function (asset) {
        State.selected.assets.addAsset(asset.entity_name + '$' + asset.id);
      });

      scope.$on('$destroy', function () {
        nestedAssets.forEach(function (asset) {
          var assetId = asset.entity_name + '$' + asset.id;
          var i = State.selected.assets.indexOf(assetId);
          if (i !== -1) {
            State.selected.assets.removeAsset(assetId);
          }
        });
      });

    };


    return {
      link: link,
      restrict: 'E',
      scope: {
        asset: '=',
        timeState: '='
      },
    };

  }]);



angular.module('omnibox')
  .directive('dbAssetCard', [ 'State', 'DataService', 'DragService', 'DBCardsService', 'TimeseriesService',
    function (State, DataService, DragService, DBCardsService, TimeseriesService) {
  return {
    link: function (scope, element) {

      scope.selected = State.selected;

      scope.getTsMetaData = function (uuid) {
        return _.find(scope.asset.timeseries, function (ts) {
          return ts.uuid === uuid;
        });
      };

      scope.noTimeseries = scope.asset.timeseries.length === 0;

      scope.toggleTimeseries = function (timeseries) {

        if (!timeseries.active) {

          var plots = DBCardsService.getActiveCountAndOrder();

          timeseries.order = plots.count > 0
            ? plots.order + 1
            : 0;

        }

        else {

          DBCardsService.removeItemFromPlot(timeseries);

        }

        timeseries.active = !timeseries.active;
        TimeseriesService.syncTime();

      };

      /**
       * Specific toggle for crosssection
       *
       * @param  {object} asset with entity_name crossection and a crossection
       *                        model.
       */
      scope.toggleCrosssection = function (asset) {

        if (!asset.crosssection.active) {
          var plots = DBCardsService.getActiveCountAndOrder();

          asset.crosssection.order = plots.count > 0
            ? plots.order + 1
            : 0;

          asset.crosssection.active = true;

        } else {
          DBCardsService.removeItemFromPlot(asset.crosssection);
          asset.crosssection.active = false;
        }

        if (DataService.onGeometriesChange) {
          DataService.onGeometriesChange();
        }
      };

      // Init crosssection
      if (scope.asset.entity_name === 'leveecrosssection') {
        scope.asset.crosssection = {
          active: false, // set to true by  toggle
          order: 0
        };
        scope.toggleCrosssection(scope.asset);
      }

      DragService.addDraggableContainer(element.find('#drag-container'));

    },
    restrict: 'E',
    scope: {
      asset: '=',
      timeState: '='
    },
    replace: true,
    templateUrl: 'omnibox/templates/db-asset-card.html'
  };
}]);


angular.module('omnibox')
.directive('dbGeometryCards', [ 'State', 'DBCardsService', 'DataService',
  function (State, DBCardsService, DataService) {
    return {
      link: function (scope) {

        scope.noData = true;

        scope.dbSupportedData = function (type, property) {
          var temporal = property.temporal && type === 'Point';

          var events = property.format === 'Vector' && type !== 'LineString';

          var other = type !== 'Point'
            && property.scale !== 'nominal'
            && property.scale !== 'ordinal';

          return temporal || events || other;
        };

        /**
         * Properties are asynchronous so watch it to set noData when added.
         */
        scope.$watch('geom.properties', function (n, o) {

          _.forEach(scope.geom.properties, function (property, slug) {
            if (property.active === undefined
              && scope.dbSupportedData(
                scope.geom.geometry.type,
                property
              )) {
              scope.toggleProperty(property);
            }
          });

          // No raster data when properties is undefined or when properties is
          // empty object.
          var noRasterData = scope.geom.properties
            ? !Object.keys(scope.geom.properties).length
            : true;

          scope.noData = noRasterData && scope.geom.entity_name === undefined;

        }, true);


        scope.toggleProperty = function (property) {

          if (!property.active) {
            var plots = DBCardsService.getActiveCountAndOrder();

            // On toggle, add seperate graph. Give order of highest order + 1.
            property.order = plots.count > 0
              ? plots.order + 1
              : 0;
            property.active = true;
          }

          else {
            DBCardsService.removeItemFromPlot(property);
            property.active = false;
          }

          if (DataService.onGeometriesChange) {
            DataService.onGeometriesChange();
          }

        };

        scope.$on('$destroy', function () {
          _.forEach(scope.geom.properties, function (property) {
            property.active = true;
            scope.toggleProperty(property);
            // Activity of property should not be defined when creating
            // dashboard.
            property.active = undefined;
          });
        });

      },
      restrict: 'E',
      scope: {
        geom: '=',
        timeState: '=',
        header: '='
      },
      replace: true,
      templateUrl: 'omnibox/templates/db-geometry-cards.html'
    };
  }
]);

/**
 *
 * Removes asset from selection
 *
 * TODO: this directive or an attribute directive should be responsible for
 * making the card small when there is not enough space.
 *
 * TODO 2: use ng-click so we do not have to worry about running a digest cycle
 * manually.
 */
angular.module('omnibox')
.directive('closeCard', [
  'State',
  'DataService',
  'TimeseriesService',
  function (State, DataService, TimeseriesService) {

    var link = function (scope, element, attrs) {

      /**
       * Removes asset from global State.
       *
       * Requires entity and id of asset on scope.
       */
      scope.rmAssetOrGeometry = function () {
        if (scope.geometry) {
          State.selected.geometries.removeGeometry(scope.geometry);
        }

        else if (scope.asset) {

          var assetId = scope.asset.entity_name + '$' + scope.asset.id;
          // Remove the asset from the selection.
          var selectedAssets = State.selected.assets;
          if (selectedAssets.indexOf(assetId) >= 0) {
            selectedAssets.removeAsset(assetId);
          }

        }
      };

    };


    return {
      link: link,
      restrict: 'E',
      scope: {
        asset: '=',
        geometry: '='
      },
      replace: true,
      templateUrl: 'omnibox/templates/close-card.html'
    };

  }]);


/**
 *
 * Toggle directive for omnibox cards
 *
 * TODO: this directive or an attribute directive should be responsible for
 * making the card small when there is not enough space.
 *
 * TODO 2: use ng-click so we do not have to worry about running a digest cycle
 * manually.
 */
angular.module('lizard-nxt')
  .directive('fullDetails', ['State', function (State) {

    var link = function (scope, element, attrs) {

      if (scope.fullDetails === undefined) {
        scope.fullDetails = true;
      }

      // FullDetails is set programmatically and by users. Do not set
      // programmatically when a user set it manually.
      var toggledByUser = false;

      // does the actual toggling.
      var toggleDetails = function () {
        if (scope.$$phase) {
          scope.fullDetails = !scope.fullDetails;
        } else {
          scope.$apply(function () {
            scope.fullDetails = !scope.fullDetails;
          });
        }
        toggledByUser = true;
      };

      element.bind('click', toggleDetails);

      /**
       * Minimize boxes when lots of cards.
       */
      scope.$watch(State.toString('selected'), function () {
        var boxLength = State.selected.assets.length
         + State.selected.geometries.length;

        if (!toggledByUser && boxLength > 2) {
          scope.fullDetails = false;
        }
        else if (!toggledByUser) {
          scope.fullDetails = true;
        }
      });

    };


    return {
      link: link,
      restrict: 'E',
      replace: true,
      scope: false,
      templateUrl: 'omnibox/templates/full-details.html'
    };

  }]);


/**
 * @module
 * @description Directive for a color picker.
 */
angular.module('omnibox')
.directive('colorPicker', ['UtilService', 'TimeseriesService',
  function (UtilService, TimeseriesService) {

    var link = function(scope, element, attrs) {
      scope.colorPicker = {
        enabled: false,
        availableColors: UtilService.GRAPH_COLORS,
        selectedColor: scope.ts.color
      };

      var toggleColorPicker = function () {
        scope.colorPicker.enabled = !scope.colorPicker.enabled;
      };

      scope.toggleColorPicker = toggleColorPicker;

      scope.selectColor = function(color) {
        scope.colorPicker.selectedColor = color;
        toggleColorPicker();
      };

      scope.$watch('colorPicker.selectedColor', function() {
        scope.ts.color = scope.colorPicker.selectedColor;
        TimeseriesService.onColorChange(scope.ts);
      });
    };

    return {
      restrict: 'AE',
      link: link,
      templateUrl: 'omnibox/templates/color-picker.html'
    };
  }
]);

/**
 * @name TimeLineService
 * @class angular.module('lizard-nxt')
  .TimeLineService
 * @memberOf app
 *
 * @summary Service to create and update a timeline. Used by timeline-directive.
 *
 * @description Inject "Timeline" and call new timeline(<args>) to create a
 * timeline. Currently the timeline supports circles (events) and vertical bars
 * (rain intensity). The user may interact with the timeline through click and
 * zoom functions.
 *
 * Everything in the timeline is animated for NxtD3.transTime milliseconds. To
 * add new elements to the timeline, make sure the elements are updated on zoom,
 * and resize. The timeline resizes *before* elements are added and *after*
 * elements are removed. Therefore resize transitions should be delayed with
 * NxtD3.transTime when the timeline is shrinking, as is happening in
 * resizeTimelineCanvas.
 */
angular.module('lizard-nxt')
  .factory("Timeline", ["NxtD3", "UtilService", "State",
      function (NxtD3, UtilService, State) {

  // Timeline
  var initialHeight,

  // D3 components
  xScale, // The d3 scale for placement on the x axis within the whole
          // timeline. Is only updated when zoomTo is called, or the window
          // resizes.
  ordinalYScale, // Scale used to place events in circles for each type

  // Interaction functions
  clicked = null,
  zoomed = null,
  zoomend = null,

  // Timeline elements
  futureIndicator,
  aggWindow, // aggregation window
  circles, // events start - end
  bars, // rain intensity
  tickmarks,
  TICKMARK_HEIGHT = 5, // data availability indicators
  MAX_CIRCLE_SIZE = 16;

  /**
   * @constructor
   * @memberOf angular.module('lizard-nxt')
   * TimeLineService
   *
   * @param {object} element - svg element for the timeline.
   * @param {object} dimensions - object containing, width, height, height per
   *  line of events, height per line of bars and an object containing top,
   *  bottom, left and right padding. All values in px.
   * @param {integer} start - begin value in milliseconds from epoch.
   * @param {integer} end - end value in milliseconds from epoch.
   * @param {object} interaction  - optional object containing callback
   * functions for zoom, click and brush interaction with the rest of the
   *  angular.module('lizard-nxt')
   * @param {integer} nEvents - number of event types (event series).
   */
  function Timeline(element, dimensions, start, end, interaction) {
    NxtD3.call(this, element, dimensions);
    initialHeight = dimensions.height;
    this._svg = this._createDrawingArea();
    this._svg = addElementGroupsToCanvas(this._svg, this.dimensions);
    this._initDimensions = dimensions;
    xScale = this._makeScale(
      {min: start, max: end},
      {min: 0, max: this._getWidth(dimensions)},
      {scale: 'time' }
    );
    drawTimelineAxes(this._svg, xScale, dimensions);
    this.addFutureIndicator();
    this.addInteraction(interaction);
  }

  Timeline.prototype = Object.create(NxtD3.prototype, {

    constructor: Timeline,

    /**
     * @attribute
     * @type function to be used to format datetime.
     */
    format: {
      value: NxtD3
        .prototype._localeFormatter.nl_NL.timeFormat("%a %e %b %Y %H:%M")
    },
    format_aggwindow: {
      value: NxtD3.prototype._localeFormatter.nl_NL.timeFormat("%e %b %-H:%M")
    },

    /**
     * @function
     * @summary Adds a now indicator to timeline.
     * @description From 'now' the background of the timeline gets a different
     * style.
     */
    addFutureIndicator: {
      value: function () {
        var width = 20000,
            height = this._getHeight(this.dimensions);

        futureIndicator = this._svg.select("#feature-group").append("rect")
          .attr("height", height)
          .attr("width", width)
          .attr('title', 'Het gedeelte van de tijdlijn dat in de toekomst ligt')
          .attr("id", "nodata")
          .attr("x", xScale(Date.now()))
          .attr("opacity", 0.8)
          .style("fill", "#DDD");
      }
    },

    addClickListener: {
      value: function (clickFn) {
        if (clickFn) {
          clicked = setClickFunction(
            xScale,
            this.dimensions,
            clickFn,
            this.drawAggWindow
          );
        }
        this._svg.select('#listeners').on("click", clicked);
      }
    },

    removeClickListener: {
      value: function () {
        this._svg.select('#listeners').on("click", null);
      }
    },

    addInteraction: {
      value: function (interaction) {
        if (!interaction) { return; }
        this.addZoomListener(interaction.zoomFn, interaction.zoomEndFn);
        this.addClickListener(interaction.clickFn);
      }
    },

    /**
     * @function
     * @summary Draws an aggWindow at timestamp.
     * @description Left of aggWindow is timeState.at, size is dependent on
     * current aggWindow interval on timeState.
     *
     * TODO: Rasterstore's "day-level aggregated rain intensity data" has
     * discrete one-day/24h intervals (=good), however those intervals are
     * from 8:00 GMT (in the morning) to the next day's 8:00 GMT in the morning
     * (=bad).
     *
     * This doens't play nice with the aggWindow to be drawn, since (for 24h
     * aggregation) this preferably starts on 00:00, and ends 24h later, again
     * on 00:00.
     *
     */
    drawAggWindow: {
      value: function (timestamp, interval, oldDimensions) {
        var height;

        if (this._svg.select('#feature-group').select(".agg-window-group").empty()) {
          height = this._getHeight(this.dimensions);
          aggWindow = this._svg.select('#feature-group').append("g")
            .attr('class', 'agg-window-group');
          aggWindow
            .append("rect")
              .attr("class", "aggwindow-rect")
              .attr("height", height)
              .attr("x", 0)
              .attr("y", 0);
        }

        aggWindow.select('.aggwindow-rect')
          .attr("x", function () {
            return Math.round(xScale(new Date(timestamp)));
          });

        if (oldDimensions && this.dimensions.height < oldDimensions.height) {
          height = this._getHeight(this.dimensions);
          aggWindow.select('.aggwindow-rect')
            .transition()
            .delay(this.transTime)
            .duration(this.transTime)
            .attr("height", height);
        } else if (oldDimensions) {
          height = this._getHeight(this.dimensions);
          aggWindow.select('.aggwindow-rect')
            .transition()
            .duration(this.transTime)
            .attr("height", height);
        }

        if (interval) {
          var width = xScale(new Date(timestamp + (interval))) -
          xScale(new Date(timestamp));
          aggWindow.select('.aggwindow-rect').attr("width", width);
        }
      }
    },

    /**
     * @function
     * @summary Resizes the timeline.
     * @description Makes a deep copy of the old dimensions, updates canvas,
     * updates all elements, redraws axis.
     *
     * @param {object} dimensions object containing, width, height, height per
     *  line of events, height per line of bars and an object containing top,
     *  bottom, left and right padding. All values in px.
     * @param {int} timestamp - timestamp in milliseconds since epoch.
     * @param {interval} interval - aggregation interval in ms.
     * @param {object} features - geojson object with event features.
     * @param {int} nEvents - number of event types (event series).
     */
    resize: {
      value: function (newDimensions, timestamp, interval, nEvents) {
        var oldDimensions = angular.copy(this.dimensions);
        NxtD3.prototype.resize.call(this, newDimensions);
        this.updateElements(oldDimensions, timestamp, interval);
        this._svg = resizeTimelineCanvas(this._svg, oldDimensions, this.dimensions);

        ordinalYScale = makeEventsYscale(initialHeight, this.dimensions);
        xScale.range([0, newDimensions.width - newDimensions.padding.right]);
        drawTimelineAxes(this._svg, xScale, newDimensions);
      }
    },

    /**
     * @function
     * @summary Update all elements to accomadate new dimensions.
     *
     * @param {object} oldDimensions - copy of the old dimensions
     * @param {int} timestamp - timestamp in milliseconds since epoch.
     * @param {interval} interval - aggregation interval in ms.
     */
    updateElements: {
      value: function (oldDimensions, timestamp, interval) {

        if (bars && oldDimensions) {
          updateRectangleElements(bars, xScale, oldDimensions, this.dimensions);
        }

        if (futureIndicator) {
          updateFutureIndicator(
            futureIndicator,
            xScale,
            oldDimensions,
            this.dimensions
          );
        }

        if (aggWindow) {
          this.drawAggWindow(timestamp, interval, oldDimensions);
        }

        if (tickmarks) {
          updateTickmarks(tickmarks, this.dimensions, oldDimensions);
        }

      }
    },

    /**
     * @function
     * @summary Updates, adds or removes all circles in the data object.
     *
     * @param {array} data array of objects:
     *   [{properties.timestamp_end: timestamp,
     *     properties.timestamp_start: timestamp,
     *     properties.event_series_id: event_series id,
     *     geometry.coordinates: [lat, lon]}]
     * @param {integer} order - Order of events.
     * @param {string} slug - Slug of event layer.
     * @param {string} color - Hex color code.
     */
    drawCircles: {
      value: function (data, order, slug, color, aggWindow) {
        circles = drawCircleElements(
          this._svg,
          this.dimensions,
          xScale,
          ordinalYScale,
          data,
          order,
          slug,
          color,
          aggWindow
        );
      }
    },

    drawTickMarks: {
      value: function (data) {
        tickmarks = drawTickMarkElements(this._svg, this.dimensions, data);
      }
    },

    /**
     * @function
     * @summary Updates, adds or removes all bars in the data object.
     *
     * @param {array} data - array of arrays [[bar_timestamp, bar_height]]
     */
    drawBars: {
      value: function (data) {

        /**
         * candidate to replace with Dirk's null checker function.
         */
        if (data.data === 'null') {
          return false;
        }

        var height = this.dimensions.bars;

        var y = this._maxMin(data, '1');
        var options = {scale: 'linear'};
        var yScale = this._makeScale(
          y,
          {min: 0, max: height},
          options
        );
        bars = drawRectElements(
          this._svg, this.dimensions, data, xScale, yScale);
      }
    },

    /**
     * @function
     * @summary Remove bars from timeline.
     */
    removeBars: {
      value: function () {
        drawRectElements(this._svg, this.dimensions, []);
        bars = undefined;
      }
    },

    /**
     * @function
     * @summary Update domain of scale and call functions to update timeline to
     * new scale.
     *
     * @param {int} start - timestamp in ms since epoch.
     * @param {int} end - timestamp in ms since epoch.
     * @param {int} interval - aggregation window in ms.
     */
    zoomTo: {
      value: function (start, end, interval) {
        xScale.domain([new Date(start), new Date(end)]);
        this.addZoomListener();
        this.drawAggWindow(start, interval);
      }
    },

    addZoomListener: {
      value: function (zoomFn, zoomEndFn) {
        if (zoomFn) {
          zoomed = setZoomFunction(
            this._svg,
            this.dimensions,
            xScale,
            zoomFn
          );
        }
        if (zoomEndFn) {
          zoomend = setZoomEndFunction(zoomEndFn);
        }
        this._svg.select('#listeners').call(d3.behavior.zoom()
          .x(xScale)
          .on("zoom", zoomed)
          .on("zoomend", zoomend)
        );

        // Move listener rectangle to the front
        var el = this._svg.select('#listeners').node();
        el.parentNode.appendChild(el);
      }
    }
  });


  /**
   * @function
   * @summary Draw timeline axes.
   *
   * @param {object} svg - timeline svg elements.
   * @param {object} xAxis - D3 axis object.
   * @param {object} dimensions - dimensions object.
   * @param {int} duration - duration in ms.
   */
  var drawTimelineAxes = function (svg, xScale, dimensions, duration) {
    var width = Timeline.prototype._getWidth(dimensions);
    // The actual d3-axis is smaller than the timeline. The scale is copied
    // and transformed to an axis with a restricted range and domain.
    var xAxisScale = xScale.copy();

    var XAXIS_PADDING = 50;

    xAxisScale
      .domain([
        xScale.invert(XAXIS_PADDING),
        xScale.invert(width - XAXIS_PADDING)
      ])
      .range([XAXIS_PADDING, width - XAXIS_PADDING]);

    var xAxis = Timeline.prototype._makeAxis(
      xAxisScale,
      {orientation: "bottom", ticks: 7}
    );

    Timeline.prototype._drawAxes(svg, xAxis, dimensions, false, duration);
    var axisEl = svg.select('#xaxis')
        .attr("class", "x axis timeline-axis");

    addClickToAxisTicks(axisEl.selectAll('text'));
  };

  /**
   * Takes a d3 multiselection of text elements and add click interaction to
   * zoom to rounded dates.
   * @param {object} d3 selection ticks text elements of tick marks.
   */
  var addClickToAxisTicks = function(ticks) {
    ticks
      .each(function (d) {
        if (d.getMinutes() === 0) {
          d3.select(this).attr('class', 'clickable');
        }
      })
      .on('click', zoomToHourDayMonthOrYear);
  };

  /**
   * Gets a date object, typically from a d3 tick mark. If it is a round
   * year|month|day|hour it zooms the timeline and calls zoom callbacks. It does
   * not zoom to minutes and seconds.
   * @param  {date} d
   */
  var zoomToHourDayMonthOrYear = function (d) {
    var end = new Date(d.getTime());
    if (d.getHours() === 0) {
      if (d.getDate() === 1) {
        if (d.getMonth() === 0) {
          xScale.domain([d, end.setYear(d.getFullYear() + 1)]);
        }
        else {
          xScale.domain([d, end.setMonth(d.getMonth() + 1)]);
        }
      }
      else {
        xScale.domain([d, end.setDate(d.getDate() + 1)]);
      }
    }
    else {
      xScale.domain([d, end.setHours(d.getHours() + 1)]);
    }
    zoomed();
    zoomend();
  };

  /**
   * Draw start stop draws the fixed text labels displaying start and stop of
   * the domain.
   *
   * @param  {svg}    svg
   * @param  {scale}  xScale
   * @param  {object} dimensions
   */
  var drawStartStop = function (svg, xScale, dimensions) {
    var format = Timeline.prototype.format,
        height = Timeline.prototype._getHeight(dimensions),
        width = Timeline.prototype._getWidth(dimensions),
        startEl = svg.select('.timeline-start-stop')
          .select('.tick-start').select('text'),
        stopEl = svg.select('.timeline-start-stop')
          .select('.tick-stop').select('text');

    if (!startEl[0][0]) {
      startEl = svg
        .append('g')
        .attr('class', 'timeline-start-stop timeline-axis')
        .attr("transform", "translate(0, " + height + ")")
          .append('g')
          .attr('class', 'tick tick-start')
          .append('text')
            .attr('y', 9)
            .attr('x', dimensions.padding.left)
            .attr('dy', '.71em');

      stopEl = svg.select('.timeline-start-stop')
        .append('g')
          .attr('class', 'tick tick-stop')
          .append('text')
            .attr('y', 9)
            .attr('dy', '.71em');
    }

    startEl
      .text(format(xScale.domain()[0]));
    stopEl
      .text(format(xScale.domain()[1]))
      .attr('x', dimensions.width - dimensions.padding.right
        - stopEl.node().getBBox().width);
  };

  /**
   * @function
   * @summary Creates groups according to dimensions to accomodate all timeline
   * elements
   *
   * @param  {object} svg element to create timeline.
   * @param  {object} dimensions object containing, width, height, height per
   *  line of events, height per line of bars and an object containing top,
   *  bottom, left and right padding. All values in px.
   * @returns {object} svg timeline svg.
   */
  var addElementGroupsToCanvas = function (svg, dimensions) {
    var width = Timeline.prototype._getWidth(dimensions),
    height = Timeline.prototype._getHeight(dimensions);
    // Create group for rain bars
    svg.select('#feature-group').append('g')
      .attr('height', height)
      .attr('width', width)
      .attr('id', 'rain-bar');
    // Create group for circles
    svg.select('#feature-group').append('g')
      .attr('height', height)
      .attr('width', width)
      .attr('id', 'circle-group');
    // Create group for tickmarks
    svg.select('#feature-group').append('g')
      .attr('height', height)
      .attr('width', width)
      .attr('id', 'tickmark-group');

    return svg;

  };

  /**
   * @function
   * @summary Updates the timeline svg. With a delay when getting smaller,
   * without delay when becoming larger.
   *
   * @param  {object} svg - element to create timeline.
   * @param  {object} oldDims - object containing, width, height, height per
   *  line of events, height per line of bars and an object containing top,
   *  bottom, left and right padding. All values in px.
   *  @param {object} newDims - new dimensions, same structure as oldDims.
   */
  var resizeTimelineCanvas = function (svg, oldDims, newDims) {
    var width = Timeline.prototype._getWidth(newDims),
    height = Timeline.prototype._getHeight(newDims);
    if (newDims.height < oldDims.height) {
      svg.transition()
        .delay(Timeline.prototype.transTime)
        .duration(Timeline.prototype.transTime)
        .select("g")
        .attr("transform", "translate(" + newDims.padding.left + ", 0)")
        .select('#xaxis')
        .attr("transform", "translate(0 ," + height + ")");
    } else {
      svg.transition()
        .duration(Timeline.prototype.transTime)
        .select("g")
        .attr("transform", "translate(" + newDims.padding.left + ", 0)")
        .select('#xaxis')
        .attr("transform", "translate(0 ," + height + ")");
    }
    svg.select("#feature-group").selectAll("g")
      .attr("height", height)
      .attr("width", width);
    return svg;
  };

  /**
   * @function
   * @summary Create function that updates all elements to zoom action and
   * calls zoomFn.
   * @description Put all scope specific in the zoom callback from the
   * directive, all the standard (re-)placement of elements in here.
   */
  var setZoomFunction = function (
    svg, dimensions, xScale, zoomFn) {
    var zoomed = function () {
      // might not exist when called programmatically
      if (d3.event.sourceEvent) {
        d3.event.sourceEvent.preventDefault();
      }

      var ONE_HOUR = 1000 * 60 * 60;

      var start = UtilService.getMinTime(xScale.domain()[0].getTime()),
          end = UtilService.getMaxTime(xScale.domain()[1].getTime());

      // Min domain when zooming is ONE_HOUR
      if (start === UtilService.MIN_TIME && end !== UtilService.MAX_TIME) {
        end = end >= start + ONE_HOUR  ? end : start + ONE_HOUR;
      }

      else if (end === UtilService.MAX_TIME && start !== UtilService.MIN_TIME) {
        start = start <= end - ONE_HOUR ? start : end - ONE_HOUR;
      }

      xScale.domain([start, end]);

      drawTimelineAxes(svg, xScale, dimensions);

      if (bars) {
        var barData = bars.data();
        // we need at least 2 elements to calc a new width
        if (barData[1] !== undefined) {
          var newWidth = xScale(barData[1][0]) - xScale(barData[0][0]);
          bars
            .attr("x", function (d) { return xScale(d[0]) - newWidth; })
            .attr('width', newWidth);
        }
      }

      if (futureIndicator) {
        var width = Timeline.prototype._getWidth(dimensions);
        futureIndicator
          .attr('x', xScale(Date.now()));
      }

      if (circles) {
        var xOneFunction = function (d) {
          return xScale(parseFloat(d.timestamp) - (parseFloat(d.interval) / 2));
        };

        d3.select("#circle-group").selectAll("circle")
          .attr("cx", xOneFunction);
      }

      if (tickmarks) {
        updateTickmarks(tickmarks, dimensions);
      }

      if (zoomFn) {
        zoomFn(xScale);
      }
    };

    return zoomed;
  };

  /**
   * @function
   * @summary Create zoomend.
   */
  var setZoomEndFunction = function (zoomEndFn) {
    var zoomend = function () {
      zoomEndFn();
    };
    return zoomend;
  };

  /**
   * @function
   * @summary Creates click function.
   * @description Creates click function. If default is prevented, the click
   * was a zoom.
   */
  var setClickFunction = function (xScale, dimensions, clickFn, drawAggWindow) {
    var clicked = function () {
      // Check whether user is dragging instead of clicking
      if (!d3.event.defaultPrevented) {
        var x = d3.mouse(this)[0] - dimensions.padding.left;
        var ts = xScale.invert(x);
        clickFn(ts, dimensions);
      }
    };
    return clicked;
  };

  /**
   * @function
   * @summary Moves rectangle elements to right position relative to the
   * timeline svg and xaxis.
   * @description Everything to the svg is relative to the top left corner, if
   * the timeline grows, the bars need to move further down. The amount is
   * computed from the difference between the old and new dimensions and the
   * move is delayed depending on the growth or shrinkage of the timeline.
   */
  var updateRectangleElements = function (rectangles, xScale, oldDimensions,
                                          newDimensions) {


    var getBarHeight = function (d) {
      return d[1] ? yScale(d[1]) : 0;
    };

    // UPDATE
    // Update old elements as needed.
    if (rectangles[0].length > 0) {
      var barHeight = newDimensions.bars,
          y = Timeline.prototype._maxMin(rectangles.data(), '1'),
          options = {scale: 'linear'},
          newHeight = Timeline.prototype._getHeight(newDimensions),
          oldHeight = Timeline.prototype._getHeight(oldDimensions),
          heightDiff = newHeight - oldHeight,
          yScale = Timeline.prototype._makeScale(
            y,
            {min: 0, max: barHeight},
            options),
            barWidth = Number(rectangles.attr('width'));

      if (heightDiff < 0) {

        rectangles.transition()
          .duration(Timeline.prototype.transTime)
          .delay(Timeline.prototype.transTime)
          .attr("height", getBarHeight)
          .attr("y", function (d) {
            return newHeight - getBarHeight(d);
          })
          .attr("x", function (d) {
            return xScale(d[0]) - barWidth;
          });

      } else {
        rectangles.transition()
          .duration(Timeline.prototype.transTime)
          .attr("height", getBarHeight)
          .attr("y", function (d) {
            return newHeight - getBarHeight(d);
          })
          .attr("x", function (d) {
            return xScale(d[0]) - barWidth;
          });
      }
    }
  };

  /**
   * @function
   * @summary update future indicator.
   *
   * @param {object} futureIndicator - D3 selection.
   * @param {object} xScale - D3 scale.
   * @param {object} oldDimensions - previous timeline dimensions object.
   * @param {object} dimensions - timeline dimensions object.
   */
  var updateFutureIndicator = function (
    futureIndicator,
    xScale,
    oldDimensions,
    dimensions
    ) {

    var height = Timeline.prototype._getHeight(dimensions),
        width = Timeline.prototype._getWidth(dimensions);

    futureIndicator
      .attr('x', xScale(Date.now()));

    if (dimensions.height < oldDimensions.height) {
      futureIndicator
       .transition()
       .delay(Timeline.prototype.transTime)
       .duration(Timeline.prototype.transTime)
       .attr('height', height);
    } else {
      futureIndicator
       .transition()
       .duration(Timeline.prototype.transTime)
       .attr('height', height);
    }
  };
  var updateTickmarks = function (tickmarks, dimensions, oldDimensions) {
    var height = Timeline.prototype._getHeight(dimensions),
        TICKMARK_HEIGHT = 5;

    // update horizontal
    tickmarks.attr("x", function (d) { return xScale(d); });

    // update vertical
    if (oldDimensions && dimensions.height < oldDimensions.height) {
      tickmarks.transition()
        .delay(Timeline.prototype.transTime)
        .duration(Timeline.prototype.transTime)
        .attr("y", height - TICKMARK_HEIGHT);
    }

    else if (oldDimensions &&  dimensions.height > oldDimensions.height) {
      tickmarks.transition()
        .duration(Timeline.prototype.transTime)
        .attr("y", height - TICKMARK_HEIGHT);
    }
  };

  /**
   * @function
   * @summary Draws rectangular tickmarks for every timestamp in data array.
   *
   * @param {object} svg - timeline svg object.
   * @param {object} dimensions - timeline dimensions object.
   * @param {integer []} data - list of timestamps in ms.
   *
   * @returns {object} d3 selection object with tickmarks for each timestamp.
   */
  var drawTickMarkElements = function (svg, dimensions, data) {
    var height = Timeline.prototype._getHeight(dimensions),
        TICKMARK_HEIGHT = 5,
        TICKMARK_WIDTH = 2;

    var group = svg
      .select("g")
      .select("#tickmark-group");

    // DATA JOIN
    // Join new data with old elements, based on the timestamp.
    tickmarks = group.selectAll("rect")
      .data(data, function  (d) { return d; });

    // UPDATE
    tickmarks.transition()
      .delay(Timeline.prototype.transTime)
      .duration(Timeline.prototype.transTime)
      .attr("y", height - TICKMARK_HEIGHT)
      .attr("x", function (d) { return xScale(d); });

    // ENTER
    tickmarks.enter().append("rect")
      .attr("class", "tickmark")
      .attr("y", height)
      .attr("width", TICKMARK_WIDTH)
      .attr("height", 0)
    .transition()
      .delay(Timeline.prototype.transTime)
      .duration(Timeline.prototype.transTime)
      .attr("x", function (d) { return xScale(d); })
      .attr("y", height - TICKMARK_HEIGHT)
      .attr("height", TICKMARK_HEIGHT);

    // EXIT
    // Remove old elements as needed.
    tickmarks.exit()
      .transition()
      .delay(Timeline.prototype.transTime)
      .duration(Timeline.prototype.transTime)
      .attr("y", height)
      .attr("height", 0)
      .remove();

    return tickmarks;

  };

  /**
   * @function
   * @summary Draws horizontal line elements according to a d3 update pattern.
   *
   * @param {object} svg - timeline svg object.
   * @param {object} dimensions - timeline dimensions object.
   * @param {object} xScale - D3 scale object.
   * @param {object} yScale - D3 scale object.
   * @param {object} data - geojson data structure:
   *   [{properties.timestamp_end: timestamp,
   *     properties.timestamp_start: timestamp,
   *     properties.event_series_id: event_series id,
   *     geometry.coordinates: [lat, lon]}]
   * @param {int} order - Order of data (which level to draw in timeline).
   * @param {string} slug - slug of event series.
   * @param {string} color - Hex color code.
   */
  var drawCircleElements = function (
    svg, dimensions, xScale, yScale, data, order, slug, color, aggWindow) {

    var MIN_CIRCLE_SIZE = 3,
        MAX_COUNT = 100;

    var xOneFunction = function (d) {
      return xScale(parseFloat(d.timestamp) - (parseFloat(aggWindow) / 2));
    };

    var yFunction = function (d) { return yScale(order); };

    var rFunction = function (d) {
      return UtilService.lin2log(
        d.count, MIN_CIRCLE_SIZE, MAX_CIRCLE_SIZE, 1, MAX_COUNT);
    };

    // if data exists, check if group is available for this series and create
    // if no data, remove circles
    if (data !== undefined) {
      var group = svg
                    .select("g")
                    .select("#circle-group")
                    .select("#" + slug);
      if (!group[0][0]) {
        group = svg.select("g").select("#circle-group").append("g")
          .attr("id", slug);
      }

      // DATA JOIN
      // Join new data with old elements, based on the id value.
      circles = group.selectAll("circle")
        .data(data, function  (d) { return d.timestamp; });
    } else if (data === undefined) {
      // if no data is defined, remove all groups
      var groups = svg.select("g").select("#circle-group").selectAll("g");
      groups.remove();

      return;
    }

    // UPDATE
    // Update old elements as needed.
    circles.transition()
      .attr("stroke", color)
      .attr("fill", color)
      .attr("cx", xOneFunction)
      .attr("cy", yFunction)
      .attr("r", rFunction);

    // ENTER
    // Create new elements as needed.
    circles.append("g");
    circles.enter().append("circle")
      .attr("class", "event")
      .attr("fill", color)
      .attr("stroke", color)
    .transition()
      .delay(Timeline.prototype.transTime)
      .duration(Timeline.prototype.transTime)
      .attr("cx", xOneFunction)
      .attr("cy", yFunction)
      .attr("r", rFunction);

    // EXIT
    // Remove old elements as needed.
    circles.exit()
    .transition()
      .duration(Timeline.prototype.transTime)
      .delay(Timeline.prototype.transTime)
      .attr("stroke-width", 0)
      .style("fill-opacity", 0)
      .remove();

    return circles;
  };

  /**
   * @function
   * @summary Draws bar elements according to a d3 update pattern.
   */
  var drawRectElements = function (svg, dimensions, data, xScale, yScale) {

    var height = Timeline.prototype._getHeight(dimensions),
    // Join new data with old elements, based on the timestamp.
    bars = svg.select("g").select('#rain-bar').selectAll('.bar-timeline')
        .data(data, function  (d) { return d[0]; });

    var barWidth;
    if (data.length > 1) {
      barWidth = xScale(data[1][0]) - xScale(data[0][0]);
    } else {
      barWidth = 0;
    }

    var getBarHeight = function (d) {
      return d[1] ? yScale(d[1]) : 0;
    };

    // UPDATE
    // Update old elements as needed.
    bars.transition()
      .duration(Timeline.prototype.transTime)
      .attr("x", function (d) { return xScale(d[0]) - barWidth; })
      .attr('width', barWidth)
      .attr("height", getBarHeight)
      .attr("y", function (d) { return height - yScale(d[1]); });

    // ENTER
    // Create new elements as needed.
    bars.enter().append("rect")
      .attr("class", "bar-timeline")
      .attr("x", function (d) {
        return xScale(d[0]) - barWidth;
      })
      .attr('width', barWidth)
      .attr("height", 0)
      .attr("y", height)
      .transition()
      .delay(Timeline.prototype.transTime)
      .duration(Timeline.prototype.transTime)
      .attr("height", getBarHeight)
      .attr("y", function (d) { return height - yScale(d[1]); });

    // EXIT
    // Remove old elements as needed.
    bars.exit()
      .transition()
      .duration(Timeline.prototype.transTime)
      .attr("y", height)
      .attr("height", 0)
      .remove();

    var barsEl = svg.select("g").select('#rain-bar').node();
    barsEl.parentNode.insertBefore(barsEl, barsEl.parentNode.firstChild);

    return bars;
  };


  /**
   * @function
   * @summary Returns a d3 scale to place events vertically in circles above
   * each other.
   *
   * @param  {int} iniH initial height of the timeline in px.
   * @param  {object} dims current dimensions of the timeline.
   */
  var makeEventsYscale = function (iniH, dims) {
    return function (order) {
      return dims.events * order - MAX_CIRCLE_SIZE;
    };
  };

  return Timeline;

}]);

'use strict';

/**
 * TimeLineDirective
 * @memberOf app
 *
 * @summary Timeline directive.
 *
 * @description Timeline directive.
 */
angular.module('lizard-nxt')
  .directive('timeline',
             ["$q",
              "$timeout",
              "RasterService",
              "UtilService",
              "Timeline",
              "VectorService",
              "DataService",
              "EventAggregateService",
              "State",
              function ($q,
                        $timeout,
                        RasterService,
                        UtilService,
                        Timeline,
                        VectorService,
                        DataService,
                        EventAggregateService,
                        State) {

  var link = function (scope, element, attrs, timelineCtrl) {

    var timelineSetsTime = false,
        timelineSetsAt = false,

        showTimeline = true, // Is set by user clicking data label, when true
                              // timeline is shown.

        dimensions = {
          width: UtilService.getCurrentWidth(element),
          height: 45,
          events: 35,
          bars: 35,
          padding: {
            top: 0,
            right: 0,
            bottom: 20,
            left: 0
          }
        },
        start = State.temporal.start,
        end = State.temporal.end,
        el = element.find('svg');

    var interaction = {

      /**
       * @function
       * @summary Update timeState on zoom.
       *
       * @param {object}  scale D3 xScale.
       */
      zoomFn: function (scale) {

        scope.$apply(function () {
          timelineSetsTime = true;
          State.temporal.timelineMoving = true;
          State.temporal.start = scale.domain()[0].getTime();
          State.temporal.end   = scale.domain()[1].getTime();

          State.temporal.at = UtilService.roundTimestamp(
            State.temporal.at,
            State.temporal.aggWindow,
            false
          );
        });

        timeline.drawAggWindow(State.temporal.at, State.temporal.aggWindow);
      },

      /**
       * @function
       * @summary Update zoomEnded to trigger new call for new timeline data.
       */
      zoomEndFn: function () {
        scope.$apply(function () {
          getTimeLineData();
          State.temporal.timelineMoving = false;
        });
      },

      /**
       * @function
       * @description Update timeState.at to click location in timebar. Snaps
       * time to closest interval.
       *
       * @param {object} event - D3 event.
       * @param {object} scale - D3 scale.
       * @param {object} dimensions - object with timeline dimensions.
       */
      clickFn: function (timestamp, dimensions) {
        scope.$apply(function () {
          timelineSetsAt = true;
          State.temporal.at = UtilService.roundTimestamp(
            timestamp,
            State.temporal.aggWindow
          );
          timeline.drawAggWindow(State.temporal.at, State.temporal.aggWindow);
        });
      },
    };


    // keep track of events in this scope
    scope.events = {nEvents: 0, slugs: []};

    // Initialise timeline
    var timeline = new Timeline(el[0], dimensions, start, end, interaction);

    setTimeout(interaction.zoomEndFn, 250);
    // HELPER FUNCTIONS

    /**
     * @function
     * @description Redetermines dimensions of timeline and calls resize.
     *
     * @param {object} newDim - object with new timeline dimensions.
     * @param {object} dim - object with old timeline dimensions.
     * @param {int} nEventTypes - number of event types (event series).
     */
    var updateTimelineSize = function (nEventTypes) {
      var eventHeight,
          newDim = angular.copy(timeline.dimensions);

      newDim.height = dimensions.padding.bottom
        + dimensions.padding.top
        + nEventTypes * dimensions.events;

      if (getTimelineLayers(DataService.layerGroups).rain) {
        newDim.height += dimensions.bars;
      }

      newDim.height = Math.max(newDim.height, dimensions.height);

      if (showTimeline) {
        element[0].style.height = newDim.height + 5 + 'px'; // 5px margins
      }


      timeline.resize(
        newDim,
        State.temporal.at,
        State.temporal.aggWindow,
        nEventTypes
      );

      if (Timeline.onresize) {
        Timeline.onresize(newDim);
      }

    };

    /**
     * @function
     * @summary Temporary function to get relevant timeline layers from active
     *  layers.
     * @description Loops over layergroups and gets for each active layergroup
     * the vector and rain intensity layer. Those layers are used to draw data
     * in the timeline.
     *
     * TODO: refactor to query layerGroups by data type (event, raster, object)
     *
     * @param {object} layerGroups - NXT layerGroups object.
     * @returns {object} with: events (list of layers) and rain (nxtLayer).
     */
    var getTimelineLayers = function (layerGroups) {
      var timelineLayers = {events: {layers: [], slugs: []},
                            rasterStore: {layers: []},
                            rain: undefined};

      if (State.context !== 'dashboard') {
        angular.forEach(layerGroups, function (layergroup) {
          if (layergroup.isActive()) {
            angular.forEach(layergroup._dataLayers, function (layer) {
              if (layer.format === "Vector") {
                timelineLayers.events.layers.push(layer);
                timelineLayers.events.slugs.push(layer.slug);
              } else if (layer.format === "Store" && State.context !== 'dashboard') {
                if (layer.slug !== "rain") {
                  timelineLayers.rasterStore.layers.push(layer);
                } else if (layer.slug === "rain") {
                  timelineLayers.rain = layer;
                }
             }
            });
          }
        });
      }

      return timelineLayers;
    };

    /**
     * @function
     * @summary Get data for events and rain.
     * @description Get data for events and rain. If data exists (relevant
     * layers are active), data is drawn in timeline. Timelineheight is updated
     * accordingly.
     *
     * TODO: Now data is fetched via layerGroup loop logic (getTimelineLayers).
     * That will change later when we set data.
     */
    var getTimeLineData = function () {
      // NOTE: remember which layers *were* active? So we can do stuff with
      // turning off data (eg tickmarks).
      var timelineLayers = getTimelineLayers(DataService.layerGroups),
          context = {eventOrder: 1,
                     nEvents: scope.events.nEvents};

      // vector data (for now only events)
      if (timelineLayers.events.layers.length > 0 &&
        State.spatial.bounds.isValid()) {
        scope.events.nEvents = timelineLayers.events.layers.length;

        // update inactive groups with nodata so update function is called
        // appropriately.
        angular.forEach(scope.events.slugs, function (slug) {
          if (timelineLayers.events.slugs.indexOf(slug) === -1) {
            timeline.drawCircles([], scope.events.nEvents, slug);
          }
        });

        // update slugs on scope for housekeeping
        scope.events.slugs = timelineLayers.events.slugs;
        getEventData();
      } else {
        scope.events.nEvents = 0;
        timeline.drawCircles(undefined, scope.events.nEvents);
      }

      if (State.spatial.bounds.isValid()) { // no business here when invalid
                                            // bounds.

        if (timelineLayers.rain !== undefined) {
          getTemporalRasterData(timelineLayers.rain,
                                timelineLayers.events.length);
        } else {
          timeline.removeBars();
        }
        if (timelineLayers.rasterStore.layers.length > 0) {
          angular.forEach(timelineLayers.rasterStore.layers, function (layer) {
            getTemporalRasterDates(layer);
          });
        } else {
          timeline.drawTickMarks([]);
        }

      }

      updateTimelineSize(scope.events.nEvents);
    };

    /**
     * @function
     * @summary get data for event layers and update timeline.
     * @description get data for event layers and update timeline.
     */
    var getEventData = function () {
      // create context for callback function, reset eventOrder to 1.
      var context = {
        eventOrder: 1,
        nEvents: scope.events.nEvents,
        slugs: scope.events.slugs
      };

      var draw = function (response) {

        if (response && response.data) {
          // Add it to the timeline
          var data = EventAggregateService.aggregate(
            response.data,
            State.temporal.aggWindow
          );

          timeline.drawCircles(
            data,
            context.eventOrder,
            response.layerGroupSlug,
            response.color,
            State.temporal.aggWindow
          );
          context.eventOrder++;
        }
      };
      // Get data with type === 'Event'
      DataService.getData('timeline', {
        geom: State.spatial.bounds,
        start: State.temporal.start,
        end: State.temporal.end,
        type: 'Event'
      }).then(null, null, draw);
    };


    /**
     * @function
     * @summary get data for temporal raster layers.
     * @description  get data for temporal raster. If it gets a response updates
     * timeline height and draws bars in timeline.
     *
     * @param {object} rasterLayer - rasterLayer object.
     */
    var getTemporalRasterData = function (rasterLayer) {

      var start = State.temporal.start,
          stop = State.temporal.end,
          bounds = State.spatial.bounds;

      // Has it's own deferrer to not conflict with
      // other deferrers with the same layerSlug
      RasterService.getData(
        'timelineData',
        rasterLayer,
        {
          geom: bounds,
          start: start,
          end: stop,
          agg: rasterLayer.aggregationType,
          aggWindow: State.temporal.aggWindow,
          deferrer: {
            origin: 'timeline_' + rasterLayer.slug,
            deferred: $q.defer()
          }
        }
      )
      .then(
        function (response) {
          if (response && response !== 'null' && response.data !== null) {
            timeline.drawBars(response.data);
          }
        }
      );
    };

    /**
     * @function
     * @summary get date array for temporal raster layers.
     * @description  get date array for temporal raster. If it gets a response
     * plots a tickmark in the timeline for every date.
     *
     * NOTE: refactor this function with getTemporalRasterData to use
     * dataService.
     *
     * @param {object} rasterLayer - rasterLayer object.
     */
    var getTemporalRasterDates = function (rasterLayer) {

      var start = State.temporal.start,
          stop = State.temporal.end,
          bounds = State.spatial.bounds,
          dates = [];

      var draw = function () {
        timeline.drawTickMarks(dates);
      };

      DataService.getData('timelineDates', {
        start: State.temporal.start,
        end: State.temporal.end,
        geom: State.spatial.bounds.getCenter(),
        truncate: true,
        exclude: 'rain'
      }).then(draw, null, function (response) {
        if (response && response !== 'null') {
          dates = dates.concat(response.data);
        }
      });

    };

    // END HELPER FUNCTIONS

    scope.timeline.toggleTimeCtx = function () {
      scope.timeline.toggleTimelineVisiblity();
      scope.transitionToContext(State.context === 'map' ? 'dashboard' : 'map');
    };

    // WATCHES

    /**
     * Updates area when user moves map.
     */
    scope.$watch(State.toString('spatial.bounds'), function (n, o) {
      if (n === o) { return true; }
      getTimeLineData();
    });

    /**
     * Updates area when users changes layers.
     */
    scope.$watch(State.toString('layerGroups.active'), function (n, o) {
      if (n === o) { return true; }
      getTimeLineData();
    });

    /**
     * Timeline is updated when something other than the timeline
     * updates the temporal extent.
     */
    scope.$watch(State.toString('temporal.timelineMoving'), function (n, o) {
      if (n === o) { return true; }
      if (!timelineSetsTime) {

        timeline.zoomTo(
          State.temporal.start,
          State.temporal.end,
          State.temporal.aggWindow
        );
        getTimeLineData();
      }
      timelineSetsTime = false;
    });

    /**
     * Update aggWindow element when timeState.at changes.
     */
    scope.$watch(State.toString('temporal.at'), function (n, o) {
      if (!timelineSetsAt) {
        // update timeline when time-controller changes temporal.at state
        timeline.drawAggWindow(State.temporal.at, State.temporal.aggWindow);
      }
      timelineSetsAt = false;
    });

    /**
     * Round timeState.at when animation stops.
     */
    scope.$watch(State.toString('temporal.playing'), function (n, o) {
      if (n === o || n) { return true; }
      State.temporal.at = UtilService.roundTimestamp(
        State.temporal.at + State.temporal.aggWindow / 2,
        State.temporal.aggWindow,
        false
      );
    });


    /**
     * The timeline can be too early on initialization.
     * The leaflet events are not even started loading,
     * so the call returns an empty array.
     *
     * If nobody touches nothing, that means the timeline
     * won't show events, whilst they are being drawn
     * on the map.
     *
     * This evenListener ensures a retrieval of data
     * after the browser is done doing requests.
     */
    window.addEventListener('load', getTimeLineData);

    var resize = function () {

      var newWidth = UtilService.getCurrentWidth(element);

      scope.$apply(function () {
        timeline.dimensions.width = newWidth;
        timeline.resize(
          timeline.dimensions,
          State.temporal.at,
          State.temporal.aggWindow,
          scope.events.nEvents // TODO: get nEvents from somewhere
        );
      });
    };

    /**
     * Update timeline when browser window is resized.
     */
    window.addEventListener('resize', resize);

    /**
     * Remove listeners.
     */
    scope.$on('$destroy', function () {
      window.removeEventListener('resize', resize);
      window.removeEventListener('load', getTimeLineData);
      timeline.destroy();
    });

    // END WATCHES

  };

  return {
    replace: true,
    restrict: 'E',
    link: link,
    templateUrl: 'timeline/timeline.html'
  };
}]);

'use strict';

/**
 * @class angular.module('lizard-nxt')
  .TimeLineCtrl
 * @memberOf app
 *
 * @summary TimeLine controller.
 *
 * @TODO : Isolate scope. Use scope for data binding to DOM elements. No need to
 *         do this on master scope.
 *
 * @desc Manipulates timeState model, animation controls.
 *
 */
angular.module('lizard-nxt')
.controller('TimeCtrl', [

  "$rootScope",
  "$scope",
  "$q",
  'UtilService',
  'DataService',
  'State',

  function (

    $rootScope,
    $scope,
    $q,
    UtilService,
    DataService,
    State) {

    window.requestAnimationFrame = window.requestAnimationFrame ||
                                   window.mozRequestAnimationFrame ||
                                   window.webkitRequestAnimationFrame ||
                                   window.msRequestAnimationFrame;

    var DEFAULT_NUMBER_OF_STEPS = 2000, // Small for humans to perceive as smooth.
        currentInterval = State.temporal.end - State.temporal.start,
        timeStep = Infinity, // Will be overwritten to
                             // currentInterval / DEFAULT_NUMBER_OF_STEPS
                             // Or the smallest temporalResolution of an active
                             // temporal layer.
        minLag = 0, // Let the browser determine the max speed using
                    // requestAnimationFrame.
        promise, // Is created when syncing time and resolves when all datalayers
                 // finished buffering and redrawing;
        timeOut; // runs for minLag of milliseconds before waiting for the promise
                 // to resolve and re-syncing the data layers to the new time and
                 // making a new step when animation is playing.


    this.state = State;

    Object.defineProperty(this, 'showContextSwitch', {
      get: function () {
        return State.layerGroups.active.some(function (slug) {
          return DataService.layerGroups[slug].temporal
            && DataService.layerGroups[slug].isActive();
        });
      }
    });

    /**
     * Keep an eye out for temporal layers that require the animation to go
     * with a lower speed so wms requests can keep up and run more smooth if the
     * temporalResolution equals or is a multiplication of  the stepSize.
     */
    $scope.$watch(State.toString('layerGroups.active'), angular.bind(this, function (n, o) {
      if (n === o) { return; }
      configAnimation.call(this);
    }));

    /**
     * sync data layers to new timestate and redo the animation configuration
     * since currentInterval has changed.
     */
    $scope.$watch(State.toString('temporal.timelineMoving'), angular.bind(this, function (n, o) {
      if (n === o) { return true; }
      if (!State.temporal.timelineMoving) {
        configAnimation.call(this);
      }
    }));

    /**
     * Sync to new time and trigger a new step when animation.playing is true.
     *
     * Layergroups need a time synced to them before being toggled. Therefore, no
     * n === o return here.
     */
    $scope.$watch(State.toString('temporal.at'), function (n, o) {
      if (n === o) { return true; }
      syncTimeWrapper(State.temporal);
    });

    /**
     * @description sets the timeStep and minLag on the basis of layergroups and
     *              their temporalResolution. The temporal layer with the smallest
     *              temporalResolution is leading.
     */
    var configAnimation = function () {
      currentInterval = State.temporal.end - State.temporal.start;
      timeStep = Infinity;
      minLag = 0;

      var activeTemporalLgs = false;

      angular.forEach(State.layerGroups.active, function (lgSlug) {
        var lg = DataService.layerGroups[lgSlug];

        if (lg.temporal) {
          // add some empty stuff to determine
          // whether animation is possible.
          activeTemporalLgs = true;
        }

        if (lg.temporal && lg.temporalResolution !== 0 && lg.temporalResolution < timeStep) {
          timeStep = lg.temporalResolution;
          // To accomadate dynamic temporal resolutions check all maplayers and
          // switch to coarser resolution if found. This is used by the rain.
          angular.forEach(lg.mapLayers, function (layer) {
            if (layer._temporalResolution > timeStep) {
              timeStep = layer._temporalResolution;
            }
          });
          // equals to 250 ms for 5 minutes, increases for larger timeSteps untill
          // it reaches 1 second between frames for timeSteps of > 20 minutes.
          minLag = timeStep / 1200 > 240 ? timeStep / 1200 : 250;
          minLag = minLag > 1000 ? 1000 : minLag;
        }
      });

      this.animatable = activeTemporalLgs;
      // Do not continue animating when there is nothing to animate.
      if (!this.animatable) {
        State.temporal.playing  = false;
      }

      // If no temporal layers were found, set to a default amount.
      if (timeStep === Infinity) {
        timeStep = currentInterval / DEFAULT_NUMBER_OF_STEPS;
      }
    };

    /**
     * @function
     * @summary Toggle animation playing.
     * @description Set State.temporal.animation.playing to true or false.
     *
     * @param {} toggle - .
     */
    this.playPauseAnimation = function (toggle) {
      if (State.temporal.playing || toggle === "off") {
        State.temporal.playing = false;
      } else {
        State.temporal.playing = true;
        window.requestAnimationFrame(step);
      }
    };

    /**
     * @function
     * @summary Push animation 1 step forward when Nxt is ready.
     * @description Set new timeState.at based on stepSize. If current
     * timeSate.at is outside current temporal extent, start animation at start
     * of temporal extent.
     */
    var step =  function () {
      // Make a new step.
      $scope.$apply(function () {
        State.temporal.at += timeStep;
      });

      // reset timeState.at if out of temporal bounds
      if (State.temporal.at >= State.temporal.end) {
        $scope.$apply(function () {
          State.temporal.at = UtilService.roundTimestamp(
            State.temporal.start,
            State.temporal.aggWindow,
            true // round up to prevent getting stuck at the start.
          );
        });
      }
    };

    /**
     * @description creates a promise by calling syncTime and toggles buffer state
     *              accordingly.
     * @param  {object} timeState nxt timeState object
     */
    var syncTimeWrapper = function (timeState) {
      var defer = $q.defer();

      if (timeState.playing) {
        progressAnimation(defer.promise);
      }
      if (State.layerGroups.timeIsSyncing) {
        var watch = $scope.$watch(
          function () { return State.layerGroups.timeIsSyncing; },
          function (loading) {
            if (loading === false) {
              defer.resolve();
              watch();
            }
          }
        );
      } else {
        defer.resolve();
      }
    };

    /**
     * @description progresses animation when provided promiss finishes and the
     *              minLag has passed. Sets buffering when he promise is not re-
     *              solved after minLag.
     * @param  {object} finish
     */
    var progressAnimation = function (finish) {
      // Remove any old timeout
      clearTimeout(timeOut);
      // when the minLag has passed.
      timeOut = setTimeout(function () {
        // And the layergroups are all ready.
        finish.then(function () {
          // And we are still animating.
          if (State.temporal.playing) {
            // And the browser is ready. GO!
            window.requestAnimationFrame(step);
          }
        });
      }, minLag);
    };

    /**
     * @function
     * @summary Move timeState.end to now.
     */
    this.zoomToNow = function () {

      var now = Date.now(),
          fullInterval = State.temporal.end - State.temporal.start,
          oneFifthInterval = Math.round(fullInterval * 0.2),
          fourFifthInterval = Math.round(fullInterval * 0.8);

      State.temporal.start = now - fourFifthInterval;
      State.temporal.end = now + oneFifthInterval;
      State.temporal.at = UtilService.roundTimestamp(now,
                                                     State.temporal.aggWindow,
                                                     false);
      UtilService.announceMovedTimeline(State);
    };

    /**
     * @function
     * @summary Zooms time in or out.
     * @description multiplies or divides current time resolution by
     * ZOOMFACTOR depending on zooming in or out. Updates start and end
     * of timeState accordingly and sets new resolution on timeState.
     *
     * @param {string} action - 'in' or not 'in'.
     */
    this.zoom = function (action) {

      var ZOOMFACTOR = 2,
          diff = (State.temporal.end - State.temporal.start) / ZOOMFACTOR / 2,

          change = action === 'in' ? diff : - diff;

      State.temporal.start = UtilService.getMinTime(
        State.temporal.start + change
      );
      State.temporal.end = UtilService.getMaxTime(
        State.temporal.end - change
      );

      UtilService.announceMovedTimeline(State);

    };

    this.formatDatetime = function () {
      switch (State.temporal.aggWindow) {
      case 300000:
        return 'dd-MM-yyyy HH:mm';
      case 3600000:
        return 'dd-MM-yyyy HH:mm';
      case 86400000:
        return 'dd-MM-yyyy';
      case 2635200000:
        return 'MM-yyyy';
      default:
        throw new Error("Unknown aggWindow: " + this.state.aggWindow);
      }
    };
  }
]);

/**
 * @name Graph
 * @class Graph
 * @memberOf app
 *
 * @summary Service to create and update a graph
 *
 * @description Inject "Graph" and call new graph(<args>) to create a
 * graph. Currently the graph supports lines, bars, donut, and a flat
 * donut called horizontal stacked bar. The user may interact with
 * the graph through click and hover functions. Graph inherits from
 * NxtD3, a lower level d3 helper class.
 *
 * NOTE: The donut code is currently not used anywhere in lizard-client.
 *
 * Everything in the graphs is animated according to NxtD3.transTime.
 */
angular.module('lizard-nxt')
  .factory("Graph", ["$timeout", "NxtD3", "ChartContainer", "UtilService",
  function ($timeout, NxtD3, ChartContainer, UtilService) {

  var MIN_WIDTH_INTERACTIVE_GRAPHS = 400; // Only graphs bigger get mouseover
                                          // and click interaction.

  /**
   * @constructor
   *
   * @memberOf Graph
   * @param {object} element    svg element for the graph.
   * @param {object} dimensions object containing, width, height and
   *                            an object containing top,
   *                            bottom, left and right padding.
   *                            All values in px.
   * @param {object} xDomain - override the domain for the graphs.
   */
  function Graph(element, dimensions, xDomain) {
    NxtD3.call(this, element, dimensions, xDomain);
    this._svg = this._createDrawingArea();
    this._containers = [];
  }

  Graph.prototype = Object.create(NxtD3.prototype, {
    constructor: Graph
  });

  Graph.prototype.resize = function (newDim) {
    NxtD3.prototype.resize.call(this, newDim);
    this._svg = this._createDrawingArea();
    this._svg.selectAll('.axis').remove();

    // reposition labels
    drawLabel(this._svg, this.dimensions, undefined, true);
    drawLabel(this._svg, this.dimensions, undefined, false);
  };

  /**
   * @function
   * @memberOf Graph
   * @param {object} content - Array of object with data, keys, unit, color,
   *                           xlabel and if multi line: id.
   *        data   Currently supports the format:
   *                        [
   *                          collection,
   *                          ...,
   *                        ]
   *        keys   Mapping between x and y values of data object:
   *                        example: {x: 0, y: 1}
   *        unit   string   will be
   *                        mapped to y axis and the label of the y axis.
   *        color  string   Color.
   *        xLabel stirng   Label for x axis.
   *        id     string or inter identiefier for charts in the graph.
   *
   * @param {boolean} temporal to draw an time axis or not.
   * @param {boolean} transitioning to draw a subset of data now, and the full
   *                                set after a timeout if drawline is not
   *                                called again before the timeout finishes.
   *                                Use transitioning = true when callig this
   *                                function many times as a result of a user
   *                                induced action.
   * @description           Draws multiple line, if necessary sets up the graph,
   *                        if necessary modifies domain and redraws axis,
   *                        and draws the line according to the data object.
   *                        Currently only a linear scale on the x-axis is
   *                        supported.
   */
  Graph.prototype.drawLine = function (content, temporal, transitioning) {
    var graph = this;
    graph._yPerUnit = {}; // one line graph has a y -scale and axis per unit in
                          // content.

    // Get x scale and axis for temporal domain.
    var range = graph._makeRange('x', graph.dimensions);
    var width = graph._getWidth(graph.dimensions);
    var scale;
    if (temporal) {
      scale = graph._makeScale(
        {max: graph._xDomain.end, min: graph._xDomain.start},
        range,
        {scale: 'time'}
      );
    } else {
      // If not temporal content has lenght 1 and is linear.
      var xMinMax = this._maxMin(content[0].data, content[0].keys.x);
      scale = graph._makeScale(
        xMinMax,
        range,
        {scale: 'linear'}
      );
      drawLabel(graph._svg, graph.dimensions, content[0].xLabel, false);
    }
    var axis = graph._makeAxis(scale, {orientation: 'bottom'}, graph.dimensions);
    graph._xy = {
      x: {
        scale: scale,
        axis: axis
      }
    };

    // Draw x axis
    this._drawAxes(
      this._svg,
      graph._xy.x.axis,
      this.dimensions,
      false, // is not a y axis.
      0 // no transition of x axis
    );

    // Filter out old charts.
    graph._containers = graph._containers.filter(function (chart) {
      var present = _.some(content, function (item) {
        return chart.id === item.id;
      });
      if (!present && chart.path) {
        chart.path.remove(); // Remove path from graph.
      }
      return present;
    });

    // Update or create charts with content.
    content.forEach(function (item, index) {
      // Update existing.
      if (graph._containers[index]) {
        var chartContainer = graph._containers[index];
        chartContainer.setContentUpdateY(item); // refresh data and min, max
        if (chartContainer.path) {
          chartContainer.path.remove(); // Redraw every path, to prevent mixups.
          chartContainer.path = null; // Redraw every path, to prevent mixups.
        }
      }

      // Create new ones
      else {
        graph._containers[index] = new ChartContainer(item, temporal);
      }

    });

    if (graph._containers.length === 0) {
      return; // for the love of pete don't let it continue
    }

    // Create the y scales and axes for the updated charts.
    graph._yPerUnit = updateYs(
      graph._containers,
      graph._yPerUnit,
      graph.dimensions,
      width > MIN_WIDTH_INTERACTIVE_GRAPHS
    );

    var charts = graph._containers;

    // Draw all the charts in graph with their respective scales.
    charts.forEach(function (chart) {
      if (chart.data.length === 0) {
        return; // for the love of pete don't let it continue
      }

      graph._xy.y = graph._yPerUnit[chart.unit];

      var data = chart.data,
          keys = chart.keys,
          labels = chart.labels;

      var lineAsArea = chart.keys.y.hasOwnProperty('y0')
        && chart.keys.y.hasOwnProperty('y1');

      chart.pathFn = lineAsArea
        ? graph._createArea(graph._xy, keys)
        : graph._createLine(graph._xy, keys);

      var MIN_POINTS_FOR_SUBSET = 15,
          DELAY = 100, // ms
          DATA_REDUCTION_FACTOR = 5;

      if (transitioning && data.length > MIN_POINTS_FOR_SUBSET) {
        var fullData = _.clone(data);
        graph._registerTimeout(
          chart,
          function () {
            chart.path = drawPath(
              graph._svg,
              chart.pathFn,
              fullData,
              0, // transition 0 ms when drawing while zooming.
              chart.path,
              lineAsArea ? chart.color : 'none',
              chart.color
            );
          },
          DELAY
        );
        data = getDataSubset(data, DATA_REDUCTION_FACTOR);
      }

      chart.path = drawPath(
        graph._svg,
        chart.pathFn,
        data,
        temporal ? 0 : graph.transTime, // Do not transition line graphs
                                       // when temporal.
        chart.path,
        lineAsArea ? chart.color : 'none', // Set fill to 'none' for normal
                                   // lines.
        chart.color
      );

    });

    // Draw one of the y axis
    drawMultipleAxes(graph);

    if (graph.dimensions.width > MIN_WIDTH_INTERACTIVE_GRAPHS) {
      addLineInteraction(graph, temporal);
    }
  };

  /**
   * @function
   * @memberOf Graph
   * @param {object} barData - Object or Array with data, keys and labels
   *
   *         data   Currently supports arrays of arrays or objects
   *                        with x value, y value, <optional> color and
   *                        <optional> category.
   *         keys   Mapping between x, y and optional color, and
   *                        category values of data object: example:
   *                        {x: 0, y: 1} or:
   *                        {x: 'xValue', y: 'yValue', color: 'eventColor',
   *                        categoy: 'cat'};
   *         labels Object {x: 'x label', y: 'y label'} will be
   *                        mapped to axis labels of the graph
   * @param {string} scale  Whether the graph has a scale other than temporal.
   *                        If it is of a temporal nature the x-axis will by
   *                        default be the temporal axis.
   * @description           Draws a barchart, if necessary sets up the graph,
   *                        if necessary modifies domain and redraws axis,
   *                        and draws the line according to the data object.
   *                        Currently only a time scale on the x-axis is
   *                        supported. It assumes that every segment has a
   *                        data element.
   */
  Graph.prototype.drawBars = function (barData, scale) {
    var graph = this;

    var content = barData[0];
    var data, keys, labels;
    data = content.data;
    keys = content.keys;
    labels = { x: content.xLabel, y: content.unit };
    var originalKey = keys.y;
    if (keys.category) {
      // Create data for stacked bars.
      data = createYValuesForCumulativeData(data, keys);
      keys.y = 'y1';
    }

    var graphSizeChanged = function () {
      var scaleRangeMaxX = graph._xy.x.scale.range()[1];
      var scaleRangeMaxY = graph._xy.y.scale.range()[0];
      return scaleRangeMaxY !== graph.dimensions.height
      || scaleRangeMaxX !== graph.dimensions.width;
    };

    if (!graph._xy || graphSizeChanged()) {
      var options = {
        x: {
          scale: scale,
          orientation: 'bottom'
        },
        y: {
          scale: 'linear',
          orientation: 'left'
        }
      };
      graph._xy = graph._createXYGraph(data, keys, labels, options);
      graph._xy.y.scale.domain([0, graph._xy.y.maxMin.max]);
    }

    graph._xy = rescale(
      graph._svg,
      graph.dimensions,
      graph._xy,
      data,
      keys,
      {y: 0},
      graph._xDomain
    );

    drawLabel(graph._svg, graph.dimensions, labels.y, true);

    drawVerticalRects(
      graph._svg,
      graph.dimensions,
      graph._xy,
      keys,
      data,
      graph.transTime,
      graph._xDomain
    );

    if (graph.dimensions.width > MIN_WIDTH_INTERACTIVE_GRAPHS) {
      addInteractionToRects(
        graph._svg,
        graph.dimensions,
        graph._xy,
        keys,
        labels,
        graph.transTime
      );
    }

    // Object reference, put it back.
    keys.y = originalKey;
  };

  /**
   * @function
   * @memberOf Graph
   * @param {object}    data object. Currently supports the format:
   *                    [
   *                      {
   *                        "<key to color>": "<color str>",
   *                        "<value key": <value int>,
   *                        "<label key>": "<label>"
   *                      },
   *                      ...,
   *                    ]
   * @param {object} keys   Mapping between x values of data object:
   *                        example: {x: 'color'}
   * @param {object} labels Object {x: 'x label'} will be
   *                        mapped to axis labels of the graph
   * @description           If necessary an x-scale, axis, draws the
   *                        label and sets up a mousemove listener.
   *                        It draws the rectangles.
   */
  Graph.prototype.drawHorizontalStack = function (content) {
      var data = content[0].data,
          keys = content[0].keys,
          labels = { x: content.xLabel, y: content.unit };

      var options = {
        scale: 'linear',
        orientation: 'bottom',
        tickFormat: d3.format(".0%") // Custom tickFomat in percentages
      };
      this._x = createXGraph(this._svg, this.dimensions, labels, options);

      if (data === null) { return; } // We are done here.

      // normalize data
      var total = d3.sum(data, function (d) {
        return Number(d[keys.x]);
      });

      var dataCopy = angular.copy(data);

      angular.forEach(dataCopy, function (value, key) {
        value[keys.x] = value[keys.x] / total;
      });
      drawHorizontalRects(this._svg, this.dimensions, this.transTime, this._x.scale, dataCopy, keys, labels);
  };

  /**
   * Draws an elevation profile, with monitoring well values as points and an
   * interpolation through the well values.
   *
   * Crosssection gets a combined y domain and the x domain of the line.
   *
   * Get range, domain, make scale and axis, draw everything.
   *
   * Data should look like this:
   *
   * content = {
   *   line: {
   *     data: [],
   *     keys: {}
   *   },
   *   points: [{x: int, value: int}]
   * };
   *
   * @param  {object} content data to plot
   */
  Graph.prototype.drawCrosssection = function (content) {
    if (!content.line.data) { return; }

    var width = this._getWidth(this.dimensions);
    var height = this._getHeight(this.dimensions);

    var xLineMinMax = this._maxMin(content.line.data, 0);

    var yLineMinMax = this._maxMin(content.line.data, 1);

    var maxY;
    var minY;

    var transTime = this._getTransTime();
    if (content.points.length) {
      var minimumPoint = _.minBy(content.points, function (p) {return p.value; });
      var maximumPoint = _.maxBy(content.points, function (p) {return p.value; });
      maxY = Math.max(yLineMinMax.max, maximumPoint.value);
      minY = Math.min(0, yLineMinMax.min, minimumPoint.value);
    }

    this._xy = {
      x: {
        minMax: {
          min: 0,
          max: xLineMinMax.max
        }
      },
      y: {
        minMax: {
          min: maxY || yLineMinMax.max,
          max: minY || yLineMinMax.min
        }
      }
    };

    var xRange = {min: 0, max: width};
    var yRange = {min: 0, max: height};

    this._xy.x.scale = this._makeScale(
      this._xy.x.minMax,
      xRange,
      {scale: 'linear'}
    );
    this._xy.x.axis = this._makeAxis(
      this._xy.x.scale,
      {orientation: 'bottom'}
    );
    this._drawAxes(
      this._svg,
      this._xy.x.axis,
      this.dimensions,
      false, // is not a y axis.
      0 // no transition of x axis
    );
    drawLabel(this._svg, this.dimensions, 'm', false);

    this._xy.y.scale = this._makeScale(
      this._xy.y.minMax,
      yRange,
      {scale: 'linear'}
    );
    this._xy.y.axis = this._makeAxis(
      this._xy.y.scale,
      {orientation: 'left', drawGrid: true}
    );
    drawAxes(
      this._svg,
      this._xy.y.axis,
      this.dimensions,
      true, // is a y axis.
      transTime
    );
    drawLabel(this._svg, this.dimensions, 'hoogte (mNAP)', true);

    var className = 'line';
    addLineToGraph(
      this._svg,
      transTime,
      content.line.data,
      {x: 0, y:1},
      this._xy,
      className
    );

    addPointsToGraph(this._svg, transTime, content.points, this._xy);

    className = 'interpolation-line';
    // Only use ts linked to freatic line.
    var linePoints = content.points.filter(function (p) { return p.linked; });
    addLineToGraph(
      this._svg,
      transTime,
      linePoints,
      {x: 'x', y: 'value'},
      this._xy,
      className
    );
  };

  /**
   * @function
   * @memberOf Graph
   * @param {int}    draw   Timestamp in ms from epoch
   * @description           draws the now according the
   *                        current active scale.
   */
  Graph.prototype.drawNow = function (now) {
      this._drawNow(now, this._xy.x.scale);
      // move to the front
      var el = this._svg.select('.now-indicator').node();
      el.parentNode.appendChild(el);
  };

  Graph.prototype._createXYGraph = function (data, keys, labels, options) {
      if (!options) {
        options = {
          x: {
            scale: 'linear',
            orientation: 'bottom'
          },
          y: {
            scale: 'linear',
            orientation: 'left'
          }
        };
      }

      var width = this._getWidth(this.dimensions);

      var xy = {x: {}, y: {}};

      angular.forEach(xy, function (value, key) {
        var y = key === 'y';
        options[key].drawGrid = width > MIN_WIDTH_INTERACTIVE_GRAPHS && y;
        xy[key] = this._createD3Objects(
          data,
          keys[key],
          options[key],
          y
        );
        drawAxes(this._svg, xy[key].axis, this.dimensions, y);
        drawLabel(this._svg, this.dimensions, labels[key], y);
      }, this);
      return xy;
  };

  /**
   * Registers a timeout with a cb and a delay. Calls the cb on the instance
   * of Graph after delay.
   *
   * @param {function} cb function to call on graph instance when timeout
   *                      resolves.
   * @param {int} delay in ms of the cb execution.
   */
  Graph.prototype._registerTimeout = function(chart, cb, delay) {
      if (chart.timeout) {
        $timeout.cancel(chart.timeout);
      }

      var graph = this;

      chart.timeout = $timeout(
        function () {
          cb.call(graph); },
        delay,
        false // Do not trigger unnecessary digest loop
      );
  };

  Graph.prototype.drawCircleOnLine = function (xLocation, remove) {
    var R = 5; // radius of dot.

    var fg = this._svg.select('#feature-group');

    // Move listener rectangle to the front
    var el = this._svg.select('#listeners').node();
        el.parentNode.appendChild(el);

    var g = fg.select('.interaction-group');
    if (remove) {
      g.selectAll('circle').remove();
    }

    var chart = this._containers[0];
    var i = UtilService.bisect(chart.data, chart.keys.x, xLocation);
    var d = chart.data[i];

    if (!d) { return; }

    var x = this._xy.x.scale(d[chart.keys.x]);
    var y;
    // If d has a y value, use it. Otherwise show dot at bottom of chart.
    if (d[chart.keys.y] || d[chart.keys.y] === 0) {
      y = this._xy.y.scale(d[chart.keys.y]);
    }
    else {
      y = this._xy.y.scale.range()[0] - R;
    }

    if (!g[0][0]) {
      g = fg.append('g').attr('class', 'interaction-group');
    } else {
      g.selectAll('circle').remove();
    }

    g.append('circle')
      .attr('r', R)
      .attr('cx', x)
      .attr('cy', y)
      .transition()
      .ease('easeInOut')
      .duration(100)
      .attr('r', 3);
  };

  /**
   * Returns this.transTime first time called or when last called a long time
   * ago, otherwise returns zero. Use it to determine transition duration.
   */
  Graph.prototype._getTransTime = function () {
    var transTime;
    var now = Date.now();
    var RENDER_BUFFER = 30; // Browsers need a few ms to render the transtion.

    if (now - this._lastTimeDrawWasCalled < RENDER_BUFFER + this.transTime) {
      transTime = 0;
    } else {
      transTime = this.transTime;
    }

    this._lastTimeDrawWasCalled = Date.now();

    return transTime;
  };



  var drawAxes, drawLabel, needToRescale, drawPath, setupLineGraph, createDonut,
      addInteractionToPath, getBarWidth, drawVerticalRects,
      addInteractionToRects, drawHorizontalRects, createXGraph, rescale,
      createYValuesForCumulativeData, getDataSubset, updateYs, drawMultipleAxes,
      setActiveAxis, addPointsToGraph, addLineToGraph, addThresholds;

  /**
   * Draws and updates thresholds of charts.
   *
   * @param {svg}    svg        d3 svg.
   * @param {array}  charts     charts in graph.
   * @param {str}    activeUnit current active axis.
   * @param {array}  xRange     min, max range of graph in px.
   * @param {fn}     yScale     d3 scale for y axis.
   * @param {int}    duration   transition duration.
   */
  addThresholds = function (svg, charts, activeUnit, xRange, yScale, duration) {
    var PADDING = 2; // px.

    // Get or create group for thresholds.
    var tg = svg.select('#feature-group').select('.thresholds');

    if (tg.empty()) {
      tg = svg.select('#feature-group')
        .append('g')
        .attr('class', 'thresholds');
    }

    // Get unique list of thresholds.
    var thresholds = [];

    charts.forEach(function (chart) {
      if (chart.unit === activeUnit) {
        chart.thresholds.forEach(function (threshold) {
          thresholds.push(threshold);
        });
      }
    });

    // Thresholds are a property of chart, but come from an asset, so multiple
    // charts might have the same thresholds.
    thresholds = _.uniq(thresholds);

    // Create, update and remove thresholds.
    var lines = tg.selectAll("line")
      .data(thresholds, function(d) { return d.name; });

    lines.enter().append('line')
      .attr('x1', 0)
      .attr('x2', xRange[1]);

    lines.transition()
      .duration(duration)
      .attr('y1', function (d) { return yScale(d.value); })
      .attr('y2', function (d) { return yScale(d.value); });

    lines.exit().transition()
      .duration(duration)
      .style('stroke-width', 0)
      .remove();

    // Create, update, remove labels on threshold.
    var labels = tg.selectAll("text")
      .data(thresholds, function(d) { return d.name; });

    labels.enter().append('text')
      .attr('x', PADDING)
      .text(function (d) {
        return d.name + ' ' + d.value.toFixed(2) + ' ' + activeUnit;
      });

    labels.transition()
      .duration(duration)
      .attr('y', function (d) { return yScale(d.value) - PADDING; });

    labels.exit()
      .remove();
  };


  /**
   * Creates y cumulatie y values for elements on the same x value.
   *
   * @param  {array} data array of objects.
   * @param  {object} keys mapping between x, y and keys in the data.
   * @return {array} with added y0 value and cumulative y value.
   */
  createYValuesForCumulativeData = function (data, keys) {
    var cumulativeData = [];
    // Group by x value
    d3.nest().key(function (d) {
      return d[keys.x];
    })
    .entries(data)
    // Compute y values for every group
    .forEach(function (group) {
      var y0 = 0;
      group.values = group.values.map(function (d) {
        d.y0 = y0;
        d.y1 = y0 + d[keys.y];
        y0 = d.y1;
        cumulativeData.push(d);
      });
    });

    return cumulativeData;
  };

  needToRescale = function (data, key, limit, old, xDomain) {
    var newDomain;
    if (key === "y") {
      newDomain = Graph.prototype._maxMin(data, "y");
    } else {
      newDomain = xDomain
        ? { min: xDomain.start, max: xDomain.end }
        : Graph.prototype._maxMin(data, key);
    }
    return (
      newDomain.max > old.max ||
      newDomain.max < (limit * old.max) ||
      newDomain.min !== old.min
    );
  };

  /**
   * @function
   * @description Updates all of the Y containers for the graph based on all
   * the charts in this graph. It looks for similar units and calculates
   * the min and the max based on all of the items with the same unit.
   * In this way the charts can be compared and different y-axes calculated.
   * @param {object} - charts - ChartContainer object with y and data
   * @param {object} - xyPerUnit - y characteristics (domain, scale, axis) per
   *                               unit of the graph
   * @param {object} - dimensions - object describing the size of the graph
   * @param {boolean}  drawGrid    to draw a grid or not.
   */
  updateYs = function (charts, yPerUnit, dimensions, drawGrid) {
    var width = Graph.prototype._getWidth(dimensions);
    var options = {
      scale: 'linear',
      orientation: 'left',
      drawGrid: drawGrid
    };

    charts.forEach(function (chart) {

      var maxMin = Graph.prototype._maxMin(chart.data, chart.keys.y);
      var unitY = yPerUnit[chart.unit];

      if (unitY) {
        maxMin.min = Math.min(chart.yMaxMin.min, unitY.maxMin.min);
        maxMin.max = Math.max(chart.yMaxMin.max, unitY.maxMin.max);
      }

      yPerUnit[chart.unit] = { maxMin: maxMin };
    });

    _.forEach(yPerUnit, function (unitY) {
      unitY.range = Graph.prototype._makeRange('y', dimensions);
      unitY.scale = Graph.prototype._makeScale(unitY.maxMin, unitY.range, options);
      unitY.axis = Graph.prototype._makeAxis(unitY.scale, options, dimensions);
    });

    return yPerUnit;
  };

  rescale = function (svg, dimensions, xy, data, keys, origin, xDomain) {
    // Sensible limits to rescale. If the max
    // of the y values is smaller than 0.2 (or 20 %) of the max of the scale,
    // update domain of the scale and redraw the axis.
    var limits = {
      x: 1,
      y: 0.2
    };
    var orientation = {
      x: 'bottom',
      y: 'left'
    };
    origin = origin || {};
    // Decide to rescale for each axis.
    angular.forEach(xy, function (value, key) {
      if (needToRescale(data, keys[key], limits[key], value.maxMin, xDomain)) {
        value.maxMin = key === "x" && xDomain
          ? { min: xDomain.start, max: xDomain.end }
          : Graph.prototype._maxMin(data, keys[key]);
        if (origin[key] === undefined) {
          origin[key] = value.maxMin.min;
        }
        var animationDuration = key === 'y' ? Graph.prototype.transTime : 0;
        var options = {orientation: orientation[key]};
        options.drawGrid = dimensions.width > MIN_WIDTH_INTERACTIVE_GRAPHS && key === 'y';
        value.scale.domain([origin[key], value.maxMin.max]);
        value.axis = Graph.prototype._makeAxis(value.scale, options, dimensions);
        drawAxes(svg, value.axis, dimensions, key === 'y' ? true : false, animationDuration);
      }
    });
    return xy;
  };

  addPointsToGraph = function (svg, duration, points, xy) {
    var xScale = xy.x.scale;
    var yScale = xy.y.scale;

    // Join new points to svg circles
    var circles = svg.select('g').select('#feature-group').selectAll("circle")
      .data(points, function(d) { return d.id; });

    // UPDATE
    // Update elements start and width as needed.
    circles.transition()
      .duration(duration)
      .attr("cx", function (d) { return xScale(d.x); })
      .attr('cy', function (d) { return yScale(d.value); });
    // ENTER
    // Create new elements as needed.
    circles.enter().append("circle")
      .attr("cx", function (d) { return xScale(d.x); })
      .attr('cy', function (d) { return yScale.range()[1]; })
      .attr("class", "point")
      .transition()
      .duration(duration)
      .attr('cy', function (d) { return yScale(d.value); })
      .attr('r', 8);
    // EXIT
    // Remove old elements as needed. First transition to width = 0
    // and then remove.
    circles.exit()
      .transition()
      .duration(duration)
      .attr('r', 0)
      .remove();
  };

  /**
   * Adds a line to a graph. Assumes xy contains d3 scales and className
   * describes a unique line.
   */
  addLineToGraph = function (svg, duration, data, keys, xy, className) {
    var xScale = xy.x.scale;
    var yScale = xy.y.scale;

    var path = d3.svg.line()
      .interpolate('basis') // Goes nicely in between the points. Makes it look
                            // very scientific.
      .x(function (d) { return xScale(d[keys.x]); })
      .y(function (d) { return yScale(d[keys.y]); })
      // interrupt the line when no data
      .defined(function (d) { return !isNaN(parseFloat(d[keys.y])); });

    // generate line paths
    var line = svg.select('#feature-group').selectAll("." + className)
      .data([data]).attr("class", className);

    // Create the line
    line.enter()
      .append("path")
      .attr("class", className)
      .attr("d", function (d) { return path(d); });

    // Update the line
    line.transition().duration(duration)
      .attr("d", path);
  };

  drawHorizontalRects = function (svg, dimensions, duration, scale, data, keys, labels) {
    var width = Graph.prototype._getWidth(dimensions),
        height = Graph.prototype._getHeight(dimensions),
        DEFAULT_BAR_COLOR = "#7f8c8d", // $asbestos is the default color for bars
        previousCumu = 0;

    // Create a start and end for each rectangle.
    angular.forEach(data, function (value) {
      value.start = previousCumu;
      previousCumu += value[keys.x];
    });

    // Data should be normalized between 0 and 1.
    var total = 1;

    // Join new data with old elements, based on the y key.
    var rects = svg.select('g').select('#feature-group').selectAll(".horizontal-rect")
      .data(data, function (d) { return d[keys.y]; });

    // UPDATE
    // Update elements start and width as needed.
    rects.transition()
      .duration(duration)
      .attr("x", function (d) { return scale(d.start); })
      .attr('width', function (d) { return scale(d[keys.x]); });
    // ENTER
    // Create new elements as needed.
    rects.enter().append("rect")
      .style("fill", function (d) { return d.color || DEFAULT_BAR_COLOR; })
      .attr("x", function (d) { return scale(d.start); })
      .attr("y", 0)
      .attr('class', 'horizontal-rect')
      .attr("height", height)
      .transition()
      .duration(duration)
      .attr('width', function (d) { return scale(d[keys.x]); });
    // EXIT
    // Remove old elements as needed. First transition to width = 0
    // and then remove.
    rects.exit()
      .transition()
      .duration(duration)
      .attr('width', 0)
      .remove();

    // Rects set their value on the label axis when hoovered
    rects.on('mousemove', function (d) {
      var label;
      var labelstr = d.label;
      if (d.label === -1 || d.label.split === undefined) {
        label = Math.round(d[keys.x] * 100) + "% overig";
      } else {
        labelstr = d.label.split('-');
        label = Math.round(d[keys.x] * 100) + '% ' + labelstr[labelstr.length - 1];
      }

      svg.select('#xlabel')
        .text(label)
        .attr("class", "selected");

      // Correct height so label fits within svg.
      var mv = - 0.5 * svg.select('#xlabel').node().getBBox().height;
      svg.select('#xlabel')
        .attr('dy', mv);
    });

    // When the user moves the mouse away from the graph, put the original
    // label back in place.
    rects.on('mouseout', function (d) {
      svg.select('#xlabel')
        .text(labels.x)
        .classed({"selected": false});
    });
  };

  drawVerticalRects = function (svg, dimensions, xy, keys, data, duration, xDomain) {

    var width = Graph.prototype._getWidth(dimensions),
        height = Graph.prototype._getHeight(dimensions),
        x = xy.x,
        y = xy.y,
        MIN_BAR_WIDTH = 2,
        barWidth = Math.max(
          MIN_BAR_WIDTH,
          Math.floor(
            getBarWidth(xy.x.scale, data, keys, dimensions, xDomain)
          )
        ),
        strokeWidth = barWidth === MIN_BAR_WIDTH ? 0 : 1,

        // Join new data with old elements, based on the x key.
        bar = svg.select('#feature-group').selectAll(".bar")
          .data(
            data,
            function (d) {
              if (d[keys.category]) {
                return d[keys.x] + d[keys.category];
              } else {
                return d[keys.x];
              }
            }
          );

    // Aggregated events explicitly have an interval property which correspond
    // to a pixel size when parsed by scale function.
    var widthFn = function (d) {
      var width;
      if (d.hasOwnProperty('interval')) {
        width = xy.x.scale(d.interval) - xy.x.scale(0);
      }
      else {
        width = barWidth;
      }
      return width;
    };

    // UPDATE
    bar
      // change x when bar is invisible:
      .attr("x", function (d) { return x.scale(d[keys.x]) - widthFn(d); })
      // change width when bar is invisible:
      .attr('width', widthFn);
    bar
      .transition()
      .duration(duration)
        .style("fill", function (d) { return d[keys.color] || ''; })
        .attr("height", function (d) {
          return y.scale(d.y0) - y.scale(d[keys.y]) || height - y.scale(d[keys.y]);
        })
        .attr("y", function (d) { return y.scale(d[keys.y]); })
    ;

    // ENTER
    // Create new elements as needed.
    bar.enter().append("rect")
      .attr("class", "bar")
      .attr("x", function (d) { return x.scale(d[keys.x]) - widthFn(d); })
      .attr('width', widthFn)
      .attr("y", function (d) { return y.scale(0); })
      .attr("height", 0)
      .style("fill", function (d) { return d[keys.color] || ''; })
      .attr("stroke-width", strokeWidth)
      .transition()
      .duration(duration)
        // Bring bars in one by one
        // .delay(function (d, i) { return i * 0.1 * duration * 2; })
        .attr("height", function (d) {
          return y.scale(d.y0) - y.scale(d[keys.y]) || height - y.scale(d[keys.y]);
        })
        .attr("y", function (d) { return y.scale(d[keys.y]); });

    // EXIT
    // Remove old elements as needed.
    bar.exit()
      .transition()
      .duration(duration)
      .attr("y", height)
      .attr("height", 0)
      .remove();
  };

  getBarWidth = function (scale, data, keys, dimensions, xDomain) {

    if (data.length === 0) {
      // Apparently, no data is present: return a dummy value since nothing
      // is to be drawn.
      return 0;
    }

    else {
      var firstDatum = data[0],
          lastDatum = data[data.length - 1];

      return  Math.floor(
        (scale(lastDatum[keys.x]) - scale(firstDatum[keys.x])) / (data.length - 1)
      );
    }

  };


  addInteractionToRects = function (svg, dimensions, xy, keys, labels, duration) {
    var height = Graph.prototype._getHeight(dimensions),
      width = Graph.prototype._getWidth(dimensions),
        fg = svg.select('#feature-group');

    var cb = function (d) {
      removeAllSelection();
      d3.select(this).attr('class', 'selected bar');
      var g = fg.append('g').attr('class', 'interaction-group');


      var text = Math.round(d[keys.y] * 100) / 100 + ' ' + labels.y;
      text = keys.category !== undefined
        ? text + ' ' + d[keys.category]
        : text;

      var t  = g.append('text').text(text);

      var tHeight = t.node().getBBox().height,
          tWidth = t.node().getBBox().width;

      var BOX_PADDING_WIDTH = 10;
      var BOX_PADDING_HEIGHT = 5;
      var TEXY_PADDING_WIDTH = BOX_PADDING_HEIGHT;

      var bgY = Math.min(
        height - tHeight - BOX_PADDING_HEIGHT,
        xy.y.scale(d.y1 || d[keys.y])
      );

      var textY = Math.min(
        height - 0.5 * tHeight,
        xy.y.scale(d.y1 || d[keys.y]) + tHeight
      );

      var bgX = Math.min(
        width - tWidth - BOX_PADDING_WIDTH,
        xy.x.scale(d[keys.x])
      );

      var textX = Math.min(
        width - tWidth,
        xy.x.scale(d[keys.x]) + TEXY_PADDING_WIDTH
      );

      g.append('rect')
        .attr('class', 'tooltip-background')
        .attr('x', bgX)
        .attr('y', bgY)
        .attr('width', tWidth + BOX_PADDING_WIDTH)
        .attr('height', tHeight + BOX_PADDING_HEIGHT);

      t.attr('x', textX)
        .attr('y', textY);

      t.node().parentNode.appendChild(t.node());
    };

    var removeAllSelection = function () {
      fg.selectAll('.bar').attr('class', 'bar');
      fg.select('.interaction-group').remove();
    };

    fg.selectAll('.bar').on('click', cb);
    fg.selectAll('.bar').on('mousemove', cb);
    fg.selectAll('.bar').on('mouseout', function () {
      removeAllSelection();
    });
  };

  createXGraph = function (svg, dimensions, labels, options) {
    var x = {};
    if (!options) {
      options = {
        scale: 'linear',
        orientation: 'bottom'
      };
    }
    var width = Graph.prototype._getWidth(dimensions),
    range = {min: 0, max: width},
    // Axis should run from zero to 100%
    domain = {min: 0, max: 1};
    x.scale = Graph.prototype._makeScale(domain, range, {scale: options.scale});
    x.axis = Graph.prototype._makeAxis(x.scale, options);
    drawAxes(svg, x.axis, dimensions, false);
    drawLabel(svg, dimensions, labels.x, false);
    return x;
  };

  drawPath = function (svg, pathFn, data, duration, path, fill, color) {
    if (!path) {
      var fg = svg.select('g').select('#feature-group');
      // bring to front
      fg.node().parentNode.appendChild(fg.node());
      path = fg.append("path")
        .attr("class", "line");
    }
    path.datum(data)
      .style('fill', fill)
      .style('stroke', color)
      .transition()
      .duration(duration)
      .attr("d", function (d) {
        // Prevent returning invalid values for d
        var p = pathFn(d) || "M0, 0";
        return p;
      });
    return path;
  };

  /**
   * When hovering show information on the data in the lines in the graph.
   *
   * @params {object} - the graph object (all-encompassing, ever-faithful)
   */
  var addLineInteraction = function (graph, temporal) {
    var height = graph._getHeight(graph.dimensions),
        fg = graph._svg.select('#feature-group'),
        MIN_LABEL_Y = 50,
        LABEL_PADDING_X = 10,
        LABEL_PADDING_Y = 5,
        xy = graph._xy;

    var duration = 0.3; // zoing

    // Move listener rectangle to the front
    var el = graph._svg.select('#listeners').node();
        el.parentNode.appendChild(el);

    var cb = function () {
      var boundingRect = this; // `this` is otherwise lost in foreach

      var values = [];
      var x2, xText; // needed for the time.

      angular.forEach(graph._containers, function (chart, id) {
        if (chart.data.length === 0) { return true; }
        var i = UtilService.bisect(chart.data, chart.keys.x, xy.x.scale.invert(d3.mouse(boundingRect)[0]));
        i = i === chart.data.length ? chart.data.length - 1 : i;
        var d = chart.data[i];
        var value = chart.keys.y.hasOwnProperty('y1') ? d[chart.keys.y.y1] : d[chart.keys.y];
        if (d[chart.keys.x] === null || d[chart.keys.y] === null) { return; }

        x2 = xy.x.scale(d[chart.keys.x]);
        var y2 = graph._yPerUnit[chart.unit].scale(value);
        xText = (temporal) ? new Date(chart.data[i][chart.keys.x]).toLocaleString() : chart.data[i][chart.keys.x].toFixed(2);

        if (!chart.labels) {
          chart.labels = {y:''};
        }

        values.push({
          x: x2,
          y: y2,
          location: chart.location,
          ylabel: chart.labels.y,
          unit: chart.unit,
          value: value,
          color: chart.color
        });
      });

      if (values.length === 0) { return true; }

      var g = fg.select('.interaction-group');
      var valuebox = fg.select('.valuebox');
      var textLength;

      if (!g[0][0]) {
        g = fg.append('g').attr('class', 'interaction-group');
        valuebox = g.append('g').attr('class', 'valuebox');
        valuebox.append('rect');
        valuebox.append('text');
        g.append('line');
      } else {
        g.selectAll('circle').remove();
        g.selectAll('tspan').remove();
        g.selectAll('text.graph-tooltip-x').remove();
      }

      valuebox
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', 100)
        .attr('height', 20 * values.length - 1);

      g.select('line')
        .attr('y1', height)
        .attr('y2', 0)
        .attr('x1', x2)
        .attr('x2', x2);

      values.forEach(function (v, i) {
        g.append('circle')
          .attr('r', 0)
          .attr('cx', v.x)
          .attr('cy', v.y)
          .transition()
          .ease('easeInOut')
          .duration(duration)
          .attr('r', 5);
          var texty2 = Math.max(v.y - LABEL_PADDING_Y, MIN_LABEL_Y);

        valuebox.select('rect')
          .attr('fill', 'white')
          .attr('x', 5)
          .attr('y', 0)
          .attr('width', 100)
          .attr('height', 20 + 15 * i);
        valuebox
          .append('circle')
            .attr('r', 4)
            .attr('cx', 15)
            .attr('cy', 10 + 15 * i)
            .attr('stroke', 'none')
            .attr('fill', v.color);

        var location = (v.location) ? '' + ' - ' + v.location : '';
        var tspan = valuebox.select('text')
          .append('tspan')
            .text(v.value.toFixed(2) + ' ' + v.ylabel + v.unit + location)
            .attr('class', 'graph-tooltip-y')
            .attr('x', 25)
            .attr('y', 15 + 15 * i);

        textLength = (textLength) ? textLength : 0;
        textLength = Math.max(tspan[0][0].getComputedTextLength(), textLength);
        valuebox.select('rect')
          .attr('width', textLength + 25);
      });
      g.append('text')
        .text(xText)
        .attr('class', 'graph-tooltip-x')
        .attr('x', x2 + LABEL_PADDING_X)
        .attr('y', height - LABEL_PADDING_Y);
    };

    graph._svg.select('#listeners').on('click', cb);
    graph._svg.select('#listeners').on('mousemove', cb);
    graph._svg.select('#listeners').on('mouseout', function () {
      fg.select('.interaction-group').remove();
    });

  };

  addInteractionToPath = function (svg, dimensions, data, keys, labels, path, xy, duration) {
    var bisect = d3.bisector(function (d) { return d[keys.x]; }).right,
        height = Graph.prototype._getHeight(dimensions),
        fg = svg.select('#feature-group'),
        MIN_LABEL_Y = 50,
        LABEL_PADDING_X = 10,
        LABEL_PADDING_Y = 5;

    // Move listener rectangle to the front
    var el = svg.select('#listeners').node();
    el.parentNode.appendChild(el);

    var cb = function () {
      fg.select('.interaction-group').remove();

      var i = bisect(data, xy.x.scale.invert(d3.mouse(this)[0]));
      i = i === data.length ? data.length - 1 : i;
      var d = data[i];
      var value = keys.y.hasOwnProperty('y1') ? d[keys.y.y1] : d[keys.y];

      if (d[keys.x] === null || d[keys.y] === null) { return; }

      var y2 = xy.y.scale(value),
          x2 = xy.x.scale(d[keys.x]),
          xText = new Date(data[i][keys.x]).toLocaleString();

      var g = fg.append('g').attr('class', 'interaction-group');

      g.append('circle')
        .attr('r', 0)
        .attr('cx', x2)
        .attr('cy', y2)
        .transition()
        .ease('easeInOut')
        .duration(duration)
        .attr('r', 5);
      g.append('line')
        .attr('y1', y2)
        .attr('y2', y2)
        .attr('x1', 0)
        .attr('x2', x2);
      g.append('line')
        .attr('y1', height)
        .attr('y2', y2)
        .attr('x1', x2)
        .attr('x2', x2);

      var texty2 = Math.max(y2 - LABEL_PADDING_Y, MIN_LABEL_Y);

      g.append('text')
        .text(Math.round(value * 100) / 100 + ' ' + labels.y)
        .attr('class', 'graph-tooltip-y')
        .attr('x', LABEL_PADDING_X)
        .attr('y', texty2 - LABEL_PADDING_Y);
      g.append('text')
        .text(xText + ' ' + labels.x)
        .attr('class', 'graph-tooltip-x')
        .attr('x', x2 + LABEL_PADDING_X)
        .attr('y', height - LABEL_PADDING_Y);
    };

    svg.select('#listeners').on('click', cb);
    svg.select('#listeners').on('mousemove', cb);
    svg.select('#listeners').on('mouseout', function () {
      fg.select('.interaction-group').remove();
    });

  };

  /**
   * Draws or updates graph axis labels.
   * @param  {object}       d3 selection svg
   * @param  {object}       dimensions
   * @param  {string}       (optional) label, if undefined uupdates current.
   * @param  {boolean}      draw on y axis, else x-axis.
   */
  drawLabel = function (svg, dimensions, label, y) {
    var width = Graph.prototype._getWidth(dimensions),
        height = Graph.prototype._getHeight(dimensions),
        mv,
        // For some reason the x label needs to move a little bit more than
        // expected and the y label a little bit less.
        PIXEL_CORRECTION = 2,
        el = svg.select(y ? '#ylabel': '#xlabel');
    if (el.empty()) {
      el = svg.append('g')
        .append("text")
        .attr('class', 'graph-text graph-label')
        .style("text-anchor", "middle")
        .text(label);
    }
    if (label) {
      el.text(label);
    }
    if (y) {
      el.attr('id', 'ylabel')
        .attr('transform', 'rotate(-90)')
        .attr('y', 0)
        .attr('x', 0 - height / 2);
    } else {
      el.attr('id', 'xlabel')
        .attr('x', dimensions.padding.left + width / 2)
        .attr('y', dimensions.height);
    }

    mv = y
      ? 0.5 * el.node().getBBox().height + PIXEL_CORRECTION
      : - 0.5 * el.node().getBBox().height + PIXEL_CORRECTION;
    el.attr('dy', mv);
    return el;
  };

  drawAxes = function (svg, axis, dimensions, y, duration) {
    // Create elements and draw axis using nxtD3 method
    Graph.prototype._drawAxes(svg, axis, dimensions, y, duration);
    var axisEl;
    // Make graph specific changes to the x and y axis
    if (y) {
      axisEl = svg.select('#yaxis')
        .attr("class", "y-axis y axis")
        .selectAll("text")
          .style("text-anchor", "end")
          .attr('class', 'graph-text');
    } else {
      axisEl = svg.select('#xaxis')
        .attr("class", "x-axis x axis")
        .selectAll("text")
          .attr("dx", "-.8em")
          .attr("dy", ".15em")
          .style("text-anchor", "end")
          .attr('class', 'graph-text')
          .attr("transform", "rotate(-25)");
    }
    return axisEl;
  };


  /**
   * Draws or updates graph axis labels, with multiple y's.
   * @param  {object}       d3 selection svg
   * @param  {object}       dimensions
   * @param  {string}       (optional) label, if undefined uupdates current.
   * @param  {boolean}      draw on y axis, else x-axis.
   * @param  {string}       unit (e.g. mNAP)
   * @param  {object}       axes - keeps track of active axis.
   */
  drawMultipleAxes = function (graph) {
    var clickRect = graph._svg.select('.click-axis');
    if (clickRect.empty()) {
      clickRect = graph._svg.append('rect')
      .attr('class', 'click-axis clickable')
      .on('click', function (e) {
        setActiveAxis(graph, 1);
        if (graph.dimensions.width > MIN_WIDTH_INTERACTIVE_GRAPHS) {
          addThresholds(
            graph._svg,
            graph._containers,
            graph._activeUnit,
            graph._xy.x.scale.range(),
            graph._yPerUnit[graph._activeUnit].scale,
            graph.transTime
          );
        }
      });
    }
    clickRect
      .attr('width', graph.dimensions.padding.left)
      .attr('height', graph.dimensions.height);
    setActiveAxis(graph, 0);
    if (graph.dimensions.width > MIN_WIDTH_INTERACTIVE_GRAPHS) {
      addThresholds(
        graph._svg,
        graph._containers,
        graph._activeUnit,
        graph._xy.x.scale.range(),
        graph._yPerUnit[graph._activeUnit].scale,
        graph.transTime
      );
    }
  };

  /**
   * Determines which axis should be drawn and includes label and circles for
   * active datasets.
   *
   * @param  {Graph}        Graph instance.
   * @param  {int}          integer 0 to keep current unit, 1 for next.
   */
  setActiveAxis = function (graph, up) {
    var units = Object.keys(graph._yPerUnit);
    var indexOfUnit = units.indexOf(graph._activeUnit) + up;
    if (indexOfUnit >= units.length || indexOfUnit === -1) {
      indexOfUnit = 0;
    }
    graph._activeUnit = units[indexOfUnit];
    drawAxes(
      graph._svg,
      graph._yPerUnit[graph._activeUnit].axis,
      graph.dimensions,
      true,
      graph.transTime
    );
    var label = drawLabel(
      graph._svg,
      graph.dimensions,
      graph._activeUnit,
      true
    );
    var activeCharts = graph._containers.filter(function (chart) {
      return chart.unit === graph._activeUnit;
    });

    if (graph.dimensions.width > MIN_WIDTH_INTERACTIVE_GRAPHS) {
      var PADDING = 15;
      var SIZE = 6;
      var DELAY = 0.5; // times transTime
      var circles = d3.select(label.node().parentNode).selectAll('circle')
        .data(activeCharts, function (d) {return d.id; });

      circles
        .enter()
        .append('circle')
        .attr('r', 0)
        .attr('cx', SIZE)
        .attr('fill', function (d) {return d.color;})
        .attr('cy', function (d, i) {
          var box = label.node().getBBox();
          return -(box.x + box.width) - PADDING - i * PADDING;
        });

      circles
        .transition()
        .ease('polyInOut')
        .delay(graph.transTime)
        .duration(graph.transTime)
        .attr('r', SIZE)
        .attr('fill', function (d) {return d.color;})
        .attr('cy', function (d, i) {
          var box = label.node().getBBox();
          return -(box.x + box.width) - PADDING - i * PADDING;
        });

      circles.exit()
        .transition()
        .ease('polyInOut')
        .delay(function (d, i) { return i * graph.transTime * DELAY; })
        .duration(graph.transTime)
        .attr('r', 0)
      .remove();
    }
  };

  /**
   * Takes a data array and returns an array with length one/subsetFactor of the
   * input.
   *
   * It uses modulo to remove but every subsetFactor item in the array. As such
   * the result depends on the order of the input and it does not attempt to
   * simplify in a least intrusive way as e.g. douglas-peucker would. This is
   * probably faster though, which is the whole point.
   *
   * @param  {array}  data         array of data points to subset.
   * @param  {int}    subsetFactor describing how much smaller the subset should
   *                               be.
   * @return {array}               subset of data with lenght data.length /
   *                               subsetFactor.
   */
  getDataSubset = function (data, subsetFactor) {
    return data.filter(function (item, index) {
      return index % subsetFactor === 0; // returns true for every subsetFactor
                                         // th item;
    });
  };

  return Graph;

}]);

/**
 *
 *
 */
angular.module('lizard-nxt')
  .factory('ChartContainer', ['NxtD3', function (NxtD3) {

  var DEFAULT_GREEN = '#16a085';

  var defaultKeys = {
    x: 'timestamp',
    y: { 'y0': 'min', 'y1': 'max' }
  };

  /**
   * Charts are are small objects that are drawn on the graph canvas
   * They are a way to keep track of all of the lines or that are being drawn.
   *
   * NOTE: this might have to change because the api of graphs is crappy
   *
   * It should be something like this:
   * <graph>
   *  <line data="data" etc.. </line>
   * </graph>
   *
   * For now this is a way to keep track of the scales, domains and xy's of the graph
   */
  function ChartContainer (chartContent) {

    this.id = chartContent.id;
    this.keys = chartContent.keys || defaultKeys;
    this.color = chartContent.color || DEFAULT_GREEN;
    this.unit = chartContent.unit;
    this.thresholds = chartContent.thresholds;
    this.location = chartContent.location;
    this.labels = chartContent.labels;
    this.setContentUpdateY(chartContent);

    return;
  }

  ChartContainer.prototype.setContentUpdateY = function (chartContent) {
    this.data = chartContent.data;
    this.keys = chartContent.keys || defaultKeys;
    this.color = chartContent.color || DEFAULT_GREEN;
    this.yMaxMin = NxtD3.prototype._maxMin(this.data, this.keys.y);
  };

  return ChartContainer;

}]);

'use strict';


/**
 * @ngdoc directive
 * @class graph
 * @memberof app
 * @name graph
 * @requires Graph
 * @summary Creates a Graph, adds it to the graphCtrl and watches data to
 *          call graphCtrl.updateGraph.
 * @description  Usage: <graph <type> <attrs></graph>
 *               Angular runs graph.graphCtrl, graph.compile.preCompile,
 *               <type directive>.link, graph.link. It sets up a graph
 *               object and puts it on the graphCtrl for further
 *               modifications by the subdirectives.
 */
angular.module('lizard-nxt')
  .directive('graph', ["Graph", function (Graph) {

  var graphCtrl, preCompile, link;

  /**
   * @function
   * @memberOf graph
   * @param {scope}     scope     local scope
   * @param {object}    element
   * @param {object}    attrs     data, keys, labels and now
   * @param {object}    graphCtrl controller
   * @description       sets up a graph on the controller after
   *                    the controller's instantiation, but before
   *                    the link. Dimensions have sensible defaults
   *                    that may be partially overwritten by setting
   *                    the dimensions attribute of the graph.
   */
  preCompile = function (scope, element, attrs, graphCtrl) {
    /*
                       dimensions.width
                               |
                     |         ^             |
                      ______________________  _
                     |   |                  |
                     | y |   Chart area     |
                     |___|__________________|  }- Dimensions.height
                     |   |     x axis       |
    padding.bottom-- |___|_____x label______| _
                       |
                  padding.left

    Labels are placed next to the edge of the svg, remaining padding
    space is available for the axis tick marks.
    */

    var dimensions, el;

    dimensions = {
      width: 375,
      height: 160,
      padding: {
        top: 5,
        right: 5,
        bottom: 50,
        left: 50
      }
    };
    // Overwrite anything provided by dimensions attr on element
    angular.extend(dimensions, scope.dimensions);

    el = element.find('svg')[0];

    graphCtrl.yfilter = attrs.yfilter;
    graphCtrl.type = attrs.type;

    // Create the graph and put it on the controller
    graphCtrl.graph = new Graph(
      el,
      dimensions,
      scope.temporal
    );
  };

  /**
   * @function
   * @memberOf graph
   * @param {scope}     scope     local scope
   * @param {object}    element
   * @param {object}    attrs     data, keys, labels and now
   * @param {object}    graphCtrl controller
   * @description       Contains listeners to values on the element
   *                    and calls the updateFunctions of the graphCtrls
   *                    on the graphs. Suddirectives only have to implement
   *                    an update function on their controller.
   */
  link = function (scope, element, attrs, graphCtrl) {

    var graphUpdateHelper = function () {
      if (scope.content) {
        graphCtrl.setData(scope);
      }
      else if (scope.data) {
        graphCtrl.setFormattedContent(scope);
      }


      // UpdateData is called with temporal.timelineMoving to draw subset for
      // performance reasons.
      graphCtrl.updateData.call(
        graphCtrl.graph,
        graphCtrl.content,
        graphCtrl.temporal,
        scope.temporal && scope.temporal.timelineMoving
      );

      // Call the graph with the now
      if (scope.temporal && scope.temporal.at) {
        graphCtrl.updateNow.call(graphCtrl.graph, scope.temporal.at);
      }
    };

    var dimsChangedCb = function () {
      if (!scope.dimensions
        || (scope.dimensions.width === graphCtrl.graph.dimensions.width
          && scope.dimensions.height === graphCtrl.graph.dimensions.height)) {
        return;
      }
      graphCtrl.graph.resize(scope.dimensions);
      graphUpdateHelper();
    };

    /**
     * Calls updateGraph when data is different than controller.content.
     * NOTE: Controller data is set on precompile.
     */
    var contentWatch = scope.$watch('content', function (n, o) {
      if (scope.data) {
        contentWatch();
        return;
      }
      graphUpdateHelper();
    }, true);

    /**
     * Support legacy single line graph api. Restructure data, and follow normal
     * flow throug content watch ^.
     */
    var dataWatch = scope.$watch('data', function (n, o) {
      if (scope.content) {
        dataWatch();
        return;
      }
      graphUpdateHelper();
    }, true);

    scope.$watch('temporal.at', function (n, o) {
      if (n === o) { return true; }
      if (scope.temporal && scope.temporal.at) {
        graphCtrl.updateNow.call(graphCtrl.graph, scope.temporal.at);
      }
    });

    scope.$watch('temporal.start', function (n, o) {
      if (n === o) { return true; }
      graphUpdateHelper();
    });

    scope.$watch('temporal.end', function (n, o) {
      if (n === o) { return true; }
      graphUpdateHelper();
    });

    scope.$watch('dimensions.height', dimsChangedCb);

    scope.$watch('dimensions.width', dimsChangedCb);

    /**
     * Destroy graph to remove listeners when scope is erased.
     */
    scope.$on('$destroy' , function () { graphCtrl.graph.destroy(); });

    scope.title = attrs.name;

  };

  /**
   * @function
   * @memberOf graph
   * @param {scope}     $scope    local scope
   * @param {Graph}     Graph     graph service
   * @description       Stores the graph directives data and update functions
   */
  graphCtrl = function ($scope, Graph) {

    this.setData = function (scope) {
      // Provide defaults for backwards compatability
      this.content = scope.content || [];
      this.temporal = scope.temporal;
    };

    /**
     * Support legacy graph api. Formats scope.data, scope.labels and scope.keys
     * to a scope.content object with a single graph object.
     */
    this.setFormattedContent = function (scope) {
      this.temporal = scope.temporal;
      this.content = [{
        id: 1, // Give an arbitrary id to identify chart in multi line.
        data: scope.data,
        unit: scope.ylabel,
        xLabel: scope.xlabel,
        keys: {
          x: (scope.keys && scope.keys.x) || 0,
          y: (scope.keys && scope.keys.y) || 1
        }
      }];

    };

    if ($scope.content) {
      this.setData($scope);
    }
    // Support legacy graph api
    else if ($scope.data) {
      this.setFormattedContent($scope);
    }

    this.graph = {};
    this.yfilter = '';
    this.now = $scope.temporal ? $scope.temporal.at : undefined;
    this.type = '';
    this.quantity = $scope.quantity || 'time';

    this.mouseloc = $scope.mouseloc || undefined;

    // Define data update function in attribute directives
    this.updateData = function () {};
    // Define timeState.now update function in attribute directives
    this.updateNow = function () {};
  };


  return {
    controller: graphCtrl,
    compile: function (scope, element, attrs, graphCtrl) {
      return {
        pre: preCompile,
        post: link
      };
    },
    scope: {
      content: '=?',

      mouseloc: '=?',
      yfilter: '=',
      dimensions: '=',
      temporal: '=',

      // Legacy, use list of graph datasets in content. This is for line and
      // other old graphs.
      data: '=?',
      xlabel: '=?',
      ylabel: '=?',
      keys: '=?'
    },
    restrict: 'E',
    replace: true,
    templateUrl: 'graph/graph.html'
  };

}]);


/**
 * @ngdoc directive
 * @class graph
 * @memberof graph
 * @name line
 * @requires graph
 * @description       Draws a line. Additionally it sets the
 *                    location of the users mouse on the parent
 *                    scope. It was initially written for the
 *                    interction and maaiveldcurve.
 * @TODO: enhance its functionality to draw timeseries.
 */
angular.module('lizard-nxt')
  .directive('line', [function () {

  var link = function (scope, element, attrs, graphCtrl) {
    var content = graphCtrl.content,
        graph = graphCtrl.graph,
        temporal = graphCtrl.type === 'temporal',
        drawSubset = false;

    graph.drawLine(content, temporal, drawSubset);

    // fugly ass hackery. This is a sacrifice to Baal for
    // letting the 'bolletje' run loose and creating havock
    // and mayhem all around itself
    // the initiator of this heinous feature is too be blamed.
    //
    // The mouseOnLine in the state is being set to get this to work.
    var watchMouse = scope.$watch('mouseloc', function (n) {
      if (n) {
        graph.drawCircleOnLine(n);
      }
    });

    scope.$on('$destroy', function () {
      var remove = true;
      watchMouse();
      graph.drawCircleOnLine(null, remove);
    });

    if (temporal) {
      graph.drawNow(graphCtrl.now);
      // Function to call when timeState.at changes
      graphCtrl.updateNow = graph.drawNow;
    }

    // Function to call when data changes
    graphCtrl.updateData = graph.drawLine;

  };

  return {
    require: 'graph',
    link: link,
    restrict: 'A'
  };
}]);


/**
 * @ngdoc directive
 * @class graph
 * @memberof graph
 * @name barChart
 * @requires graph
 * @description       Draws a barchart. With dynamic axis label.
 *                    Initially written for the rain graph.
 */
angular.module('lizard-nxt')
  .directive('barChart', ['$filter', function ($filter) {

  var link = function (scope, element, attrs, graphCtrl) {

    var content = graphCtrl.content,
        filter = graphCtrl.yfilter,
        graph = graphCtrl.graph,
        quantity = graphCtrl.quantity;

    // Apply the filter on the ylabel to go from aggWindow
    // in ms to a nice 'mm/dag' label. This could be migrated
    // to the html, but filtering from the DOM is expensive
    // in angular.
    if (filter) {
      console.log('TODO: filter label on bar chart');
      // TODO: labels.y = $filter(filter)(labels.y);
    }

    graph.drawBars(content, quantity);
    graph.drawNow(graphCtrl.now);

    // Function to call when data changes
    graphCtrl.updateData = function (content, temporal) {
      if (filter) {
        console.log('TODO: filter label on bar chart');
        // TODO: labels.y = $filter(filter)(labels.y);
      }
      this.drawBars(content, quantity);
    };

    // Function to call when timeState.at changes
    graphCtrl.updateNow = graph.drawNow;

  };

  return {
    require: 'graph',
    link: link,
    restrict: 'A'
  };

}]);


/**
 * @ngdoc directive
 * @class graph
 * @memberof graph
 * @name horizontal stack
 * @requires graph
 * @description       Draws a barchart. With dynamic axis label.
 *                    Initially written to substitute the landuse donut.
 */
angular.module('lizard-nxt')
  .directive('horizontalStack', [function () {

  var link = function (scope, element, attrs, graphCtrl) {

    var graph = graphCtrl.graph;

    graph.drawHorizontalStack(graphCtrl.content);
    // Function to call when data changes
    graphCtrl.updateData = graph.drawHorizontalStack;

  };

  return {
    require: 'graph',
    link: link,
    restrict: 'A'
  };

}]);


/**
 * Creates a specific line and point graph for levee crosssections.
 *
 * Content should contain property line for elevation data and the property
 * points for timeseries values of wells.
 */
angular.module('lizard-nxt')
.directive('crossSection', [function () {
  var link = function (scope, element, attrs, graphCtrl) {

    var content = graphCtrl.content,
        graph = graphCtrl.graph;

    graph.drawCrosssection(content);

    // Function to call when data changes
    graphCtrl.updateData = graph.drawCrosssection;

    };

    return {
      require: 'graph',
      link: link,
      restrict: 'A'
    };

  }
]);


/**
 * Initialise angular.module('dashboard')
 *
 */
angular.module('dashboard', ['image-carousel', 'timeseries']);

'use strict';

angular.module('dashboard')
.service('DashboardService', ['EventAggregateService', 'State', function (EventAggregateService, State) {

  this.GRAPH_PADDING = 13; // Padding around the graph svg. Not to be confused
                          // with the padding inside the svg which is used for
                          // axis and labels.
  var ROW_BOTTOM_MARGIN = 20; // Pixels between graph rows.


  /**
   * Combines timeseries, with other chartable active data to dashboard data.
   *
   * Graphs are an array of graph-directive objects representing timeseries
   * and raster data.
   * {
   *   'type': 'type',
   *   content: [{
   *     data: [],
   *     keys: {},
   *     labels: {},
   *     color: ''
   *   }]
   * }
   *
   * @param  {array} graphs     Currently plotted graphs.
   * @param  {array} timeseries Data source timeseries from timseriesService.
   * @param  {array} assets     Data source DataService.assets.
   * @param  {array} geometries Data source DataService.geometries.
   * @return {array} graph
   */
  this.buildGraphs = function (graphs, timeseries, assets, geometries) {

    timeseries.forEach(function (ts) {
      ts.updated = true;
      if (graphs[ts.order]) {
        // Check if timeseries is already in the plot, if so replace data.
        var partOfContent =_.find(graphs[ts.order].content, function (c) {
          return c.id === ts.id;
        });
        if (partOfContent) {
          partOfContent.data = ts.data;
          partOfContent.color = ts.color;
          // Keep this graph
          partOfContent.updated = true;
        } else {
          graphs[ts.order].content.push(ts);
        }
      }
      else {
        var content = [ts];
        graphs[ts.order] = { 'content': content };
      }

      graphs[ts.order].type = ts.valueType === 'image' ? 'image' : 'temporalLine';

    });

    assets.forEach(function (asset) {
      graphs = addPropertyData(graphs, asset.properties);

      // Specific logic to add crosssections. We could abstract this to all
      // assets with children that have timeseries.
      if (asset.entity_name === 'leveecrosssection'
        && asset.crosssection && asset.crosssection.active) {
        graphs[asset.crosssection.order] = {
          'type': 'crosssection',
          'content': [asset]
        };
        graphs[asset.crosssection.order].content[0].updated = true;
      }

    });

    geometries.forEach(function (geometry) {
      graphs = addPropertyData(graphs, geometry.properties);
    });

    // Add empty graphs for undefined items.
    _.forEach(graphs, function (graph, i) {
      if (graph === undefined) {
        graphs[i] = {'type': 'empty', content: [{updated: true}]};
      }
    });

    // Remove all graphs that have not been updated or are empty.
    _.forEach(graphs, function (g, i) {
      g.content = _.filter(g.content, function (c) { return c.updated; });
      _.forEach(g.content, function (c) { c.updated = false; });
      if (g.content.length === 0) {
        graphs.splice(i, 1);
      }
    });

    return graphs;
  };

  /**
   * Creates a dimensions object for graph-directive.
   *
   * @param  {angular element} element   element to draw graphs in.
   * @param  {[int}            nGraphs   number of graphs in dashboard.
   * @param  {boolean}         showXAxis should be true for non temporal graphs.
   * @return {object}          dimension object per graph.
   */
  this.getDimensions = function (element, nGraphs, showXAxis) {
    var AXIS_LABEL_SPACE = 60;
    var AXIS_DEFAULT_SPACE = 15;
    var PAD = 10;
    var PAD_RIGHT = 40;
    return {
      width: element.width() - this.GRAPH_PADDING,
      height: getGraphHeight(element, nGraphs),
      padding: {
        top: PAD,
        right: PAD_RIGHT,
        bottom: showXAxis ? AXIS_LABEL_SPACE : AXIS_DEFAULT_SPACE,
        left: AXIS_LABEL_SPACE
      }
    };
  };

  /**
   * Adds DataService.assets|geometries.properties to dashboard graphs object.
   *
   * @param {object} graphs     dashboard graph object.
   * @param {object} properties asset or geometries properties.
   */
  var addPropertyData = function (graphs, properties) {
    _.forEach(properties, function (property, slug) {
      if (property.active) {
        var type = '';
        var item = {};
        if (property.format !== 'Vector') {
          item = {
            data: property.data,
            keys: {x: 0, y: 1},
            unit: property.unit,
            // TODO: xLabel is not always meters.
            xLabel: 'm'
          };

          if (slug === 'rain') {
            type = 'rain';
          } else if (property.temporal) {
            type = 'temporalLine';
          } else {
            type = 'distance';
          }
        }
        else if (property.format === 'Vector') {
          item = {
            data: EventAggregateService.aggregate(
              property.data,
              State.temporal.aggWindow,
              property.color
            ),
            keys: {
              x: 'timestamp',
              y: 'count',
              color: 'color',
              category: 'category'
            },
            unit: property.unit,
          };

          type = 'event';
        }
        graphs[property.order] = { type: type, content: [item] };
        var indexOflast = graphs[property.order].content.length - 1;
        graphs[property.order].content[indexOflast].updated = true;
      }
    });
    return graphs;
  };

  var getGraphHeight = function (element, nGraphs) {
    return (element.height() - ROW_BOTTOM_MARGIN * nGraphs) / nGraphs;
  };


}]);

'use strict';

/**
 * Collects crosssection data from api and creates a graph content object.
 */
angular.module('dashboard')
.directive('crossSection', [
  'TimeseriesService',
  'CabinetService',
  'UtilService',
  function (TimeseriesService, CabinetService, UtilService) {

    var link = function (scope, element, attrs) {

      // Contains content for crosssection graph.
      var content = {
        line: {
          data: [],
          keys: {x:0, y:1}
        },
        points: []
      };

      var tsData = [];

      // Get timeseries ids of monitoring wells
      var timeseriesIds = [];
      scope.asset.monitoring_wells.forEach(function(well) {
        well.timeseries.forEach(function (ts) {
          if (ts.parameter === 'Stijghoogte') {
            timeseriesIds.push(ts.uuid);
          }
        });
      });


      // Get elevation
      var coords = scope.asset.geometry.coordinates;

      CabinetService.raster().get({
        raster_names: 'dem/nl',
        srs: 'EPSG:4326',
        geom: 'LINESTRING(' + coords[0][0]
          + ' ' + coords[0][1]
          + ',' + coords[1][0]
          + ' ' + coords[1][1]
          + ')'
      }).then(function (response) {
        content.line.data = response.data;
        scope.content = content; // bind content to scope to start drawing
                                 // graph.
      });

      /** Gets timeseries using TimeseriesService .*/
      var getTimeseries = function (timeseries, timeState) {
        TimeseriesService
        ._getTimeseries(timeseries, timeState, TimeseriesService.minPoints)
        .then(function (result) {
          tsData = [];
          result.forEach(function (ts) {
            tsData.push(ts);
          });
          setTimeseriesToAt(tsData, timeState.at);
        });
      };

      /**
       * Updates content to contain the data in the ts beloning to at.
       *
       * @param {array}  timeseries list of timeseries.
       * @param {int}    at         virtual now.
       */
      var setTimeseriesToAt = function (timeseries, at) {
        content.points = [];
        timeseries.forEach(function (ts) {
          var i = UtilService.bisect(ts.data, 'timestamp', at);
          if (i !== undefined) {

            // Get the well of timeseries and the ts.
            var wellTs; // stores linked property, needed to include or exclude
                        // timeseries values from cross section interpolation.
            var well = _.find(scope.asset.monitoring_wells, function(well) {
              return _.some(well.timeseries, function (mwts) {
                if (mwts.uuid === ts.id) { wellTs = mwts; }
                return mwts.uuid === ts.id;
              });
            });

            content.points.push({
              id: ts.id,
              value: ts.data[i].max,
              x: well.distance_along_crosssection,
              linked: wellTs.linked
            });

            content.points = _.sortBy(content.points, 'x');

          }
        });
      };

      scope.$watch('temporal.timelineMoving', function () {
        getTimeseries(timeseriesIds, scope.temporal);
      });

      scope.$watch('temporal.at', function () {
        setTimeseriesToAt(tsData, scope.temporal.at);
      });

    };

    return {
      link: link,
      restrict: 'E',
      scope: {
        asset: '=',
        dimensions: '=',
        temporal: '='
      },
      templateUrl: 'dashboard/crosssection.html'
    };

  }
]);


angular.module('dashboard')
.directive('dashboard', [
  'State',
  'DataService',
  'TimeseriesService',
  'DashboardService',
  'DragService',
  function (
    State,
    DataService,
    TimeseriesService,
    DashboardService,
    DragService
  ) {

    var link = function (scope, element, attrs) {

      scope.dashboard = {
        graphs: [],
        state: State
      };

      var buildDashboard = function () {

        TimeseriesService.minPoints =
          element.width() - DashboardService.GRAPH_PADDING;

        scope.dashboard.graphs = DashboardService.buildGraphs(
          scope.dashboard.graphs,
          TimeseriesService.timeseries,
          DataService.assets,
          DataService.geometries
        );

        _.forEach(scope.dashboard.graphs, function (graph) {
          graph.dimensions = DashboardService.getDimensions(
            element,
            scope.dashboard.graphs.length,
            graph.type === 'distance' || graph.type === 'crosssection' // give space for axis.
          );
        });
      };

      DataService.onAssetsChange = buildDashboard;
      DataService.onGeometriesChange = buildDashboard;
      TimeseriesService.onTimeseriesChange = buildDashboard;

      /**
       * Update dashboard when timeline has moved.
       */
      scope.$watch(State.toString('temporal.timelineMoving'), function (off) {
        if (!State.temporal.timelineMoving) {
          TimeseriesService.syncTime();
        }
      });

      var applyResize = function () {
        scope.$apply(buildDashboard);
      };

      window.addEventListener('resize', applyResize);

      scope.$on('$destroy', function () {
        window.removeEventListener('resize', applyResize);
        DataService.onAssetsChange = null;
        DataService.onGeometriesChange = null;
        TimeseriesService.onTimeseriesChange = null;
      });

      // Make dashboard a dropable element.
      DragService.addDropZone(element);

    };

    return {
      link: link,
      templateUrl: 'dashboard/dashboard.html',
      replace: true,
      restrict: 'E'
    };

  }

]);

/**
 * Initialise angular.module('scenarios')
 *
 */
angular.module('scenarios', []);
'use strict';

angular.module('scenarios')
  .directive('scenarios', function () {
    var link =  function (scope) {
    };

  return {
    link: link,
    templateUrl: 'scenarios/scenarios.html',
    replace: false,
    restrict: 'E'
  };

});

'use strict';

angular.module('scenarios')
.controller("ScenariosCtrl", [
  "$scope",
  "Resource",
  "MapService",
  "DataService",
  "State", function ($scope, Resource, MapService, DataService, State) {

    var PAGE_SIZE = 10.0,
        TABLE_MARGIN = 150;

    $scope.scenarios = [];
    $scope.selectedScenario = null;

    // It is pretty imposible to make the table the right length without js.
    $scope.tableHeight = window.innerHeight - TABLE_MARGIN + 'px';

    $scope.page = 1;

    $scope.getPage = function (page) {
      if (!page) {
        page = $scope.page;
      }
      $scope.page = page;
      $scope.loading = true;
      new Resource.Endpoint('api/v2/scenarios/?page=' + page).get()
        .then(function (response) {
          $scope.next = (!!response.next);
          $scope.previous = (!!response.previous);
          $scope.loading = false;
          // get the amount of pages for the ng-repeater
          var pages = Math.ceil(response.count / PAGE_SIZE);
          $scope.pages = _.range(1, pages + 1);
          $scope.scenarios = response.results;
        });
    };

    $scope.getPage();

    /**
     * @description Selects or deselects scenario.
     *
     */
    $scope.select = function (scenario) {
      if ($scope.selectedScenario === null) {
        $scope.selectedScenario = scenario;
        new Resource.Endpoint('api/v2/scenarios/' + scenario.id + '/').get()
          .then(function (response) {
            angular.extend(scenario, response);
          });
      } else if (scenario.id === $scope.selectedScenario.id) {
        $scope.selectedScenario = null;
      } else {
        $scope.selectedScenario = scenario;
      }
    };

    $scope.preview = function (result) {
      if (result.layer_group && !result.lg) {
        result.lg = DataService.createLayerGroup(result.layer_group);
        MapService.fitBounds(result.lg.spatialBounds);
      }
      if (result.lg) {
        DataService.toggleLayerGroup(result.lg);
      }
    };

  }
]);

/**
 *
 * Initialize user-menu module
 *
 */
angular.module('user-menu', []);

/**
 *
 * Shows user-menu and has logout login buttons
 */
angular.module('user-menu')
  .directive('userMenu', ['UtilService', '$location', 'user',
              function (UtilService, $location, user) {

    var link = function (scope, element, attrs) {

      scope.user = user;
      scope.showApps = false;

      /**
       * Turn off either favourites or apps when click the on or the other
       */
      var toggleDashboardOrApps = function (e) {
        var favs = e === true;
        var lApps = document.querySelector('#lizard-apps-container');
        if (!lApps.classList.contains('hidden') && favs) {
          lApps.classList.toggle('hidden');
        } else if (!favs) {
          scope.favourites.enabled = false;
        }
      };

      var appsScreenUrl = function () {
        var appsScreenSlug = UtilService.slugify($location.host());
        return "//apps.lizard.net/screens/" + appsScreenSlug + ".js";
      };

      var script = document.createElement('script');
      script.src = appsScreenUrl();
      script.onload = function () {
        if (typeof window.Lizard.startPlugins === 'function') {
          window.Lizard.startPlugins(); // jshint ignore:line
          scope.showApps = (element
            .find('#lizard-apps-button')
            .children().length > 0);
          scope.$digest();

          element.find('#lizard-apps-button').click(toggleDashboardOrApps);
        }
      };

      scope.$watch('favourites.enabled', toggleDashboardOrApps);

      document.head.appendChild(script);

    };

    return {
      restrict: 'E',
      link: link,
      templateUrl: 'user-menu/user-menu.html'
    };
  }]);

/**
 *
 * Initialize favourites module
 *
 */
angular.module('favourites', []);

/**
 * Service to handle favourites retrieval, creation and deletion.
 */
angular.module('favourites')
  // NOTE: inject TimeseriesService even though it is not used.
  // TimeseriesService defines State.selected.timeseries which may be restored
  // from favourite.
  .service("FavouritesService", ['$resource', 'State', 'gettextCatalog', 'UtilService', 'notie', 'TimeseriesService',
    function ($resource, State, gettextCatalog, UtilService, notie) {

      /* Create a resource for interacting with the favourites endpoint of the
       * API.
       *
       * Use a reconfigured 'query' so it actually returns an array of items.
       */
      var Favourites = $resource('/api/v2/favourites/:uuid/', {uuid:'@uuid'}, {
        'query': {
          method:'GET',
          isArray:true,
          transformResponse:
            function (data, headers) {
              var angularData = angular.fromJson(data);
              if ('results' in angularData) {
                return angularData.results;
              } else {
                return angularData;
              }
            }
         }
      });

      /**
       * Get all favourites from the API.
       * @param {dict} params - A dictionary of request params (e.g.
       *                        {'page_size': 10}).
       * @param {function} success - Execute this function on a successful GET.
       * @param {function} error - Execute this function on an unsuccessful
       *                           GET.
       */
      this.fetchAllFavourites = function (params, success, error) {
        return Favourites.query(params, success, error);
      };

      this.getFavourite = function(uuid, success, error) {
        return Favourites.get(
          {'uuid': uuid},
          function (response) {
            notie.alert(
              4,
              gettextCatalog.getString('Restoring favourite ') +
              response.name,
              3
            );
            success(response);
          },
          function (err) {
          if (err.status === 404) {
            notie.alert(
              3,
              gettextCatalog.getString('Whoops: favourite has been removed'),
              3
            );
          }
          else {
            notie.alert(
              3,
              gettextCatalog.getString(
                'Ay ay: Lizard could not retrieve your favourite'
              ),
              3
            );
          }
          error();
        });
      };

      /**
       * Add a new favourite to the API.
       * @constructor
       * @param {string} name - The name of the new favourite.
       * @param {object} state - The current state of the portal.
       * @param {function} success - Execute this function on a successful
       *                             POST.
       * @param {function} error - Execute this function when something goes
       *                           wrong with the POST.
       * @returns {object} - The new favourite.
       */
      this.createFavourite = function (name, state, success, error) {
        var data = {
          'name': name,
          'state': JSON.stringify(state)
        };

        return Favourites.save(data, success, error);
      };

      /**
       * Remove a favourite from the API.
       * @param {object} favourite - The favourite to be deleted.
       * @param {function} success - Execute this function on a successful
       *                             DELETE.
       * @param {function} error - Execute this function when something goes
       *                           wrong with the DELETE.
       */
      this.deleteFavourite = function (favourite, success, error) {
        return Favourites.delete({uuid: favourite.uuid}, success, error);
      };

      /**
       * @function
       * @description calculate the interval from the fav State
       * to the new state if the interval should be relative
       */
      var adhereTemporalStateToInterval = function (favtime) {
        // Physical now
        var now = Date.now();
        // Difference between now and the now back when the fav was made.
        var change = now - favtime.now;

        favtime.start += change;
        favtime.at  += change;
        favtime.end += change;
        favtime.now = null;
        favtime.relative = false; // Set relative back to default.
        return favtime;
      };

      /**
       * Replace the current portal state with the favourite state.
       * @param {object} favourite - The favourite to apply.
       */
      this.applyFavourite = function (favourite) {

        if (favourite.state.temporal.relative) {
          favourite.state.temporal = adhereTemporalStateToInterval(
            favourite.state.temporal
          );
        }

        // Use _.mergeWith to set the whole array to trigger functions of
        // properties.
        var arrayStates = ['all', 'active', 'timeseries', 'assets', 'geometries'];
        _.mergeWith(State, favourite.state, function (state, favstate, key, parent) {
          if (arrayStates.indexOf(key) !== -1) {
            state = favstate;
            return state;
          }
        });

        UtilService.announceMovedTimeline(State);

      };

      return this;
    }
  ]);

/**
 * @module
 * @description Show favourites menu.
 */
angular.module('favourites')
  .directive('favourites', [function () {

  var link = function (scope, element, attrs) {

    scope.favourites = {
      enabled: false
    };

    /**
     * Toggle the favourites.
     * @param {object} $event - Click event object.
     */
    scope.toggleFavourites = function($event) {
      scope.favourites.enabled = !scope.favourites.enabled;
      $event.stopPropagation();
    };

    /**
     * Collapse favourites on click outside the box.
     */
    scope.$watch('favourites.enabled', function () {
      if (scope.favourites.enabled === true) {
        $(document).bind('click', function(event){
          var isClickedElementChildOfPopup = element
            .find(event.target)
            .length > 0;

          if (!isClickedElementChildOfPopup) {
            scope.$apply( function () {
              scope.favourites.enabled = false;
            });
          }
        });
      }
    });
  };

  return {
    restrict: 'E',
    link: link,
    templateUrl: 'favourites/templates/favourites.html'
  };
  }]);

/**
 * @module
 * @description Show and delete favourites.
 */
angular.module('favourites')
  .directive('showFavourites',
             ['FavouritesService', 'notie', 'gettextCatalog', 'State',
              function (FavouritesService, notie, gettextCatalog, State) {

  var link = function (scope, element, attrs) {
    /**
     * Fill the favourites list with all the favourites returned by the
     * GET request.
     * @param {array} allFavourites - The array of favourite objects
     *                                returned by the GET request.
     * @param {dict} responseHeaders - Not actually used but required
     *                                 by $resource.
     */
    var fetchFavouritesSuccess = function (allFavourites, responseHeaders) {
      scope.favourites.data = allFavourites;
    };

    /**
     * Throw an alert and error when something went wrong with fetching the
     * favourites.
     * @param {dict} httpResponse - The httpResponse headers returned by the
     *                              GET request.
     */
    var fetchFavouritesError = function(httpResponse) {
      console.log(httpResponse);
      notie.alert(
        3, gettextCatalog.getString(
          "Oops! Something went wrong while fetching the favourites."));
      throw new Error(
        httpResponse.status + " - "
        + "Could not retrieve favourites:"
        + " " + httpResponse.config.url
        + ".");
    };

    FavouritesService.fetchAllFavourites(
      {'page_size': 0},
      fetchFavouritesSuccess,
      fetchFavouritesError);

    /**
     * Update the front-end to reflect a successful delete of an favourite.
     * @param {object} favourite - The deleted favourite.
     * @param {?} value - Not actually used but required by $resource.
     * @param {dict} responseHeaders - Not actually used but required
     *                                       by $resource.
     */
    var deleteFavouriteSuccess = function(
        favourite, value, responseHeaders) {
      scope.favourites.data.splice(
        scope.favourites.data.indexOf(favourite),
        1);
    };

    /**
     * Throw an alert and error when something went wrong with the deletion
     * of the favourite.
     * @param {dict} httpResponse - The httpResponse headers returned by the
     *                              DELETE.
     */
    var deleteFavouriteError = function(httpResponse) {
      console.log(httpResponse);
      notie.alert(3,
        gettextCatalog.getString(
          "Oops! Something went wrong while deleting the favourite."));
      throw new Error(
        httpResponse.status + " - "
        + "Could not delete previously retrieved favourite:"
        + " " + httpResponse.config.url
        + ".");
    };

    /**
     * Remove favourite from database when delete icon is clicked.
     * Update the front-end to reflect a successful delete or throw an alert
     * on error.
     * @param {object} favourite - The favourite to be deleted.
     */
    scope.deleteFavourite = function (favourite) {
      FavouritesService.deleteFavourite(
        favourite,
        deleteFavouriteSuccess.bind(undefined, favourite),
        deleteFavouriteError);
    };

    scope.selectFavourite = function (favourite) {
      FavouritesService.applyFavourite(favourite);
    };
  };

  return {
    restrict: 'E',
    link: link,
    templateUrl: 'favourites/templates/favourites-show.html'
  };
  }]);

/**
 * @module
 * @description Create favourites.
 */
angular.module('favourites')
  .directive('addFavourites',
             ['FavouritesService', 'notie', 'gettextCatalog', 'State',
              function (FavouritesService, notie, gettextCatalog, State) {

  var link = function (scope, element, attrs) {
    /**
     * Reset (empty) the favourites form.
     */
    scope.resetForm = function() {
      scope.favourite.name = angular.copy(null);
      scope.favouritesForm.$setPristine();
    };

    /**
     * Update the front-end to reflect a successful creation of a favourite.
     * @param {object} favourite - The newly created favourite.
     * @param {dict} responseHeaders - The response headers returned by POST.
     */
    var createFavouriteSuccess = function(favourite, responseHeaders){
      scope.favourites.data.splice(0, 0, favourite);
    };

    /**
     * Throw an alert and error when something went wrong with the creation
     * of the favourite.
     * @param {dict} httpResponse - The httpResponse headers returned by the
     *                              POST.
     */
    var createFavouriteError = function(httpResponse){
      notie.alert(3,
        gettextCatalog.getString(
          "Oops! Something went wrong while creating the favourite."));
      throw new Error(
        httpResponse.status + " - " + "Could not create favourite.");
    };

    /**
     * Create a new favourite with the current portal state.
     */
    scope.createFavourite = function () {
      var oldRelativeVal = !!State.temporal.relative;
      State.temporal.relative = scope.favourite.relative;

      // if the time is temporal save the now to calculate the
      // intervals
      if (State.temporal.relative) {
        State.temporal.now = Date.now();
      }

      FavouritesService.createFavourite(
        scope.favourite.name,
        State,
        createFavouriteSuccess,
        createFavouriteError
      );
      State.temporal.relative = oldRelativeVal;
    };
  };

  return {
    restrict: 'E',
    link: link,
    templateUrl: 'favourites/templates/favourites-add.html'
  };
  }]);

/**
 * @module
 * @description Share favourites.
 */
angular.module('favourites')
  .directive('shareFavourites', ['$window', function ($window) {

    var link = function (scope, element, attrs) {

      scope.shareFavourite = function (favourite) {
        scope.favouriteURL = $window.location.origin +
          '/favourites/' +
          favourite.uuid;
      };
    };

    return {
      restrict: 'E',
      link: link,
      templateUrl: 'favourites/templates/favourites-share.html'
    };
  }]);

angular.module('data-menu')
  .directive('singleClick', ['$parse', function ($parse) {
    return {
      restrict: 'A',
      link: function (scope, element, attr) {
        var fn = $parse(attr.singleClick);
        var delay = 300,
            clicks = 0,
            timer = null;

        element.on('click', function (event) {
          clicks++;  //count clicks
          if (clicks === 1) {
            timer = setTimeout(function () {
              scope.$apply(function () {
                fn(scope, { $event: event });
              });
              clicks = 0;             //after action performed, reset counter
            }, delay);
          } else {
            clearTimeout(timer);    //prevent single-click action
            clicks = 0;             //after action performed, reset counter
          }
        });
      }
    };
  }
]);
/**
 * Opacity slider for layer-chooser.
 */
angular.module('data-menu')
  .directive('opacitySlider', function () {

  var link = function (scope, element, attrs) {
    var opacity = scope.layergroup.getOpacity();
    scope.percOpacity = opacity * 100 + '%';
    var layerChooserWidth = 170; // chrome is the new IE
    var localClick;

    /**
     * @description captures the location of click
     * and calculates the percentage of the width.
     * @params {event} jQuery event.
     */
    var adjustOpacity = function (e) {
      e.preventDefault();
      localClick = (e.originalEvent.layerX < 0) ? e.offsetX : e.originalEvent.layerX;
      if (localClick === undefined) {
        localClick = e.originalEvent.changedTouches[0].offsetX;
      }
      var newOpacity = localClick / layerChooserWidth;
      scope.$apply(function () {
        scope.percOpacity = newOpacity * 100 + '%';
      });

      scope.layergroup.setOpacity(newOpacity);

    };

    element.bind('click', adjustOpacity);
    element.bind('touch', adjustOpacity);
  };

  return {
    link: link,
    templateUrl: 'opacity/opacity.html',
    restrict: 'E',
    replace: true
  };
});

//layer-directive.js

angular.module('data-menu')
.directive("baselayerChooser", ['DataService', function (DataService)
{
  var link = function (scope) {

    var _allBLGs = DataService.baselayerGroups,
        _allBLGSlugs = _.map(_allBLGs, "slug"),
        _getActiveBLG = function () {
          return _.filter(_allBLGs, function (blg) {
            return blg.isActive();
          })[0];
        };

    scope.getNextInactiveBLG = function () {
      var activeBLGIndex = 0;
      if (_getActiveBLG()) {
        activeBLGIndex = _allBLGSlugs.indexOf(_getActiveBLG().slug);
      }
      return _allBLGs[(activeBLGIndex + 1) % _allBLGs.length];
    };
  };

  return {
    link: link,
    templateUrl: 'layer-chooser/baselayer-chooser.html',
    restrict: 'E',
  };

}]);

//layer-directive.js

angular.module('data-menu')
  .directive("eventlayerChooser", [function () {

  var link = function (scope, element) {
    scope.showOpacitySlider = false;
    element.find('.layer-img')[0].style.backgroundColor = scope.layergroup.mapLayers[0].color;
  };

  return {
    link: link,
    templateUrl: 'layer-chooser/eventlayer-chooser.html',
    restrict: 'E',
  };
}]);

angular.module('templates-main', ['annotations/templates/annotations-make.html', 'annotations/templates/annotations-view.html', 'annotations/templates/annotations.html', 'dashboard/crosssection.html', 'dashboard/dashboard.html', 'data-menu/data-menu-item.html', 'data-menu/data-menu.html', 'data-menu/layer-adder.html', 'data-menu/layer-switcher.html', 'favourites/templates/favourites-add.html', 'favourites/templates/favourites-share.html', 'favourites/templates/favourites-show.html', 'favourites/templates/favourites.html', 'graph/graph.html', 'image-carousel/image-carousel.html', 'layer-chooser/baselayer-chooser.html', 'layer-chooser/eventlayer-chooser.html', 'layer-chooser/layer-chooser.html', 'omnibox/templates/asset-cards.html', 'omnibox/templates/card-header.html', 'omnibox/templates/cardattributes.html', 'omnibox/templates/close-card.html', 'omnibox/templates/color-picker.html', 'omnibox/templates/dashboard-cards.html', 'omnibox/templates/db-asset-card.html', 'omnibox/templates/db-cards.html', 'omnibox/templates/db-geometry-cards.html', 'omnibox/templates/defaultpoint.html', 'omnibox/templates/empty.html', 'omnibox/templates/full-details.html', 'omnibox/templates/geometry-cards.html', 'omnibox/templates/nestedasset.html', 'omnibox/templates/omnibox.html', 'omnibox/templates/rain.html', 'omnibox/templates/search-results.html', 'omnibox/templates/search.html', 'omnibox/templates/summary-card.html', 'opacity/opacity.html', 'scenarios/scenarios.html', 'timeline/timeline.html', 'timeseries/timeseries.html', 'user-menu/user-menu.html']);

angular.module("annotations/templates/annotations-make.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("annotations/templates/annotations-make.html",
    "<form name=\"annotationform\" novalidate>\n" +
    "  <table class=\"table table-condensed table-no-borders\">\n" +
    "    <colgroup>\n" +
    "      <col class=\"col-xs-7\"></col>\n" +
    "      <col class=\"col-xs-3\"></col>\n" +
    "      <col class=\"col-xs-2\"></col>\n" +
    "    </colgroup>\n" +
    "    <tbody>\n" +
    "      <tr>\n" +
    "        <td>\n" +
    "          <input type=\"text\"\n" +
    "                 class=\"form-control input-sm\"\n" +
    "                 name=\"text\"\n" +
    "                 ng-maxlength=256\n" +
    "                 required\n" +
    "                 ng:model=\"text\"\n" +
    "                 placeholder=\"<% 'Annotation message...'|translate %>\">\n" +
    "          <div\n" +
    "            ng-show=\"annotationform.text.$dirty && annotationform.text.$invalid\">\n" +
    "            <small\n" +
    "              class=\"text-danger\"\n" +
    "              ng-show=\"annotationform.text.$error.required\"\n" +
    "              translate>\n" +
    "              Annotation text is required.\n" +
    "            </small>\n" +
    "            <small\n" +
    "              class=\"text-danger\"\n" +
    "              ng-show=\"annotationform.text.$error.maxlength\"\n" +
    "              translate>\n" +
    "              Annotation text cannot be longer than 256 characters.\n" +
    "            </small>\n" +
    "          </div>\n" +
    "        </td>\n" +
    "        <td class=\"text-right\">\n" +
    "          <span ng-bind=\"timelineat | date: formatDatetime()\"></span>\n" +
    "        </td>\n" +
    "        <td>\n" +
    "          <button\n" +
    "            class=\"btn btn-link\"\n" +
    "            ng-disabled=\"annotationform.$invalid\"\n" +
    "            ng-click=\"createAnnotation()\">\n" +
    "            <i class=\"fa fa-plus\"></i>\n" +
    "          </button>\n" +
    "          &nbsp;\n" +
    "          <button\n" +
    "            class=\"btn btn-link\"\n" +
    "            ng-disabled=\"annotationform.$pristine\"\n" +
    "            ng-click=\"resetForm()\">\n" +
    "            <i class=\"fa fa-times text-danger\"></i>\n" +
    "          </button>\n" +
    "        </td>\n" +
    "      </tr>\n" +
    "      <tr ng-show=\"annotationform.text.$dirty\">\n" +
    "        <td colspan=\"2\">\n" +
    "          <span translate>Add an attachment:</span>\n" +
    "          <input type=\"file\"\n" +
    "                 class=\"input-sm\"\n" +
    "                 name=\"attachment\"\n" +
    "                 ng:model=\"fileupload\"\n" +
    "                 file-model=\"attachment\"\n" +
    "                 max-file-size=10000000>\n" +
    "          <div ng-show=\"annotationform.attachment.$dirty && annotationform.attachment.$invalid\">\n" +
    "            <small\n" +
    "              class=\"text-danger\"\n" +
    "              ng-show=\"annotationform.attachment.$error.maxFileSize\"\n" +
    "              translate>\n" +
    "              Annotation attachment size cannot be bigger than 10MB.\n" +
    "            </small>\n" +
    "          </div>\n" +
    "          <div ng-hide=\"user.organisations.length === 1\">\n" +
    "          <span translate>Select an organisation:</span><br>\n" +
    "          <select\n" +
    "            ng-options=\"org as org.name for org in user.organisations track by org.unique_id\"\n" +
    "            ng-model=\"selectedOrganisation\"></select>\n" +
    "        </div>\n" +
    "        </td>\n" +
    "        <td></td>\n" +
    "      </tr>\n" +
    "    </tbody>\n" +
    "  </table>\n" +
    "</form>\n" +
    "");
}]);

angular.module("annotations/templates/annotations-view.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("annotations/templates/annotations-view.html",
    "<div ng-if=\"annotations.length > 0\">\n" +
    "  <table class=\"table table-hover table-condensed\">\n" +
    "    <colgroup>\n" +
    "      <col class=\"col-xs-7\"></col>\n" +
    "      <col class=\"col-xs-3\"></col>\n" +
    "      <col class=\"col-xs-2\"></col>\n" +
    "    </colgroup>\n" +
    "    <tbody>\n" +
    "      <tr ng-repeat=\"obj in annotations track by obj.id\">\n" +
    "        <td><% obj.properties.text %></td>\n" +
    "        <td class=\"text-right\">\n" +
    "          <span ng-bind=\"obj.properties.timestamp | date: formatDatetime()\"></span>\n" +
    "        </td>\n" +
    "        <td class=\"text-right\">\n" +
    "          <a target=\"_blank\"\n" +
    "             href=\"<% obj.properties.attachment_url %>\"\n" +
    "             title=\"<% 'Download attachment.'|translate %>\"\n" +
    "             ng-if=\"obj.properties.attachment_url\">\n" +
    "            <i class=\"fa fa-download\"></i>\n" +
    "          </a>&nbsp;\n" +
    "          <a class=\"clickable\"\n" +
    "             title=\"<% 'Delete this annotation from the database.'|translate %>\"\n" +
    "             ng-click=\"deleteAnnotation(obj)\">\n" +
    "            <i class=\"fa fa-trash text-danger\"></i>\n" +
    "          </a>\n" +
    "        </td>\n" +
    "      </tr>\n" +
    "    </tbody>\n" +
    "  </table>\n" +
    "</div>\n" +
    "");
}]);

angular.module("annotations/templates/annotations.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("annotations/templates/annotations.html",
    "<div class=\"annotations card active\">\n" +
    "  <div class=\"card-content\">\n" +
    "    <span class=\"card-title\">\n" +
    "      <span class=\"card-title-text\"\n" +
    "            ng-if=\"annotations.length > 0\"\n" +
    "            translate\n" +
    "            translate-n=\"annotations.length\"\n" +
    "            translate-plural=\"<% $count %> annotations\">One annotation</span>\n" +
    "\n" +
    "      <span class=\"card-title-text\"\n" +
    "            ng-if=\"annotations.length == 0\"\n" +
    "            translate>Add an annotation</span>\n" +
    "    </span>\n" +
    "\n" +
    "    <full-details></full-details>\n" +
    "\n" +
    "    <annotations-view\n" +
    "      ng-class=\"{ hidden: !fullDetails }\"\n" +
    "      data=\"data\"\n" +
    "      time-state=\"timeState\"\n" +
    "      annotations=\"annotations\">\n" +
    "    </annotations-view>\n" +
    "    <annotations-make\n" +
    "      ng-class=\"{ hidden: !fullDetails }\"\n" +
    "      data=\"data\"\n" +
    "      timelineat=\"timeState.at\"\n" +
    "      annotations=\"annotations\">\n" +
    "    </annotations-make>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("dashboard/crosssection.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("dashboard/crosssection.html",
    "<div>\n" +
    "  <graph\n" +
    "    ng-if=\"content\"\n" +
    "    cross-section\n" +
    "    content=\"content\"\n" +
    "    dimensions=\"dimensions\">\n" +
    "  </graph>\n" +
    "</div>\n" +
    "");
}]);

angular.module("dashboard/dashboard.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("dashboard/dashboard.html",
    "<div class=\"dashboard-wrapper drag-target\">\n" +
    "\n" +
    "  <!-- Use track by to keep references to dom elements and prevent redraws -->\n" +
    "  <!-- Store index on dom element for drag and drop functionality -->\n" +
    "  <div\n" +
    "    ng-if=\"item.type !== 'empty'\"\n" +
    "    ng-repeat=\"item in dashboard.graphs track by $index\"\n" +
    "    data-order=\"<% $index %>\"\n" +
    "    class=\"row dashboard-inner drag-target\">\n" +
    "\n" +
    "    <graph\n" +
    "      ng-if=\"item.type === 'temporalLine'\"\n" +
    "      line\n" +
    "      content=\"item.content\"\n" +
    "      temporal=\"dashboard.state.temporal\"\n" +
    "      type=\"temporal\"\n" +
    "      dimensions=\"item.dimensions\">\n" +
    "     </graph>\n" +
    "\n" +
    "    <graph\n" +
    "      ng-if=\"item.type === 'distance'\"\n" +
    "      line\n" +
    "      content=\"item.content\"\n" +
    "      dimensions=\"item.dimensions\">\n" +
    "    </graph>\n" +
    "\n" +
    "    <graph\n" +
    "      ng-if=\"item.type === 'rain'\"\n" +
    "      bar-chart\n" +
    "      content=\"item.content\"\n" +
    "      type=\"temporal\"\n" +
    "      temporal=\"dashboard.state.temporal\"\n" +
    "      dimensions=\"item.dimensions\">\n" +
    "    </graph>\n" +
    "\n" +
    "    <graph\n" +
    "      ng-if=\"item.type === 'event'\"\n" +
    "      bar-chart\n" +
    "      content=\"item.content\"\n" +
    "      type=\"temporal\"\n" +
    "      temporal=\"dashboard.state.temporal\"\n" +
    "      dimensions=\"item.dimensions\">\n" +
    "    </graph>\n" +
    "\n" +
    "    <image-carousel\n" +
    "      ng-if=\"item.type === 'image'\"\n" +
    "      images=\"item.content[0].data\"\n" +
    "      context=\"dashboard\"\n" +
    "      temporal=\"dashboard.state.temporal\"\n" +
    "      dimensions=\"item.dimensions\">\n" +
    "    </image-carousel>\n" +
    "\n" +
    "    <cross-section\n" +
    "      ng-if=\"item.type === 'crosssection'\"\n" +
    "      asset=\"item.content[0]\"\n" +
    "      dimensions=\"item.dimensions\"\n" +
    "      temporal=\"dashboard.state.temporal\">\n" +
    "    </cross-section>\n" +
    "\n" +
    "  </div>\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("data-menu/data-menu-item.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("data-menu/data-menu-item.html",
    "<a ng-class=\"{'active': boxType === type}\"\n" +
    "   ng-click=\"changeBoxType()\"\n" +
    "   class=\"button-list-item clickable\">\n" +
    "   <i class=\"fa fa-<% icon %>\"></i>\n" +
    "</a>\n" +
    "");
}]);

angular.module("data-menu/data-menu.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("data-menu/data-menu.html",
    "<div ng-controller=\"DatamenuController as menu\">\n" +
    "    <div class=\"material-shadow\"\n" +
    "         ng-class=\"{'slide-left': menu.enabled,\n" +
    "                    'layer-adder-wrapper': menu.layerAdderEnabled,\n" +
    "                    'layer-switcher-wrapper': !menu.layerAdderEnabled,}\">\n" +
    "\n" +
    "      <layer-switcher\n" +
    "        ng-if=\"!menu.layerAdderEnabled\"\n" +
    "        layergroup=\"layergroup\"\n" +
    "        menu=\"menu\"></layer-switcher>\n" +
    "      <layer-adder\n" +
    "        menu=\"menu\"\n" +
    "        ng-if=\"menu.layerAdderEnabled\"></layer-adder>\n" +
    "\n" +
    "      <div class=\"button-list-container\" ng-if=\"context === 'map' || context === 'scenarios'\">\n" +
    "        <div class=\"button-list-item compass\"\n" +
    "             ng-click=\"menu.enabled = !menu.enabled\">\n" +
    "          <span class=\"fa\" ng-class=\"{\n" +
    "                  'fa-spinner fa-spin': menu.state.gettingData,\n" +
    "                  'fa-compass': !menu.state.gettingData\n" +
    "                }\"\n" +
    "                title=\"<% menu.enabled ? tooltips.closeMenu : tooltips.openMenu %>\">\n" +
    "          </span>\n" +
    "        </div>\n" +
    "        <datamenu-item\n" +
    "          title=\"<% 'Point selection' | translate %>\"\n" +
    "          box-type=\"menu.box.type\"\n" +
    "          type=\"point\" icon=\"map-marker\"></datamenu-item>\n" +
    "        <datamenu-item\n" +
    "          title=\"<% 'Select Multiple Points' | translate %>\"\n" +
    "          box-type=\"menu.box.type\"\n" +
    "          type=\"multi-point\" icon=\"th\"></datamenu-item>\n" +
    "        <datamenu-item\n" +
    "          title=\"<% 'Line selection' | translate %>\"\n" +
    "          box-type=\"menu.box.type\"\n" +
    "          type=\"line\" icon=\"expand\"></datamenu-item>\n" +
    "        <datamenu-item\n" +
    "          title=\"<% 'Region selection' | translate %>\"\n" +
    "          box-type=\"menu.box.type\"\n" +
    "          type=\"region\" icon=\"lemon-o\"></datamenu-item>\n" +
    "        <datamenu-item\n" +
    "          title=\"<% 'View selection' | translate %>\"\n" +
    "          box-type=\"menu.box.type\"\n" +
    "          type=\"area\" icon=\"square-o\"></datamenu-item>\n" +
    "    </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("data-menu/layer-adder.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("data-menu/layer-adder.html",
    "<div class=\"layer-adder\">\n" +
    "  <a class=\"go-back\"\n" +
    "     href=\"\"\n" +
    "     ng-click=\"menu.layerAdderEnabled = !menu.layerAdderEnabled\">\n" +
    "    <i class=\"fa fa-angle-left\"></i>&nbsp;&nbsp;Go back\n" +
    "  </a>\n" +
    "  <input ng-model=\"searchLayerGroups\"\n" +
    "         placeholder=\"Filter layers...\"\n" +
    "         class=\"material-shadow\" />\n" +
    "  <table class=\"table table-hover\">\n" +
    "    <tbody>\n" +
    "      <tr\n" +
    "        class=\"clickable\"\n" +
    "        ng-repeat=\"obj in availableLayerGroups.results\"\n" +
    "        ng-click=\"addLayerGroupToPortal(obj)\"\n" +
    "        ng-mouseenter=\"hovering=true\"\n" +
    "        ng-mouseleave=\"hovering=false\">\n" +
    "        <td>\n" +
    "          <i class=\"fa\"\n" +
    "             ng-class=\"hovering ? 'fa-plus' : 'fa-map'\">\n" +
    "          </i>\n" +
    "        </td>\n" +
    "        <td><% obj.name %></td>\n" +
    "        <td><% obj.description %></td>\n" +
    "      </tr>\n" +
    "    </tbody>\n" +
    "  </table>\n" +
    "  <uib-pagination total-items=\"availableLayerGroups.count\"\n" +
    "                  ng-model=\"layerGroupsCurrentPage\"\n" +
    "                  max-size=\"10\"\n" +
    "                  class=\"pagination-sm\"\n" +
    "                  boundary-link-numbers=\"true\"\n" +
    "                  rotate=\"false\"\n" +
    "                  previous-text=\"&laquo;\"\n" +
    "                  next-text=\"&raquo;\">\n" +
    "  </uib-pagination>\n" +
    "</div>\n" +
    "");
}]);

angular.module("data-menu/layer-switcher.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("data-menu/layer-switcher.html",
    "<div class=\"layer-switcher\">\n" +
    "  <ul class=\"list-group\">\n" +
    "    <li>\n" +
    "      <baselayer-chooser></baselayer-chooser>\n" +
    "    </li>\n" +
    "    <li ng-repeat=\"layergroup in menu.layerGroups | orderObjectBy: 'order': false\"\n" +
    "        ng-if=\"!(layergroup.isEventLayerGroup() || layergroup.baselayer)\">\n" +
    "      <layer-chooser layergroup=\"layergroup\">\n" +
    "      </layer-chooser>\n" +
    "    </li>\n" +
    "\n" +
    "    <li ng-repeat=\"layergroup in menu.layerGroups | orderObjectBy: 'order': false\"\n" +
    "        ng-if=\"layergroup.isEventLayerGroup() && !layergroup.baselayer\">\n" +
    "      <eventlayer-chooser layergroup=\"layergroup\">\n" +
    "      </eventlayer-chooser>\n" +
    "    </li>\n" +
    "    <li>\n" +
    "      <a class=\"layer-item add-data\"\n" +
    "         ng-click=\"menu.layerAdderEnabled = !menu.layerAdderEnabled\"\n" +
    "         href=\"\"\n" +
    "         translate>\n" +
    "        Add data&hellip;\n" +
    "        <div class=\"layer-chooser-tools\">\n" +
    "          <i class=\"fa fa-plus\"></i>\n" +
    "        </div>\n" +
    "      </a>\n" +
    "    </li>\n" +
    "  </ul>\n" +
    "</div>\n" +
    "");
}]);

angular.module("favourites/templates/favourites-add.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("favourites/templates/favourites-add.html",
    "<form name=\"favouritesForm\" novalidate>\n" +
    "  <table class=\"table table-hover table-no-borders\">\n" +
    "    <colgroup>\n" +
    "      <col class=\"col-sm-1\"></col>\n" +
    "      <col class=\"col-sm-9\"></col>\n" +
    "      <col class=\"col-sm-2\"></col>\n" +
    "    </colgroup>\n" +
    "    <tbody>\n" +
    "      <tr>\n" +
    "        <td>\n" +
    "        </td>\n" +
    "        <td>\n" +
    "          <input type=\"text\"\n" +
    "                 class=\"form-control input-sm\"\n" +
    "                 name=\"text\"\n" +
    "                 ng-maxlength=256\n" +
    "                 required\n" +
    "                 ng:model=\"favourite.name\"\n" +
    "                 placeholder=\"<% 'New favourite name...'|translate %>\" />\n" +
    "          <div\n" +
    "            ng-show=\"favouritesForm.favourite.name.$dirty && favouritesForm.favourite.name.$invalid\">\n" +
    "            <small\n" +
    "              class=\"text-danger\"\n" +
    "              ng-show=\"favouritesForm.favourite.name.$error.required\"\n" +
    "              translate>\n" +
    "              Favourite name is required.\n" +
    "            </small>\n" +
    "            <small\n" +
    "              class=\"text-danger\"\n" +
    "              ng-show=\"favouritesForm.favourite.name.$error.maxlength\"\n" +
    "              translate>\n" +
    "              Favourite name cannot be longer than 256 characters.\n" +
    "            </small>\n" +
    "          </div>\n" +
    "        </td>\n" +
    "        <td>\n" +
    "          <button\n" +
    "            class=\"btn btn-link\"\n" +
    "            ng-disabled=\"favouritesForm.$invalid\"\n" +
    "            ng-click=\"createFavourite()\">\n" +
    "            <i class=\"fa fa-plus text-primary\"></i>\n" +
    "          </button>\n" +
    "          &nbsp;\n" +
    "          <button\n" +
    "            class=\"btn btn-link\"\n" +
    "            ng-disabled=\"favouritesForm.$pristine\"\n" +
    "            ng-click=\"resetForm()\">\n" +
    "            <i class=\"fa fa-times text-danger\"></i>\n" +
    "          </button>\n" +
    "        </td>\n" +
    "      </tr>\n" +
    "      <tr>\n" +
    "        <td><input type=\"checkbox\" ng:model=\"favourite.relative\"></td>\n" +
    "        <td translate ng-click=\"favourite.relative = !favourite.relative\">Make time relative (sticky to the end)</td>\n" +
    "        <td></td>\n" +
    "      </tr>\n" +
    "    </tbody>\n" +
    "  </table>\n" +
    "</form>\n" +
    "");
}]);

angular.module("favourites/templates/favourites-share.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("favourites/templates/favourites-share.html",
    "<div ng-if=\"favouriteURL\">\n" +
    "  <hr></hr>\n" +
    "  Share your favourite by copying the following link (Ctrl-C):\n" +
    "  <!-- select text on click to accomate copying -->\n" +
    "  <input onClick=\"this.setSelectionRange(0, this.value.length)\" type=\"text\" value=\"<% favouriteURL %>\"></input>\n" +
    "</div>\n" +
    "");
}]);

angular.module("favourites/templates/favourites-show.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("favourites/templates/favourites-show.html",
    "<p ng-if=\"favourites.data.length == 0\" translate>\n" +
    "You don't have any favourites yet.<br />\n" +
    "Add the current portal state to your favourites!\n" +
    "</p>\n" +
    "<div class=\"favourites-show\">\n" +
    "  <table class=\"table table-hover table-no-borders\"\n" +
    "         ng-if=\"favourites.data.length > 0\">\n" +
    "    <colgroup>\n" +
    "      <col class=\"col-sm-1\"></col>\n" +
    "      <col class=\"col-sm-9\"></col>\n" +
    "      <col class=\"col-sm-2\"></col>\n" +
    "    </colgroup>\n" +
    "    <tbody>\n" +
    "      <tr ng-repeat=\"obj in favourites.data\">\n" +
    "        <td ng-click=\"selectFavourite(obj)\"\n" +
    "            class=\"clickable\">\n" +
    "          <i class=\"fa fa-star text-primary\"></i>\n" +
    "        </td>\n" +
    "        <td ng-click=\"selectFavourite(obj)\"\n" +
    "            class=\"clickable\">\n" +
    "          <% obj.name %>\n" +
    "        </td>\n" +
    "        <td>\n" +
    "          <button class=\"btn btn-link\"\n" +
    "                  title=\"Share favourite link\"\n" +
    "                  ng-click=\"shareFavourite(obj)\">\n" +
    "            <i class=\"fa fa-share-alt\"></i>\n" +
    "          </button>\n" +
    "          <button class=\"btn btn-link\"\n" +
    "                  ng-click=\"deleteFavourite(obj)\">\n" +
    "            <i class=\"fa fa-trash text-danger\"></i>\n" +
    "          </button>\n" +
    "        </td>\n" +
    "      </tr>\n" +
    "    </tbody>\n" +
    "  </table>\n" +
    "</div>\n" +
    "");
}]);

angular.module("favourites/templates/favourites.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("favourites/templates/favourites.html",
    "<div class=\"favourites material-shadow\" ng-if=\"favourites.enabled\">\n" +
    "  <show-favourites></show-favourites>\n" +
    "  <add-favourites></add-favourites>\n" +
    "  <share-favourites></share-favourites>\n" +
    "</div>\n" +
    "");
}]);

angular.module("graph/graph.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("graph/graph.html",
    "<div class=\"graph-svg-wrapper\">\n" +
    "  <span ng-bind=\"title\" ng-style=\"{'left': 10 + dimensions.padding.left + 'px'}\"></span>\n" +
    "  <svg></svg>\n" +
    "</div>\n" +
    "");
}]);

angular.module("image-carousel/image-carousel.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("image-carousel/image-carousel.html",
    "<div id=\"imageCarousel\" class=\"carousel slide\" data-interval=\"false\" ng-style=\"itemDimensions\">\n" +
    "\n" +
    "  <!-- Wrapper for slides -->\n" +
    "  <div class=\"carousel-inner\" role=\"listbox\">\n" +
    "    <div class=\"item\" ng-class=\"{active: $first}\" ng-repeat=\"img in images\">\n" +
    "      <img src=\"\" data-lazy-load-src=\"<% img.url %>\" data-timestamp=\"<% img.timestamp %>\" ng-style=\"dimensions\">\n" +
    "      <div class=\"carousel-caption\">\n" +
    "        <p><% img.timestamp | date:'yyyy-MM-dd HH:mm' %></p>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "\n" +
    "  <!-- Left and right controls -->\n" +
    "  <a class=\"left carousel-control clickable\" ng-click=\"slide('prev')\" role=\"button\" data-slide=\"prev\">\n" +
    "    <span class=\"glyphicon glyphicon-chevron-left\" aria-hidden=\"true\"></span>\n" +
    "    <span class=\"sr-only\">Previous</span>\n" +
    "  </a>\n" +
    "  <a class=\"right carousel-control clickable\" ng-click=\"slide('next')\" role=\"button\" data-slide=\"next\">\n" +
    "    <span class=\"glyphicon glyphicon-chevron-right\" aria-hidden=\"true\"></span>\n" +
    "    <span class=\"sr-only\">Next</span>\n" +
    "  </a>\n" +
    "</div>\n" +
    "");
}]);

angular.module("layer-chooser/baselayer-chooser.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("layer-chooser/baselayer-chooser.html",
    "<div class=\"noselect need-bottom-margin\">\n" +
    "    <!-- style=\"margin-bottom: 10px;\"> -->\n" +
    "\n" +
    "  <!-- special, \"baselayer\" menu-item (singular): -->\n" +
    "  <label class=\"layer-item\"\n" +
    "         ng-click=\"menu.toggleLayerGroup(getNextInactiveBLG())\"\n" +
    "         title=\"<% 'Baselayer' | translate %>\">\n" +
    "    <span><% getNextInactiveBLG().name %></span>\n" +
    "  </label>\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("layer-chooser/eventlayer-chooser.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("layer-chooser/eventlayer-chooser.html",
    "<div class=\"noselect need-bottom-margin\">\n" +
    "  <label\n" +
    "    single-click=\"menu.toggleLayerGroup(layergroup)\"\n" +
    "    ng-class=\"{active: layergroup.isActive()}\"\n" +
    "    class=\"layer-item layer-img\"\n" +
    "    for=\"<% layergroup.id %>-layer\"\n" +
    "    title=\"<% layergroup.name %>\"\n" +
    "    ng-style=\"layergroup.imageStyle\">\n" +
    "    <span ng-bind=\"layergroup.name\"></span>\n" +
    "    <div class=\"layer-chooser-tools\">\n" +
    "      <i class=\"fa fa-close\"\n" +
    "         ng-click=\"removeLayerGroup(layergroup); $event.stopPropagation()\"></i>\n" +
    "      <i\n" +
    "        ng-if=\"((layergroup.spatialBounds.north - layergroup.spatialBounds.east) !== 0)\n" +
    "               && layergroup.isActive()\"\n" +
    "        ng-click=\"menu.zoomToBounds(layergroup.spatialBounds, layergroup.temporalBounds); $event.stopPropagation()\"\n" +
    "        class=\"fa fa-crosshairs\">\n" +
    "      </i>\n" +
    "    </div>\n" +
    "  </label>\n" +
    "</div>\n" +
    "");
}]);

angular.module("layer-chooser/layer-chooser.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("layer-chooser/layer-chooser.html",
    "<div class=\"noselect\">\n" +
    "  <label\n" +
    "    single-click=\"menu.toggleLayerGroup(layergroup)\"\n" +
    "    ng-dblclick=\"layergroup.dblClick()\"\n" +
    "    ng-class =\"{active: layergroup.isActive()}\"\n" +
    "    class=\"layer-item layer-img\"\n" +
    "    for=\"<% layergroup.id %>-layer\"\n" +
    "    title=\"<% layergroup.name %>\"\n" +
    "    ng-style=\"layergroup.imageStyle\">\n" +
    "      <span ng-bind=\"layergroup.name\"></span>\n" +
    "      <div class=\"layer-chooser-tools\">\n" +
    "        <i class=\"fa fa-close\"\n" +
    "           ng-click=\"removeLayerGroup(layergroup); $event.stopPropagation()\"></i>\n" +
    "        <i\n" +
    "          ng-if=\"((layergroup.spatialBounds.north - layergroup.spatialBounds.east) !== 0)\n" +
    "                 && layergroup.isActive()\"\n" +
    "          ng-click=\"menu.zoomToBounds(layergroup.spatialBounds, layergroup.temporalBounds); $event.stopPropagation()\"\n" +
    "          class=\"fa fa-crosshairs\">\n" +
    "        </i>\n" +
    "      </div>\n" +
    "  </label>\n" +
    "</div>\n" +
    "\n" +
    "<opacity-slider title=\"<% tooltips.transparency %>\"></opacity-slider>\n" +
    "");
}]);

angular.module("omnibox/templates/asset-cards.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/asset-cards.html",
    "<div class=\"animate-repeat\">\n" +
    "\n" +
    "  <cardattributes waterchain=\"asset\" show-header=\"showHeader\"></cardattributes>\n" +
    "\n" +
    "  <timeseries\n" +
    "    timeseries-single-select\n" +
    "    ng-if=\"showTimeseries && asset.timeseries.length > 0\"\n" +
    "    asset=\"asset\"\n" +
    "    time-state=\"timeState\">\n" +
    "  </timeseries>\n" +
    "\n" +
    "  <nestedasset\n" +
    "    ng-if=\"showTimeseries\"\n" +
    "    asset=\"asset\"\n" +
    "    time-state=\"timeState\">\n" +
    "  </nestedasset>\n" +
    "\n" +
    "  <geometry-cards\n" +
    "    geom=\"asset\"\n" +
    "    header=\"false\"\n" +
    "    time-state=\"timeState\">\n" +
    "  </geometry-cards>\n" +
    "\n" +
    "  <annotations\n" +
    "    ng-if=\"showAnnotations && user.authenticated\"\n" +
    "    data=\"asset\"\n" +
    "    time-state=\"timeState\">\n" +
    "  </annotations>\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("omnibox/templates/card-header.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/card-header.html",
    "<header class=\"card-header\">\n" +
    "\n" +
    "  <div ng-if=\"asset\" class=\"card-header-center\">\n" +
    "    <close-card asset=\"asset\"></close-card>\n" +
    "\n" +
    "      <span class=\"icons fa-stack fa-lg\">\n" +
    "        <i class=\"fa fa-circle fa-stack-2x\"></i>\n" +
    "        <i\n" +
    "          class=\"asset-icon fa fa-stack\"\n" +
    "          ng-class=\"getIconClass(asset.entity_name)\">\n" +
    "        </i>\n" +
    "      </span>\n" +
    "\n" +
    "      <span class=\"asset-title\">\n" +
    "        <% asset.entity_name | objectTitle | translate %>\n" +
    "      </span>\n" +
    "\n" +
    "      <br>\n" +
    "\n" +
    "      <em><% asset.code %></em>\n" +
    "\n" +
    "  </div>\n" +
    "\n" +
    "  <div ng-if=\"geom\" class=\"card-header-center\">\n" +
    "    <close-card geometry=\"geom\"></close-card>\n" +
    "\n" +
    "    <span ng-if=\"geom.geometry.type === 'Point'\" class=\"asset-title\">\n" +
    "      <% geom.geometry.coordinates[1] | number : 2 %>, <% geom.geometry.coordinates[0] | number : 2 %>\n" +
    "    </span>\n" +
    "    <span ng-if=\"geom.geometry.type === 'LineString'\">\n" +
    "      <% geom.geometry.coordinates[0][1] | number : 2 %>, <% geom.geometry.coordinates[0][0] | number : 2 %> - <% geom.geometry.coordinates[1][1] | number : 2 %>, <% geom.geometry.coordinates[1][0] | number : 2 %></span>\n" +
    "    <span ng-if=\"geom.name\">\n" +
    "      <% geom.name %>: <% geom.area / 10000 | number : 0 %> ha.\n" +
    "    </span>\n" +
    "    <span ng-if=\"geom.geometry.type === 'Polygon' && !geom.name\" translate>\n" +
    "      Screen view\n" +
    "    </span>\n" +
    "  </div>\n" +
    "\n" +
    "</header>\n" +
    "");
}]);

angular.module("omnibox/templates/cardattributes.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/cardattributes.html",
    "<div>\n" +
    "\n" +
    "  <cardheader ng-if=\"showHeader\" asset=\"waterchain\"></cardheader>\n" +
    "\n" +
    "  <div class=\"card active card-attributes\">\n" +
    "    <table id=\"kunstwerk-table\" class=\"table table-condensed table-hover\">\n" +
    "\n" +
    "      <tr class=\"attr-row\"\n" +
    "          ng-repeat=\"obj in wanted[waterchain.entity_name].rows\"\n" +
    "          >\n" +
    "\n" +
    "        <td class=\"fixed-width-card-table\">\n" +
    "          <div class=\"attr-row-content\">\n" +
    "            <% obj.keyName | translate %>\n" +
    "          </div>\n" +
    "        </td>\n" +
    "\n" +
    "        <td class=\"lineout\"\n" +
    "            ng-if=\"waterchain[obj.attrName] !== undefined\n" +
    "              && waterchain[obj.attrName] !== null\n" +
    "              && waterchain[obj.attrName] !== ''\n" +
    "              && waterchain[obj.attrName] !== 'pumps'\n" +
    "              && waterchain[obj.attrName] !== 'filters'\">\n" +
    "          <div class=\"attr-row-content\" ng-bind-html=\"$eval(obj.ngBindValue) + obj.valueSuffix\">\n" +
    "          </div>\n" +
    "        </td>\n" +
    "\n" +
    "        <td class=\"lineout\"\n" +
    "            ng-if=\"waterchain[obj.attrName] === undefined\n" +
    "              || waterchain[obj.attrName] === null\n" +
    "              || waterchain[obj.attrName] === ''\"\n" +
    "            rel=\"tooltip\"\n" +
    "            data-toggle=\"tooltip\"\n" +
    "            title=\"<% 'Example value' | translate %>\">\n" +
    "          <div class=\"attr-row-content dummy-attr-value\" ng-bind-html=\"obj.defaultValue + obj.valueSuffix\">\n" +
    "          </div>\n" +
    "        </td>\n" +
    "      </tr>\n" +
    "    </table>\n" +
    "\n" +
    "    <div class=\"structure-image-wrapper text-center\"\n" +
    "         ng-if=\"!!waterchain.image_url && fullDetails\">\n" +
    "\n" +
    "        <img class=\"structure-image\"\n" +
    "             ng-src=\"{{waterchain.image_url}}\" />\n" +
    "\n" +
    "    </div>\n" +
    "  </div>\n" +
    "\n" +
    "</div>\n" +
    "\n" +
    "");
}]);

angular.module("omnibox/templates/close-card.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/close-card.html",
    "<span class=\"pull-right clickable\" ng-click=\"rmAssetOrGeometry()\">\n" +
    "  <i class=\"fa fa-lg fa-times\"></i>\n" +
    "</span>\n" +
    "");
}]);

angular.module("omnibox/templates/color-picker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/color-picker.html",
    "<ul class=\"color-picker\"\n" +
    "    ng-if=\"colorPicker.enabled\">\n" +
    "  <li ng-repeat=\"color in colorPicker.availableColors\"\n" +
    "      ng-class=\"{selected: (color === colorPicker.selectedColor)}\"\n" +
    "      ng-click=\"selectColor(color)\"\n" +
    "      ng-style=\"{'background-color': color}\"\n" +
    "      class=\"clickable\">\n" +
    "  </li>\n" +
    "</ul>\n" +
    "");
}]);

angular.module("omnibox/templates/dashboard-cards.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/dashboard-cards.html",
    "");
}]);

angular.module("omnibox/templates/db-asset-card.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/db-asset-card.html",
    "<div>\n" +
    "  <div class=\"card active\">\n" +
    "\n" +
    "    <timeseries asset=\"asset\" time-state=\"timeState\"></timeseries>\n" +
    "\n" +
    "    <cardheader asset=\"asset\"></cardheader>\n" +
    "\n" +
    "    <div class=\"card-content\">\n" +
    "\n" +
    "      <!-- crosssections are not draggable and a specific visualization. -->\n" +
    "      <div\n" +
    "        ng-if=\"asset.entity_name === 'leveecrosssection'\"\n" +
    "        ng-click=\"toggleCrosssection(asset)\"\n" +
    "        class=\"card-content-list clickable\">\n" +
    "        <i class=\"fa fa-line-chart\"></i>\n" +
    "        <span translate ng-class=\"{'text-primary bg-warning': asset.crosssection.active}\">\n" +
    "          Levee cross section\n" +
    "        </span>\n" +
    "      </div>\n" +
    "\n" +
    "      <div ng-if=\"asset.crosssection.active\">\n" +
    "        <dl>\n" +
    "          <dt translate>Green line</dt>\n" +
    "          <dd translate>Elevation along crosssection (source: AHN2).</dd>\n" +
    "          <dt translate>Grey dots</dt>\n" +
    "          <dd translate>Measured hydraulic head at current time.</dd>\n" +
    "          <dt translate>Dashed line</dt>\n" +
    "          <dd translate>indicative interpolation of hydraulic head in the same aquifer.</dd>\n" +
    "        </dl>\n" +
    "      </div>\n" +
    "\n" +
    "      <em ng-if=\"noTimeseries && asset.entity_name !== 'leveecrosssection'\" translate>\n" +
    "        No timeseries available for this asset\n" +
    "      </em>\n" +
    "\n" +
    "      <!-- use ng-show, so div is present and can be added to drag containers -->\n" +
    "      <div id=\"drag-container\">\n" +
    "        <div ng-repeat=\"ts in selected.timeseries\"\n" +
    "             ng-if=\"getTsMetaData(ts.uuid)\"\n" +
    "             data-uuid=\"<% ts.uuid %>\"\n" +
    "             class=\"draggable-ts\">\n" +
    "          <div\n" +
    "            id=\"<% ts.uuid %>\"\n" +
    "            ng-click=\"toggleTimeseries(ts)\"\n" +
    "            class=\"card-content-list clickable\">\n" +
    "            <i class=\"fa\" ng-class=\"{\n" +
    "              'fa-clock-o': getTsMetaData(ts.uuid).value_type !== 'image',\n" +
    "              'fa-file-image-o': getTsMetaData(ts.uuid).value_type === 'image'\n" +
    "            }\"></i>\n" +
    "            <span ng-class=\"{'text-primary bg-warning': ts.active}\">\n" +
    "              <% getTsMetaData(ts.uuid).location %>,\n" +
    "              <% getTsMetaData(ts.uuid).parameter %>\n" +
    "            </span>\n" +
    "          </div>\n" +
    "          <div class=\"circle pull-right\"\n" +
    "               ng-style=\"{'background-color': ts.color}\"\n" +
    "               ng-click=\"toggleColorPicker()\">\n" +
    "          </div>\n" +
    "          <color-picker></color-picker>\n" +
    "        </div>\n" +
    "      </div>\n" +
    "\n" +
    "      <db-geometry-cards\n" +
    "        time-state=\"timeState\"\n" +
    "        geom=\"asset\"\n" +
    "        header=\"false\">\n" +
    "      </db-geometry-cards>\n" +
    "\n" +
    "    </div>\n" +
    "\n" +
    "  </div>\n" +
    "\n" +
    "  <db-nested-asset asset=\"asset\" time-state=\"timeState\"></db-nested-asset>\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("omnibox/templates/db-cards.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/db-cards.html",
    "<div>\n" +
    "\n" +
    "  <db-asset-card\n" +
    "    timeseries\n" +
    "    time-state=\"omnibox.state.temporal\"\n" +
    "    asset=\"asset\"\n" +
    "    ng-repeat=\"asset in omnibox.data.assets\">\n" +
    "  </db-asset-card>\n" +
    "\n" +
    "  <div\n" +
    "    class=\"card active animate-repeat\"\n" +
    "    ng-repeat=\"geom in omnibox.data.geometries\">\n" +
    "\n" +
    "    <cardheader geom=\"geom\"></cardheader>\n" +
    "\n" +
    "    <div class=\"card-content\">\n" +
    "      <db-geometry-cards\n" +
    "        time-state=\"state.temporal\"\n" +
    "        geom=\"geom\"\n" +
    "        header=\"true\"\n" +
    "        >\n" +
    "      </db-geometry-cards>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("omnibox/templates/db-geometry-cards.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/db-geometry-cards.html",
    "<div>\n" +
    "  <em ng-if=\"noData\" translate>No raster data available for this geometry</em>\n" +
    "\n" +
    "  <div\n" +
    "    ng-if=\"dbSupportedData(geom.geometry.type, prop)\"\n" +
    "    ng-repeat=\"(slug, prop) in geom.properties\">\n" +
    "    <div ng-click=\"toggleProperty(prop)\" class=\"card-content-list clickable\">\n" +
    "      <i class=\"fa fa-line-chart\"></i>\n" +
    "      <span ng-class=\"{'text-primary bg-warning': prop.active}\"><% prop.quantity %>, (<% prop.unit %>)</span>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("omnibox/templates/defaultpoint.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/defaultpoint.html",
    "<div class=\"card active\">\n" +
    "  <div ng-switch=\"content.format\">\n" +
    "\n" +
    "    <div ng-switch-when=\"Store\">\n" +
    "      <div ng-if=\"!content.temporal\">\n" +
    "        <table ng-if=\"content.scale === 'interval' || content.scale === 'ratio' \"\n" +
    "          class=\"table table-condensed table-hover single-row-table\">\n" +
    "          <thead>\n" +
    "            <td class=\"col-md-4\"><% content.quantity %> </td>\n" +
    "            <td class=\"col-md-4\"><% content.data[0] | number : 2 %> <% content.unit %></td>\n" +
    "            <td class=\"col-md-4\"></td>\n" +
    "          </thead>\n" +
    "        </table>\n" +
    "\n" +
    "        <table ng-if=\"content.scale === 'nominal' || content.scale === 'ordinal'\"\n" +
    "               class=\"table table-condensed table-hover single-row-table\">\n" +
    "          <thead>\n" +
    "            <td class=\"col-md-2\">\n" +
    "              <div class=\"discrete-raster-color-indicator\"\n" +
    "                   ng-style=\"{'background-color': content.data[0].color}\">\n" +
    "              </div>\n" +
    "            </td>\n" +
    "            <td class=\"col-md-11\">\n" +
    "              <% content.quantity %>:&nbsp;<% content.data[0].label | discreteRasterType %>\n" +
    "            </td>\n" +
    "            <td class=\"col-md-2\"><% content.data[0].label | discreteRasterSource %></td>\n" +
    "          </thead>\n" +
    "        </table>\n" +
    "      </div>\n" +
    "      <graph ng-if=\"content.temporal\"\n" +
    "        class=\"card-content\"\n" +
    "        line\n" +
    "        type=\"temporal\"\n" +
    "        temporal=\"timeState\"\n" +
    "        data=\"content.data\"\n" +
    "        ylabel=\"content.unit\"\n" +
    "        keys=\"{x: 0, y: 1}\">\n" +
    "      </graph>\n" +
    "    </div>\n" +
    "\n" +
    "    <div ng-switch-when=\"WMS\"\n" +
    "         ng-if=\"content.data.features && content.data.features.length\">\n" +
    "      <div class=\"card-content\">\n" +
    "\n" +
    "        <span id=\"title-holder\"\n" +
    "              class=\"card-title-text kunstwerk-title-text\">\n" +
    "          <% content.layerGroupName %>\n" +
    "        </span>\n" +
    "        <full-details></full-details>\n" +
    "      </div>\n" +
    "\n" +
    "      <table ng-if=\"fullDetails\" class=\"table table-condensed table-hover\">\n" +
    "\n" +
    "        <tr ng-repeat=\"(key, val) in content.data.features[0].properties\">\n" +
    "\n" +
    "          <td>\n" +
    "            <span class=\"attr-row-content\">\n" +
    "              <% key %>:&nbsp\n" +
    "            </span>\n" +
    "\n" +
    "            <span ng-if=\"isUrl(val)\" class=\"attr-row-content\">\n" +
    "              <a href=\"<% val %>\" target=\"_blank\"><% val %></a>\n" +
    "            </span>\n" +
    "            <span ng-if=\"!isUrl(val)\" class=\"attr-row-content\">\n" +
    "              <% val %>\n" +
    "            </span>\n" +
    "          </td>\n" +
    "\n" +
    "        </tr>\n" +
    "      </table>\n" +
    "    </div>\n" +
    "\n" +
    "\n" +
    "    <div ng-switch-when=\"Vector\" ng-if=\"content.data.length\">\n" +
    "      <div class=\"card-content\">\n" +
    "\n" +
    "        <span class=\"card-title\">\n" +
    "          <span><i class=\"fa fa-circle\" ng-style=\"{'color': content.color }\"></i></span>\n" +
    "          <span><% content.data.length %></span>\n" +
    "          <span><% content.quantity %></span>\n" +
    "        </span>\n" +
    "        <full-details class=\"table-details-toggler\"></full-details>\n" +
    "        <table ng-if=\"fullDetails\" class=\"table table-hover table-condensed\" >\n" +
    "          <tbody>\n" +
    "            <tr ng-repeat=\"event in content.data\">\n" +
    "              <td rel=\"tooltip\"\n" +
    "                  data-placement=\"left\"\n" +
    "                  title=\"<% 'Start' | translate %>: <% event.properties.timestamp_start | date:'dd/MM/yyyy' %>\n" +
    "                         <% 'End' | translate %>: <% event.properties.timestamp_end | date:'dd/MM/yyyy' %>\">\n" +
    "                  <% event.properties.timestamp_start | date:'dd/MM/yyyy' %>\n" +
    "              </td>\n" +
    "              <td rel=\"tooltip\"\n" +
    "                  data-placement=\"left\"\n" +
    "                  title=\"<% event.properties.category %>\">\n" +
    "                  <% event.properties.category %>\n" +
    "              </td>\n" +
    "              <td rel=\"tooltip\"\n" +
    "                  data-placement=\"left\"\n" +
    "                  title=\"<% event.properties.value %>\">\n" +
    "                  <% event.properties.value | truncate:17 %>\n" +
    "              </td>\n" +
    "            </tr>\n" +
    "          </tbody>\n" +
    "        </table>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "\n" +
    "\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("omnibox/templates/empty.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/empty.html",
    "");
}]);

angular.module("omnibox/templates/full-details.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/full-details.html",
    "<span class=\"full-details-toggle pull-right card-title-text\">\n" +
    "  <i class=\"fa fa-lg clickable\"\n" +
    "    ng-class=\"{'fa-caret-down': fullDetails, 'fa-caret-left': !fullDetails}\">\n" +
    "  </i> \n" +
    "\n" +
    "</span>\n" +
    "");
}]);

angular.module("omnibox/templates/geometry-cards.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/geometry-cards.html",
    "<div class=\"animate-repeat\">\n" +
    "\n" +
    "  <cardheader ng-if=\"header\" geom=\"geom\"></cardheader>\n" +
    "\n" +
    "  <div\n" +
    "    ng-if=\"showNoData && header\"\n" +
    "    class=\"card active card-content\">\n" +
    "    <em translate>No data available for this location</em>\n" +
    "  </div>\n" +
    "\n" +
    "  <rain\n" +
    "    ng-if=\"geom.properties.rain && (geom.id || geom.geometry.type !== 'Polygon')\"\n" +
    "    rain=\"geom\"\n" +
    "    time-state=\"timeState\">\n" +
    "  </rain>\n" +
    "\n" +
    "  <defaultpoint\n" +
    "    ng-if=\"geom.geometry.type === 'Point' && slug !== 'rain' && slug !== 'annotations'\"\n" +
    "    ng-repeat=\"(slug, content) in geom.properties\"\n" +
    "    content=\"content\"\n" +
    "    name=\"slug\"\n" +
    "    time-state=\"timeState\">\n" +
    "  </defaultpoint>\n" +
    "\n" +
    "  <div\n" +
    "    ng-if=\"geom.geometry.type === 'LineString' && (content.scale === 'interval' || content.scale === 'ratio')\"\n" +
    "    class=\"card active card-content\"\n" +
    "    ng-repeat=\"(slug, content) in geom.properties\">\n" +
    "\n" +
    "    <graph\n" +
    "      line\n" +
    "      mouseloc=\"mouseloc\"\n" +
    "      data=\"content.data\"\n" +
    "      ylabel=\"content.quantity + ' [' + content.unit + ']'\"\n" +
    "      xlabel=\"'Afstand in [m]'\">\n" +
    "    </graph>\n" +
    "\n" +
    "    <div class=\"card-tools\">\n" +
    "       <a\n" +
    "         class=\"btn btn-default btn-xs\"\n" +
    "         title=\"<% 'Export info card data' | translate %>\"\n" +
    "         ng-csv=\"formatLineCSV(slug, content)\"\n" +
    "         field-separator=\";\"\n" +
    "         filename=\"<% slug %>.csv\"\n" +
    "         csv-header=\"getLineCSVHeaders(slug, content)\">\n" +
    "         <i class=\"fa fa-share-square-o\"></i>\n" +
    "         <span translate>Export</span>\n" +
    "      </a>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "\n" +
    "  <div\n" +
    "    ng-if=\"content.data\n" +
    "    && (geom.geometry.type === 'Polygon' || geom.geometry.type === 'MultiPolygon')\n" +
    "    && slug !== 'rain'\"\n" +
    "    ng-repeat=\"(slug, content) in geom.properties\"\n" +
    "    class=\"card active\">\n" +
    "\n" +
    "    <div class=\"card-content\">\n" +
    "\n" +
    "      <div ng-if=\"content.format === 'Vector' && slug !== 'annotations'\">\n" +
    "        <span class=\"card-title\">\n" +
    "          <span><i class=\"fa fa-circle\" ng-style=\"{'color': content.color }\"></i></span>\n" +
    "          <span><% content.data.length %></span>\n" +
    "          <span><% content.quantity %></span>\n" +
    "        </span>\n" +
    "        <full-details class=\"table-details-toggler\"></full-details>\n" +
    "        <table ng-if=\"fullDetails\" class=\"table table-hover table-condensed\" >\n" +
    "          <tbody>\n" +
    "            <tr ng-repeat=\"event in content.data\">\n" +
    "              <td rel=\"tooltip\"\n" +
    "                  data-placement=\"left\"\n" +
    "                  title=\"<% 'Start' | translate %>: <% event.properties.timestamp_start | date:'dd/MM/yyyy' %>\n" +
    "                         <% 'End' | translate %>: <% event.properties.timestamp_end | date:'dd/MM/yyyy' %>\">\n" +
    "                  <% event.properties.timestamp_start | date:'dd/MM/yyyy' %>\n" +
    "              </td>\n" +
    "              <td rel=\"tooltip\"\n" +
    "                  data-placement=\"left\"\n" +
    "                  title=\"<% event.properties.category %>\">\n" +
    "                  <% event.properties.category %>\n" +
    "              </td>\n" +
    "              <td rel=\"tooltip\"\n" +
    "                  data-placement=\"left\"\n" +
    "                  title=\"<% event.properties.value %>\">\n" +
    "                  <% event.properties.value | truncate:17 %>\n" +
    "              </td>\n" +
    "            </tr>\n" +
    "          </tbody>\n" +
    "        </table>\n" +
    "      </div>\n" +
    "\n" +
    "      <graph\n" +
    "        ng-if=\"content.aggType === 'curve'\"\n" +
    "        line\n" +
    "        xlabel=\"'[%]'\"\n" +
    "        ylabel=\"content.unit\"\n" +
    "        data=\"content.data\"\n" +
    "        keys=\"{x: 0, y: 1}\">\n" +
    "      </graph>\n" +
    "\n" +
    "      <graph\n" +
    "        ng-if=\"content.aggType === 'histogram'\"\n" +
    "        bar-chart\n" +
    "        quantity=\"'linear'\"\n" +
    "        ylabel=\"'[%]'\"\n" +
    "        xlabel=\"content.unit\"\n" +
    "        data=\"content.data\"\n" +
    "        keys=\"{x: 0, y: 1}\">\n" +
    "      </graph>\n" +
    "\n" +
    "      <graph\n" +
    "        ng-if=\"content.aggType === 'counts'\"\n" +
    "        horizontal-stack\n" +
    "        data=\"content.data\"\n" +
    "        keys=\"{x: 'data', y: 'label'}\"\n" +
    "        xlabel=\"'[%]'\"\n" +
    "        dimensions=\"{height: 80, padding: {left: 0, right: 0, top: 5, bottom: 50 } }\">\n" +
    "      </graph>\n" +
    "\n" +
    "      <div ng-if=\"content.aggType !== 'histogram' && content.aggType !== 'curve' && content.aggType !== 'counts'\">\n" +
    "\n" +
    "        <graph\n" +
    "          ng-if=\"content.format === Store\"\n" +
    "          line\n" +
    "          data=\"content.data\">\n" +
    "        </graph>\n" +
    "\n" +
    "      </div>\n" +
    "\n" +
    "    </div>\n" +
    "\n" +
    "  </div>\n" +
    "\n" +
    "  <annotations\n" +
    "    ng-if=\"header && geom.geometry.type === 'Point' && user.authenticated\"\n" +
    "    data=\"geom\"\n" +
    "    time-state=\"timeState\">\n" +
    "  </annotations>\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("omnibox/templates/nestedasset.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/nestedasset.html",
    "<div>\n" +
    "  <div ng-if=\"asset.selectedAsset\" class=\"card active\">\n" +
    "\n" +
    "    <div class=\"card-content\">\n" +
    "\n" +
    "      <div class=\"timeseries-header-container\">\n" +
    "\n" +
    "        <i id=\"icon-holder\"\n" +
    "          ng-class=\"$parent.getIconClass(attr)\">\n" +
    "        </i>\n" +
    "\n" +
    "        <span id=\"title-holder\"\n" +
    "              class=\"card-title-text kunstwerk-title-text\"\n" +
    "              ng-bind=\"attr | objectTitle | translate\">\n" +
    "        </span>\n" +
    "\n" +
    "        <select\n" +
    "          class=\"timeseries nested-asset\"\n" +
    "          ng-if=\"list.length > 1\"\n" +
    "          ng-model=\"asset.selectedAsset\"\n" +
    "          ng-change=\"selectedAssetChanged(asset.selectedAsset)\"\n" +
    "          ng-options=\"\n" +
    "            a.code !== '' ? a.code\n" +
    "            : a.serial !== '' ? a.serial\n" +
    "            : a.id\n" +
    "            for a in list track by a.id\">\n" +
    "        </select>\n" +
    "\n" +
    "      </div>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "\n" +
    "  <asset-cards\n" +
    "    ng-if=\"asset.selectedAsset\"\n" +
    "    asset=\"asset.selectedAsset\"\n" +
    "    show-timeseries=\"true\"\n" +
    "    show-annotations=\"false\"\n" +
    "    time-state=\"timeState\">\n" +
    "  </asset-cards>\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("omnibox/templates/omnibox.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/omnibox.html",
    "<div>\n" +
    "\n" +
    "  <search></search>\n" +
    "\n" +
    "  <div id=\"cards\" class=\"pullDown cardbox\">\n" +
    "\n" +
    "    <search-results ng-if=\"omnibox.searchResults\"></search-results>\n" +
    "\n" +
    "    <div ng-if=\"omnibox.context === 'map'\">\n" +
    "\n" +
    "      <asset-cards\n" +
    "        asset=\"asset\"\n" +
    "        show-header=\"true\"\n" +
    "        show-annotations=\"(omnibox.data.geometries.length + omnibox.data.assets.length) < 2\"\n" +
    "        show-timeseries=\"(omnibox.data.geometries.length + omnibox.data.assets.length) < 2\"\n" +
    "        time-state=\"omnibox.state.temporal\"\n" +
    "        ng-repeat=\"asset in omnibox.data.assets track by omnibox.trackAssets(asset)\">\n" +
    "      </asset-cards>\n" +
    "\n" +
    "      <geometry-cards\n" +
    "        geom=\"geom\"\n" +
    "        header=\"true\"\n" +
    "        ng-repeat=\"geom in omnibox.data.geometries track by $index\"\n" +
    "        time-state=\"omnibox.state.temporal\"\n" +
    "        mouseloc=\"omnibox.state.selected.mouseOnLine\">\n" +
    "      </geometry-cards>\n" +
    "\n" +
    "    </div>\n" +
    "\n" +
    "    <div ng-if=\"omnibox.context === 'dashboard'\">\n" +
    "\n" +
    "      <db-cards></db-cards>\n" +
    "\n" +
    "    </div>\n" +
    "\n" +
    "    <scenarios ng-if=\"omnibox.state.context === 'scenarios'\"></scenarios>\n" +
    "\n" +
    "  </div>\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("omnibox/templates/rain.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/rain.html",
    "<div>\n" +
    "\n" +
    "  <div class=\"card active\">\n" +
    "    <div class=\"card-content\">\n" +
    "      <full-details></full-details>\n" +
    "\n" +
    "      <span class=\"card-title-text\" ng-class=\"{hidden: fullDetails}\" translate>Rain</span>\n" +
    "      <div ng-if=\"graphContent\" ng-class=\"{ hidden: !fullDetails }\">\n" +
    "        <graph\n" +
    "          bar-chart\n" +
    "          temporal=\"timeState\"\n" +
    "          type=\"temporal\"\n" +
    "          content=\"graphContent\"\n" +
    "          now=\"timeState.at\">\n" +
    "        </graph>\n" +
    "\n" +
    "        <div\n" +
    "          class=\"card-tools\"\n" +
    "          ng-class=\"{hidden: !fullDetails}\">\n" +
    "\n" +
    "          <a\n" +
    "            ng-click=\"recurrenceTimeToggle()\"\n" +
    "            ng-class=\"{ active: rrc.active }\"\n" +
    "            class=\"btn btn-default btn-xs\"\n" +
    "            title=\"<% 'Rain recurrence statistics' | translate %>\"\n" +
    "            translate>\n" +
    "            <span translate>Statistics</span>\n" +
    "          </a>\n" +
    "\n" +
    "          <a\n" +
    "            target=\"_blank\"\n" +
    "            ng-href=\"<% getRawDataUrl() %>\"\n" +
    "            ng-class=\"timeState.end - timeState.start > rain.MAX_TIME_INTERVAL ? 'disabled' : ''\"\n" +
    "            class=\"btn btn-default btn-xs\"\n" +
    "            title=\"<% 'Export data' | translate %>\">\n" +
    "            <i class=\"fa fa-share-square-o\"></i>\n" +
    "            <span translate>Export</span>\n" +
    "          </a>\n" +
    "\n" +
    "        </div>\n" +
    "\n" +
    "      </div>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "\n" +
    "  <div class=\"card active ng-class: {hidden: !fullDetails}\" ng-if=\"rrc.active\">\n" +
    "    <div class=\"card-content-message\">\n" +
    "      <div class=\"recurrence-time-container\">\n" +
    "        <div ng-if=\"!rrc.data.message\">\n" +
    "          <table class=\"table table-hover table-condensed\">\n" +
    "            <caption translate>Recurrence times (RT)</caption>\n" +
    "            <thead>\n" +
    "              <tr>\n" +
    "                <td class=\"col-md-4 larger-font-card-table\" translate>Start</th>\n" +
    "                <td class=\"larger-font-card-table\" translate>Duration</th>\n" +
    "                <td class=\"larger-font-card-table text-right\" translate translate-comment=\"millimeters\">mm</th>\n" +
    "                <td class=\"larger-font-card-table\" translate translate-comment=\"Recurrence Time\">RT (years)</th>\n" +
    "              </tr>\n" +
    "            </thead>\n" +
    "            <tbody>\n" +
    "            <tr class=\"recurrence_time\"\n" +
    "              ng-repeat=\"recurTime in rrc.data.data\">\n" +
    "              <td class=\"larger-font-card-table\"><% recurTime.start | date : 'dd-MM-yyyy HH:mm' %></td>\n" +
    "              <td class=\"larger-font-card-table\"><% recurTime.td_window %></td>\n" +
    "              <td class=\"larger-font-card-table text-right\"><% recurTime.max | number: 1 %></td>\n" +
    "              <td class=\"larger-font-card-table\"><% recurTime.t %></td>\n" +
    "            </tr>\n" +
    "            </tbody>\n" +
    "          </table>\n" +
    "        </div>\n" +
    "        <div ng-if=\"rrc.data.message\">\n" +
    "          <span class=\"message\"><% rrc.data.message %></span>\n" +
    "        </div>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("omnibox/templates/search-results.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/search-results.html",
    "<div class=\"card active\">\n" +
    "\n" +
    "  <div class=\"search-results\">\n" +
    "\n" +
    "    <h3 ng-if=\"omnibox.searchResults.spatial.length > 0\">\n" +
    "      <i class=\"fa fa-map-marker\">&nbsp;</i>\n" +
    "      <span translate>Locations</span>&nbsp;(<% omnibox.searchResults.spatial.length %>)\n" +
    "    </h3>\n" +
    "    <ul>\n" +
    "      <li ng-cloak\n" +
    "        ng-repeat=\"result in omnibox.searchResults.spatial\"\n" +
    "        class=\"cluster location\">\n" +
    "        <a ng-click=\"zoomToSpatialResult(result)\"\n" +
    "          tabindex=\"2\"\n" +
    "          href=\"\">\n" +
    "          <span><% result.formatted_address %></span>\n" +
    "        </a>\n" +
    "      </li>\n" +
    "    </ul>\n" +
    "\n" +
    "    <h3 ng-if=\"omnibox.searchResults.api.length > 0\">\n" +
    "      <i class=\"fa fa-map-pin\">&nbsp;</i>\n" +
    "      <span translate>Assets</span>&nbsp;(<% omnibox.searchResults.api.length %>)\n" +
    "    </h3>\n" +
    "    <ul>\n" +
    "      <li ng-cloak\n" +
    "        ng-repeat=\"result in omnibox.searchResults.api\"\n" +
    "        class=\"cluster location\">\n" +
    "        <a ng-click=\"zoomToSearchResult(result)\"\n" +
    "          tabindex=\"2\"\n" +
    "          href=\"\">\n" +
    "          <i class=\"fa\"\n" +
    "             ng-class=\"util.getIconClass(result.entity_name)\"></i>\n" +
    "          <span><% result.title %></span>\n" +
    "        </a>\n" +
    "      </li>\n" +
    "    </ul>\n" +
    "\n" +
    "    <h3 ng-if=\"omnibox.searchResults.temporal\" translate>Time</h3>\n" +
    "  	<div\n" +
    "  		ng-if=\"omnibox.searchResults.temporal\"\n" +
    "  		class=\"cluster location\">\n" +
    "  	  <a ng-click=\"zoomToTemporalResult(omnibox.searchResults.temporal)\"\n" +
    "  	    class=\"pointer clickable\">\n" +
    "  	    <span><% omnibox.searchResults.temporal.format(\n" +
    "  	    	omnibox.searchResults.temporal.nxtFormatString\n" +
    "  	    ) %></span>\n" +
    "  	  </a>\n" +
    "  	</div>\n" +
    "\n" +
    "  </div>\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("omnibox/templates/search.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/search.html",
    "<div class=\"searchbox\" id=\"searchbox\" tabindex=\"-1\" role=\"search\">\n" +
    "  <div class=\"zoom-buttons material-shadow\">\n" +
    "    <button class=\"btn btn-primary\"\n" +
    "            ng-click=\"zoomIn()\"\n" +
    "            tabindex=\"4\"\n" +
    "            accesskey=\"+\"\n" +
    "            aria-label=\"<% tooltips.zoomInMap %>\">\n" +
    "      <i class=\"fa fa-plus\"></i>\n" +
    "    </button>\n" +
    "    <button class=\"btn btn-primary\"\n" +
    "            ng-click=\"zoomOut()\"\n" +
    "            tabindex=\"4\"\n" +
    "            accesskey=\"-\"\n" +
    "            aria-label=\"<% tooltips.zoomOutMap %>\">\n" +
    "      <i class=\"fa fa-minus\"></i>\n" +
    "    </button>\n" +
    "  </div>\n" +
    "\n" +
    "  <div class=\"resize-wrapper material-shadow\">\n" +
    "    <div class=\"search-and-close\">\n" +
    "      <button class=\"btn btn-default btn-lg clear-search\"\n" +
    "              type=\"button\"\n" +
    "              aria-label=\"<% tooltips.resetQuery %>\"\n" +
    "              ng-click=\"cleanInput()\"\n" +
    "              ng-if=\"query\"\n" +
    "              tabindex=\"3\"\n" +
    "              accesskey=\"q\"\n" +
    "              id=\"clear\">\n" +
    "        <i class=\"fa fa-close\"></i>\n" +
    "      </button>\n" +
    "      <div class=\"resize-wrapper\">\n" +
    "        <input\n" +
    "          id=\"searchboxinput\"\n" +
    "          tabindex=\"1\"\n" +
    "          accesskey=\"s\"\n" +
    "          placeholder=\"<% 'Search for places, or dates (i.e. 23-10-2013)' | translate %>\"\n" +
    "          autocomplete=\"off\"\n" +
    "          dir=\"ltr\"\n" +
    "          ng-model=\"query\"\n" +
    "          ng-change=\"search(query)\"\n" +
    "          ng-keydown=\"searchKeyPress($event)\"\n" +
    "          spellcheck=\"false\"\n" +
    "          type=\"search\">\n" +
    "      </div>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("omnibox/templates/summary-card.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/summary-card.html",
    "<div>\n" +
    "\n" +
    "<cardheader asset=\"asset.data\"></cardheader>\n" +
    "\n" +
    "  <div class=\"card-content\">\n" +
    "\n" +
    "    <!-- this used to be hidden when !fullDetails -->\n" +
    "    <table id=\"kunstwerk-table\" class=\"table table-condensed table-hover\">\n" +
    "\n" +
    "      <tr class=\"attr-row\"\n" +
    "          ng-repeat=\"obj in wanted[asset.data.entity_name].rows\"\n" +
    "          >\n" +
    "\n" +
    "        <td class=\"fixed-width-card-table\">\n" +
    "          <div class=\"attr-row-content\">\n" +
    "            <% obj.keyName | translate %>\n" +
    "          </div>\n" +
    "        </td>\n" +
    "\n" +
    "        <td class=\"lineout\"\n" +
    "            ng-if=\"asset.data[obj.attrName] !== undefined\n" +
    "              && asset.data[obj.attrName] !== null\n" +
    "              && asset.data[obj.attrName] !== ''\n" +
    "              && asset.data[obj.attrName] !== 'pumps'\n" +
    "              && asset.data[obj.attrName] !== 'filters'\">\n" +
    "          <div class=\"attr-row-content\" ng-bind=\"asset.data[obj.attrName]\">\n" +
    "          </div>\n" +
    "        </td>\n" +
    "\n" +
    "        <td class=\"lineout\"\n" +
    "            ng-if=\"asset.data[obj.attrName] === undefined\n" +
    "              || asset.data[obj.attrName] === null\n" +
    "              || asset.data[obj.attrName] === ''\"\n" +
    "            rel=\"tooltip\"\n" +
    "            asset.data-toggle=\"tooltip\"\n" +
    "            title=\"<% 'Example value' | translate %>\">\n" +
    "          <div class=\"attr-row-content dummy-attr-value\" ng-bind-html=\"obj.defaultValue + obj.valueSuffix\">\n" +
    "          </div>\n" +
    "        </td>\n" +
    "      </tr>\n" +
    "    </table>\n" +
    "\n" +
    "    <div class=\"structure-image-wrapper text-center\"\n" +
    "         ng-if=\"!!asset.data.image_url && fullDetails\">\n" +
    "\n" +
    "        <img class=\"structure-image\"\n" +
    "             ng-src=\"<% asset.data.image_url %>\" />\n" +
    "\n" +
    "    </div>\n" +
    "  </div>\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("opacity/opacity.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("opacity/opacity.html",
    "<div class=\"ng-class: {inactive: !layergroup.isActive() || layergroup.baselayer || !showOpacitySlider}; progress\">\n" +
    "    <div class=\"progress-bar\" role=\"progressbar\" ng-style=\"{ 'width': percOpacity }\">\n" +
    "      <span class=\"sr-only\"></span>\n" +
    "    </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("scenarios/scenarios.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("scenarios/scenarios.html",
    "<div class=\"card\" ng-controller=\"ScenariosCtrl\">\n" +
    "  <div class=\"card-content\">\n" +
    "    <div ng-if=\"loading\">\n" +
    "      <i class=\"fa fa-refresh fa-spin\"></i>\n" +
    "    </div>\n" +
    "\n" +
    "    <div ng-if=\"selectedScenario === null\">\n" +
    "      <span id=\"title-holder\" class=\"card-title-text ng-binding\" translate>\n" +
    "        3di resultaten\n" +
    "      </span>\n" +
    "\n" +
    "      <table class=\"table table-hover scenarios-table\">\n" +
    "        <tbody\n" +
    "          ng-if=\"scenarios.length > 0\"\n" +
    "          class=\"scenarios-table-body\"\n" +
    "          >\n" +
    "          <tr ng-repeat=\"scenario in scenarios | filter: query\"\n" +
    "            class=\"scenarios-table-row clickable\">\n" +
    "            <td ng-click=\"select(scenario)\" title=\"<% scenario.model_name %>\"><% scenario.name %> </td>\n" +
    "            <td ng-click=\"select(scenario)\" class=\"clickable text-right\" ><% scenario.created | date: 'M/d/y HH:mm:ss' %></td>\n" +
    "          </tr>\n" +
    "        </tbody>\n" +
    "\n" +
    "      </table>\n" +
    "\n" +
    "      <nav>\n" +
    "        <ul class=\"pagination\">\n" +
    "          <li>\n" +
    "          <a ng-if=\"previous\"\n" +
    "            title=\"Previous\"\n" +
    "            ng-click=\"getPage(page - 1)\" aria-label=\"Previous\">\n" +
    "            <span aria-hidden=\"true\" translate>&laquo; Previous</span>\n" +
    "          </a>\n" +
    "          </li>\n" +
    "          <li ng-repeat=\"_page in pages\" ng-class=\"{active: page === _page}\">\n" +
    "            <a ng-click=\"getPage(_page)\"><% _page %></a>\n" +
    "          </li>\n" +
    "          <li>\n" +
    "          <a ng-if=\"next\"\n" +
    "            title=\"Next\"\n" +
    "            ng-click=\"getPage(page + 1)\" aria-label=\"Next\">\n" +
    "            <span aria-hidden=\"true\" translate>Next &raquo;</span>\n" +
    "          </a>\n" +
    "          </li>\n" +
    "        </ul>\n" +
    "      </nav>\n" +
    "\n" +
    "    </div>\n" +
    "\n" +
    "    <div ng-if=\"selectedScenario\">\n" +
    "      <a ng-click=\"select(selectedScenario)\" class=\"clickable\" title=\"Terug\"><i class=\"fa fa-arrow-left\"></i></a>\n" +
    "\n" +
    "      <span id=\"title-holder\" class=\"card-title-text ng-binding\">\n" +
    "        <% selectedScenario.name %> -\n" +
    "        <a href=\"https://models.lizard.net/model_databank/models/<% selectedScenario.model_name %>/commits/\" target=\"_blank\" title=\"Go to the Model database\"><% selectedScenario.model_name %></a> #<% selectedScenario.model_revision %>\n" +
    "      </span>\n" +
    "\n" +
    "      <table class=\"table table-condensed result-table\">\n" +
    "        <tr>\n" +
    "          <td><span translate>Started (simulation time)</span></td>\n" +
    "          <td><% selectedScenario.start_time_sim | date: 'M/d/y HH:mm:ss' %></td>\n" +
    "        </tr>\n" +
    "        <tr>\n" +
    "          <td><span translate>Ended (simulation time)</span></td>\n" +
    "          <td><% selectedScenario.end_time_sim | date: 'M/d/y HH:mm:ss' %></td>\n" +
    "        </tr>\n" +
    "        <tr\n" +
    "          ng-class=\"{'selected-result': result.lg._active, clickable: result.layer_group}\"\n" +
    "          ng-repeat=\"result in selectedScenario.result_set\">\n" +
    "          <td ng-click=\"preview(result)\"><% result.result_type.name %>\n" +
    "            <a ng-if=\"result.layer_group\" translate>(preview)</a>\n" +
    "         </td>\n" +
    "          <td>\n" +
    "            <a ng-if=\"result.result_type.code !== 'damage_estimation_json'\"\n" +
    "               href=\"<% result.attachment_url %>\" target=\"_blank\" translate>Download</a>\n" +
    "            <a ng-if=\"result.result_type.code === 'damage_estimation_json'\"\n" +
    "               href=\"<% result.attachment_url %>\" target=\"_blank\" translate>\n" +
    "              <span translate>\n" +
    "                €<% result.value | number: 2%> | Download\n" +
    "              </span>\n" +
    "            </a>\n" +
    "          </td>\n" +
    "        </tr>\n" +
    "      </table>\n" +
    "      <span ng-if=\"selectedScenario.result_set.length === 0\" translate>\n" +
    "        No results\n" +
    "      </span>\n" +
    "    </div>\n" +
    "\n" +
    "  </div><!-- card-content-->\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("timeline/timeline.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("timeline/timeline.html",
    "<div id=\"timeline\"\n" +
    "     ng-controller=\"TimeCtrl as timeline\">\n" +
    "\n" +
    "  <div class=\"timeline-wrapper\">\n" +
    "    <div class=\"time-controls\" id=\"time-controls\" ng-if=\"timeline.animatable\">\n" +
    "      <div class=\"btn-group\">\n" +
    "        <a ng-click=\"timeline.playPauseAnimation()\"\n" +
    "           class=\"extra-padding timeline-button\"\n" +
    "           ng-class=\"{\n" +
    "            'active': timeline.state.temporal.playing,\n" +
    "            'hidden': !timeline.animatable\n" +
    "           }\"\n" +
    "           title=\"<% timeline.state.temporal.playing ? tooltips.stopAnim : tooltips.startAnim %>\"\n" +
    "           data-original-title=\"<% 'Play/pause' | translate %>\">\n" +
    "          <span\n" +
    "            class=\"fa\"\n" +
    "            ng-class=\"{\n" +
    "              'fa-circle-o-notch fa-spin': timeline.state.layerGroups.timeIsSyncing,\n" +
    "              'fa-pause active': timeline.state.temporal.playing,\n" +
    "              'fa-play': !timeline.state.temporal.playing && !timeline.state.layerGroups.timeIsSyncing,\n" +
    "              }\">\n" +
    "          </span>\n" +
    "        </a>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "    <div id=\"timeline-svg-wrapper\" class=\"timeline-svg-wrapper\">\n" +
    "      <svg></svg>\n" +
    "    </div>\n" +
    "    <div class=\"time-controls-right\">\n" +
    "      <div class=\"btn-group-vertical\">\n" +
    "          <a class=\"btn btn-default btn-xss\" ng-click=\"timeline.zoom('in')\"\n" +
    "            class=\"extra-padding timeline-button\"\n" +
    "            title=\"<% tooltips.zoomInTimeline %>\"\n" +
    "            data-original-title=\"Zoom in\">\n" +
    "            <i class=\"fa fa-plus\"></i>\n" +
    "          </a>\n" +
    "          <a class=\"btn btn-default btn-xss\" ng-mousedown=\"timeline.zoomToNow()\"\n" +
    "            class=\"extra-padding timeline-button\"\n" +
    "            title=\"<% tooltips.goToNow %>\"\n" +
    "            data-original-title=\"Naar nu\">\n" +
    "            <i class=\"fa fa-clock-o\"></i>\n" +
    "          </a>\n" +
    "          <a class=\"btn btn-default btn-xss\" ng-click=\"timeline.zoom('out')\"\n" +
    "            class=\"extra-padding timeline-button\"\n" +
    "            title=\"<% tooltips.zoomOutTimeline %>\"\n" +
    "            data-original-title=\"Zoom uit\">\n" +
    "            <i class=\"fa fa-minus\"></i>\n" +
    "          </a>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("timeseries/timeseries.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("timeseries/timeseries.html",
    "<div class=\"card active\" ng-if=\"asset.timeseries.length > 0\">\n" +
    "  <div class=\"card-content\">\n" +
    "\n" +
    "    <div class=\"timeseries-header-container\">\n" +
    "      <i class=\"fa\" ng-class=\"{\n" +
    "        'fa-spin': fetching && timeseries.selected.value_type !== image,\n" +
    "        'fa-clock-o': timeseries.selected.value_type !== 'image',\n" +
    "        'fa-file-image-o': timeseries.selected.value_type === 'image'\n" +
    "      }\"></i>\n" +
    "      <select\n" +
    "        class=\"timeseries\"\n" +
    "        ng-if=\"asset.timeseries.length > 1\"\n" +
    "        ng-class=\"{hidden: !fullDetails}\"\n" +
    "        ng-model=\"timeseries.selected\"\n" +
    "        ng-change=\"timeseries.change()\"\n" +
    "        ng-options=\"ts.location\n" +
    "          + ', '\n" +
    "          + ts.parameter\n" +
    "          for ts in asset.timeseries track by ts.uuid\n" +
    "        \">\n" +
    "      </select>\n" +
    "      <span\n" +
    "        class=\"card-title-text placeholder\"\n" +
    "        ng-if=\"asset.timeseries.length === 1 && fullDetails\">\n" +
    "        <% asset.timeseries[0].location\n" +
    "          + ', '\n" +
    "          + asset.timeseries[0].parameter %>\n" +
    "      </span>\n" +
    "      <span class=\"card-title-text placeholder\" ng-class=\"{hidden: fullDetails}\" translate>Timeseries</span>\n" +
    "      <full-details></full-details>\n" +
    "    </div>\n" +
    "\n" +
    "\n" +
    "    <div ng-if=\"content.length\">\n" +
    "\n" +
    "      <br>\n" +
    "\n" +
    "      <div ng-if=\"content[0].valueType !== 'image'\">\n" +
    "        <div class=\"timeseries-graph-container\"\n" +
    "            ng-class=\"{hidden: !fullDetails}\"\n" +
    "            ng-if=\"content[0].type === 'bar-chart'\">\n" +
    "           <graph\n" +
    "              bar-chart\n" +
    "              type=\"temporal\"\n" +
    "              temporal=\"timeState\"\n" +
    "              content=\"content\"\n" +
    "              now=\"timeState.at\">\n" +
    "            </graph>\n" +
    "        </div>\n" +
    "\n" +
    "        <div class=\"timeseries-graph-container\"\n" +
    "          ng-class=\"{hidden: !fullDetails}\"\n" +
    "            ng-if=\"content[0].type !== 'bar-chart'\">\n" +
    "          <graph\n" +
    "            line\n" +
    "            type=\"temporal\"\n" +
    "            temporal=\"timeState\"\n" +
    "            content=\"content\"\n" +
    "            now=\"timeState.at\">\n" +
    "          </graph>\n" +
    "        </div>\n" +
    "\n" +
    "        <div class=\"card-tools\"\n" +
    "          ng-class=\"{hidden: !fullDetails}\">\n" +
    "          <a\n" +
    "            target=\"_blank\"\n" +
    "            href=\"<% timeseries.selected.url %>\"\n" +
    "            class=\"btn btn-default btn-xs\"\n" +
    "            title=\"<% 'Export info card data' | translate %>\">\n" +
    "            <i class=\"fa fa-share-square-o\"></i>\n" +
    "            <span translate>Export</span>\n" +
    "          </a>\n" +
    "        </div>\n" +
    "      </div>\n" +
    "\n" +
    "      <div ng-if=\"content[0].valueType === 'image'\">\n" +
    "\n" +
    "      <!-- hardcoded context, timeseries directive is only used in omnibox when\n" +
    "           map -->\n" +
    "        <image-carousel\n" +
    "          images=\"content[0].data\"\n" +
    "          context=\"map\"\n" +
    "          temporal=\"timeState\">\n" +
    "        </image-carousel>\n" +
    "\n" +
    "      </div>\n" +
    "\n" +
    "    </div>\n" +
    "\n" +
    "\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("user-menu/user-menu.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("user-menu/user-menu.html",
    "<nav class=\"navbar navbar-default\">\n" +
    "  <div id=\"lizard-apps-container\" class=\"lizard-apps-container material-shadow\"></div>\n" +
    "  <div class=\"container-fluid\">\n" +
    "    <div class=\"navbar-header\">\n" +
    "      <button type=\"button\"\n" +
    "              class=\"navbar-toggle\"\n" +
    "              data-toggle=\"collapse\"\n" +
    "              data-target=\".navbar-collapse\">\n" +
    "        <span class=\"sr-only\">Toggle navigation</span>\n" +
    "        <span class=\"icon-bar\"></span>\n" +
    "        <span class=\"icon-bar\"></span>\n" +
    "        <span class=\"icon-bar\"></span>\n" +
    "      </button>\n" +
    "    </div>\n" +
    "    <div class=\"navbar-collapse collapse\">\n" +
    "      <ul class=\"nav navbar-nav navbar-left\">\n" +
    "        <li ng-show=\"showApps\">\n" +
    "          <a id=\"lizard-apps-button\"\n" +
    "             class=\"lizard-apps-button\"\n" +
    "             title=\"Apps\"\n" +
    "             href=\"\">\n" +
    "          </a>\n" +
    "        </li>\n" +
    "        <li ng-if=\"context == 'map'\">\n" +
    "          <a ng-click=\"toggleDashboard()\"\n" +
    "             title=\"<% 'Switch to dashboard' | translate %>\"\n" +
    "             target=\"_blank\"\n" +
    "             accesskey=\"d\"\n" +
    "             href=\"\">\n" +
    "            <i class=\"fa fa-bar-chart\"></i>\n" +
    "            <span translate>Dashboard</span>\n" +
    "          </a>\n" +
    "        </li>\n" +
    "        <li ng-if=\"context == 'dashboard'\">\n" +
    "          <a class=\"hidden-xs\"\n" +
    "             ng-click=\"toggleDashboard()\"\n" +
    "             title=\"<% 'Switch to map' | translate %>\"\n" +
    "             target=\"_blank\"\n" +
    "             accesskey=\"m\"\n" +
    "             href=\"\">\n" +
    "            <i class=\"fa fa-globe\"></i>\n" +
    "            <span translate>Map</span>\n" +
    "          </a>\n" +
    "        </li>\n" +
    "        <li ng-if=\"user.authenticated\"\n" +
    "            ng-class=\"{'open': favourites.enabled}\">\n" +
    "          <a title=\"<% 'Favourites' | translate %>\"\n" +
    "             href=\"\"\n" +
    "             ng-click=\"toggleFavourites($event)\">\n" +
    "            <i class=\"fa fa-star\"></i>\n" +
    "            <span translate>Favourites</span>\n" +
    "            <span class=\"caret\"></span>\n" +
    "          </a>\n" +
    "        </li>\n" +
    "      </ul>\n" +
    "      <ul class=\"nav navbar-nav navbar-right\">\n" +
    "        <li ng-if=\"!user.authenticated\">\n" +
    "          <a href=\"https://www.lizard.net/support\"\n" +
    "             title=\"<% 'Question and manual' | translate %>\"\n" +
    "             target=\"_blank\">\n" +
    "            <i class=\"fa fa-question\"></i>\n" +
    "            <span translate>Help</span>\n" +
    "          </a>\n" +
    "        </li>\n" +
    "        <li ng-if=\"!user.authenticated\">\n" +
    "          <a onclick=\"logIn()\"\n" +
    "             title=\"<% tooltips.login %>\"\n" +
    "             class=\"clickable\">\n" +
    "            <div ng-cloak id=\"username\">\n" +
    "              <i id=\"\" class=\"fa fa-user\"></i>\n" +
    "              <span translate>Log in</span>\n" +
    "            </div>\n" +
    "          </a>\n" +
    "        </li>\n" +
    "        <li class=\"dropdown\" ng-if=\"user.authenticated\">\n" +
    "          <a title=\"<% tooltips.profile %>\"\n" +
    "             class=\"dropdown-toggle\"\n" +
    "             data-toggle=\"dropdown\"\n" +
    "             role=\"button\"\n" +
    "             aria-haspopup=\"true\"\n" +
    "             aria-expanded=\"false\"\n" +
    "             href=\"#\">\n" +
    "            <div ng-cloak id=\"username\">\n" +
    "              <i class=\"fa fa-user\"></i>\n" +
    "              <span ng-bind=\"user.firstName\"></span>\n" +
    "              <span class=\"caret\"></span>\n" +
    "            </div>\n" +
    "          </a>\n" +
    "          <ul class=\"dropdown-menu\">\n" +
    "            <li>\n" +
    "              <a href=\"https://www.lizard.net/support\"\n" +
    "                 title=\"<% 'Question and manual' | translate %>\"\n" +
    "                 target=\"_blank\">\n" +
    "                <i class=\"fa fa-question\"></i>\n" +
    "                <span translate>Help</span>\n" +
    "              </a>\n" +
    "            </li>\n" +
    "            <li>\n" +
    "              <a href=\"http://sso.lizard.net/edit_profile/\"\n" +
    "                 title=\"<% 'Edit profile' | translate %>\">\n" +
    "                <i class=\"fa fa-pencil\"></i>\n" +
    "                <span translate>Edit profile</span>\n" +
    "              </a>\n" +
    "            </li>\n" +
    "            <li role=\"separator\" class=\"divider\"></li>\n" +
    "            <li>\n" +
    "              <a ng-if=\"user.authenticated\"\n" +
    "                 class=\"logout user\"\n" +
    "                 href=\"/accounts/logout/?next=/\"\n" +
    "                 title=\"<% tooltips.logout %>\"\n" +
    "                 onclick=\"return logOut()\">\n" +
    "                 <i id=\"\" class=\"fa fa-power-off\"></i>\n" +
    "                 <span translate>Log out</span>\n" +
    "              </a>\n" +
    "            </li>\n" +
    "          </ul>\n" +
    "        </li>\n" +
    "      </ul>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</nav>\n" +
    "");
}]);
