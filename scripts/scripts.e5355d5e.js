angular.module('gettext').run(['gettextCatalog', function (gettextCatalog) {
/* jshint -W100 */
    gettextCatalog.setStrings('en', {"(preview)":"(preview)","3di resultaten":"3di resultaten","<% entityname=\"\" |=\"\" objecttitle=\"\" %=\"\">\n        </%>":"<% entityname=\"\" |=\"\" objecttitle=\"\" %=\"\">\n        </%>","<% waterchain.layers.waterchain_grid.data.entity_name=\"\" |=\"\" objecttitle=\"\" %=\"\">\n    </%>":"<% waterchain.layers.waterchain_grid.data.entity_name=\"\" |=\"\" objecttitle=\"\" %=\"\">\n    </%>","<span translate=\"\">\n                €<% result.value=\"\" |=\"\" number:=\"\" 2%=\"\"> | Download\n              </%></span>":"<span translate=\"\">\n                €<% result.value=\"\" |=\"\" number:=\"\" 2%=\"\"> | Download\n              </%></span>","Add an annotation":"Add an annotation","Adjust opacity":"Adjust opacity","Annotation attachment size cannot be bigger than 10MB.":"Annotation attachment size cannot be bigger than 10MB.","Annotation message...":"Annotation message...","Annotation text cannot be longer than 256 characters.":"Annotation text cannot be longer than 256 characters.","Annotation text is required.":"Annotation text is required.","Aquifer confinement":"Aquifer confinement","Baselayer":"Baselayer","Bosom channel":"Bosom channel","Bottom level":"Bottom level","Bottom level manhole":"Bottom level manhole","Bridge":"Bridge","Capacity":"Capacity","Category":"Category","Channel":"Channel","Close data menu":"Close data menu","Close result window":"Close result window","Close timeline":"Close timeline","Coating":"Coating","Code":"Code","Construction year":"Construction year","Control":"Control","Could not create annotation.":"Could not create annotation.","Could not delete previously retrieved annotation:":"Could not delete previously retrieved annotation:","Crest Level":"Crest Level","Crest height":"Crest height","Crest level":"Crest level","Crest width":"Crest width","Crossprofile":"Crossprofile","Culvert":"Culvert","Delete this annotation from the database.":"Delete this annotation from the database.","Diameter":"Diameter","Double click for lizard version number":"Double click for lizard version number","Download":"Download","Download attachment.":"Download attachment.","Duration":"Duration","End":"End","End of current timeline":"End of current timeline","Ended (simulation time)":"Ended (simulation time)","Example value":"Example value","Export":"Export","Export info card data":"Export info card data","Extra statistieken, herhalingstijden":"Extra statistieken, herhalingstijden","Filter":"Filter","Filter bottom level":"Filter bottom level","Filter top level":"Filter top level","Frequency":"Frequency","Go to the present in timeline":"Go to the present in timeline","Groundwater station":"Groundwater station","Height":"Height","Invert level end point":"Invert level end point","Invert level start point":"Invert level start point","Length":"Length","Levee":"Levee","Levee reference point":"Levee reference point","Line selection":"Line selection","Litology":"Litology","Locations":"Locations","Log in":"Log in","Log out":"Log out","Manhole":"Manhole","Manhole id":"Manhole id","Map":"Map","Material":"Material","Measuring station":"Measuring station","Modify profile":"Modify profile","Name":"Name","No results":"No results","One annotation":["One annotation","<% $count %> annotations"],"Oops! Something went wrong while creating the annotation.":"Oops! Something went wrong while creating the annotation.","Oops! Something went wrong while deleting the annotation.":"Oops! Something went wrong while deleting the annotation.","Open data menu":"Open data menu","Open timeline":"Open timeline","Open water level (average)":"Open water level (average)","Orifice":"Orifice","Outlet":"Outlet","Overflow":"Overflow","Pipe":"Pipe","Play/pause":"Play/pause","Point selection":"Point selection","Pressure pipe":"Pressure pipe","Primary channel":"Primary channel","Pump":"Pump","Pump station":"Pump station","Question and manual":"Question and manual","RT (years)":"RT (years)","Rain":"Rain","Recurrence times (RT)":"Recurrence times (RT)","Region selection":"Region selection","Search for places, or dates (i.e. 23-10-2013)":"Search for places, or dates (i.e. 23-10-2013)","Shape":"Shape","Show dashboard":"Show dashboard","Sluice":"Sluice","Start":"Start","Start animation":"Start animation","Start level":"Start level","Start of current timeline":"Start of current timeline","Started (simulation time)":"Started (simulation time)","Statistics":"Statistics","Stop animation":"Stop animation","Stop level":"Stop level","Surface level":"Surface level","The 'now' of the timeline":"The 'now' of the timeline","Time":"Time","Timeseries":"Timeseries","Top level":"Top level","Type":"Type","View selection":"View selection","Wastewater treatment plant":"Wastewater treatment plant","Weir":"Weir","Widht":"Widht","Width":"Width","Zoom in on the map":"Zoom in on the map","Zoom in on timeline":"Zoom in on timeline","Zoom out of timeline":"Zoom out of timeline","Zoom out on the map":"Zoom out on the map","code":"code","mm":"mm","mm / 5 min":"mm / 5 min","mm / day":"mm / day","mm / hour":"mm / hour","mm / month":"mm / month","€<% result.value=\"\" |=\"\" number:=\"\" 2%=\"\"> | Download\n              </%>":"€<% result.value=\"\" |=\"\" number:=\"\" 2%=\"\"> | Download\n              </%>"});
    gettextCatalog.setStrings('nl', {"(preview)":"(preview)","3di resultaten":"3di resultaten","Add an annotation":"Voeg een annotatie toe","Adjust opacity":"Transparantie aanpassen","Annotation attachment size cannot be bigger than 10MB.":"Bestand met annotaties mag niet groter zijn dan 10MB.","Annotation message...":"Annotatie bericht...","Annotation text cannot be longer than 256 characters.":"Annotatie mag niet langer zijn dan 256 karakters.","Annotation text is required.":"Annotatie is vereist.","Aquifer confinement":"Watervoerend pakket","Baselayer":"Basislaag","Bosom channel":"Boezemkanaal","Bottom level":"Onderkant buis","Bottom level manhole":"Putbodem","Bridge":"Brug","Capacity":"Capaciteit","Category":"Categorie","Channel":"Watergang","Close data menu":"Sluit het datamenu","Close result window":"Sluit het resultatenvenster","Close timeline":"Sluit de tijdlijn","Coating":"Bekleding","Code":"Code","Construction year":"Bouwjaar","Control":"Bediening","Could not create annotation.":"Aanmaken van annotatie is mislukt.","Could not delete previously retrieved annotation:":"Verwijderen van vorige annotatie is mislukt:","Crest Level":"Niveau","Crest height":"Kruinhoogte","Crest level":"Overstorthoogte","Crest width":"Overstortbreedte","Crossprofile":"Dwarsprofiel","Culvert":"Duiker","Delete this annotation from the database.":"Verwijder deze annotatie uit de database.","Diameter":"Diameter","Double click for lizard version number":"Dubbelklikken voor lizard versienummer","Download":"Download","Download attachment.":"Bijlage downloaden.","Duration":"Duur","End":"Einde","End of current timeline":"Einde van de huidige tijdlijn","Ended (simulation time)":"Einde (simulatie tijd)","Example value":"Voorbeeldwaarde","Export":"Exporteer","Export info card data":"Exporteer infocard data","Extra statistieken, herhalingstijden":"Extra statistieken, herhalingstijden","Filter":"Filter","Filter bottom level":"Onderkant filter","Filter top level":"Bovenkant filter","Frequency":"Frequentie","Go to the present in timeline":"Ga naar het heden in de tijdlijn","Groundwater station":"Grondwatermeetpunt","Height":"Hoogte","Invert level end point":"BOB eindpunt","Invert level start point":"BOB beginpunt","Length":"Lengte","Levee":"Kering","Levee reference point":"Keringreferentiepunt","Line selection":"Lijnselectie","Litology":"Litology","Locations":"Locaties","Log in":"Inloggen","Log out":"Uitloggen","Manhole":"Put","Manhole id":"Put id","Map":"Kaart","Material":"Materiaal","Measuring station":"Meetstation","Modify profile":"Profiel aanpassen","Name":"Naam","No results":"Geen resultaten","One annotation":["Eén annotatie","<% $count %> annotaties"],"Oops! Something went wrong while creating the annotation.":"Oeps! Er is iets misgegaan bij het aanmaken van de annotatie.","Oops! Something went wrong while deleting the annotation.":"Oeps! Er is iets misgegaan bij het verwijderen van de annotatie.","Open data menu":"Open het datamenu","Open timeline":"Open de tijdlijn","Open water level (average)":"Buitenwaterstand (gemiddeld)","Orifice":"Doorlaat","Outlet":"Uitlaat","Overflow":"Overstort","Pipe":"Leiding","Play/pause":"Play/pauze","Point selection":"Puntselectie","Pressure pipe":"Persleiding","Primary channel":"Primaire watergang","Pump":"Pomp","Pump station":"Gemaal","Question and manual":"Vragen en handleiding","RT (years)":"HT (jaren)","Rain":"Regen","Recurrence times (RT)":"Herhalingstijden (HT)","Region selection":"Regio selectie","Search for places, or dates (i.e. 23-10-2013)":"Zoek naar plaatsen of data (bv. 23-10-2013)","Shape":"Vorm","Show dashboard":"Toon het dashboard","Sluice":"Sluis","Start":"Start","Start animation":"Start animatie","Start level":"Aanslagpeil","Start of current timeline":"Start van de huidige tijdlijn","Started (simulation time)":"Start (simulatie tijd)","Statistics":"Statistieken","Stop animation":"Stop animatie","Stop level":"Afslagpeil","Surface level":"Maaiveldhoogte","The 'now' of the timeline":"Het 'nu' van de tijdlijn","Time":"Tijd","Timeseries":"Tijdreeksen","Top level":"Bovenkant buis","Type":"Type","View selection":"Schermselectie","Wastewater treatment plant":"Afvalwaterzuivering","Weir":"Stuw","Widht":"Breedte","Width":"Breedte","Zoom in on the map":"Zoom in op de kaart","Zoom in on timeline":"Zoom in op de tijdlijn","Zoom out of timeline":"Zoom uit van de tijdlijn","Zoom out on the map":"Zoom uit van de kaart","code":"code","mm":"mm","mm / 5 min":"mm / 5 min","mm / day":"mm / dag","mm / hour":"mm / uur","mm / month":"mm / maand"});
/* jshint +W100 */
}]);
'use strict';

/**
 * Setup Raven if available.
 * Raven is responsible for logging to https://sentry.lizard.net
 */
if (window.RavenEnvironment) {
  window.Raven.config(window.RavenEnvironment, {
    ignoreUrls: [/localhost/]
  }).install();
  if (window.user.authenticated) {
    window.Raven.setUserContext({
      username: window.user.userName
    });
  }
}

/**
 * Initialise angular.module('lizard-nxt')
 *
 */
angular.module("lizard-nxt", [
  'lizard-nxt-filters',
  'data-menu',
  'map',
  'omnibox',
  'restangular',
  'dashboard',
  'time-ctx',
  'scenarios',
  'user-menu',
  'global-state',
  'ngSanitize',
  'ngCsv',
  'gettext',
  'timeseries'
])
// Decorator for ngExceptionHandler to log exceptions to sentry
  .config(function ($provide) {
  $provide.decorator("$exceptionHandler", function ($delegate) {
      return function (exception, cause) {
          $delegate(exception, cause);
          window.Raven.captureException(exception, {
            extra: {cause: cause}
          });
        };
    });
});

/**
 * Change default angular tags to prevent collision with Django tags.
 */
angular.module('lizard-nxt')
  .config(function ($interpolateProvider) {
  //To prevent Django and Angular Template hell
  $interpolateProvider.startSymbol('<%');
  $interpolateProvider.endSymbol('%>');
});

/**
 * Set url fragment behavior to HTML5 mode (without hash in url).
 */
angular.module('lizard-nxt')
  .config(function ($locationProvider) {
  // We want to release to gh-pages for demo purposes or whatever
  // But github.io doesn't rewrite the urls beautifully like we do.
  var html5Mode = (window.location.host !== 'nens.github.io' &&
                   window.location.host !== 'lizard.sandbox.lizard.net');
  $locationProvider.html5Mode(html5Mode);
});

/**
 * @name user
 * @memberOf app
 * @description User and auth stuff
 */
angular.module('lizard-nxt')
  .constant('user', window.user);

/**
 * @name versioning
 * @memberOf app
 * @description User and auth stuff
 */
angular.module('lizard-nxt')
  .constant('versioning', window.versioning);

/**
 * @name production backend
 * @memberOf app
 * @description subdomain of production backend.
 */
angular.module('lizard-nxt')
  .constant('backendDomain', 'https://demo.lizard.net');

/**
 * @name locale
 * @memberOf app
 * @description Portal's default locale.
 */
angular.module('lizard-nxt')
  .constant('defaultLocale', window.locale);


/**
 *
 * @name MasterController
 * @class MasterCtrl
 * @memberOf app
 *
 * @summary Master controller
 *
 * @description Binds logic and attributes to the global $scope. Keep
 *              this clean and put stuff in specific component controllers
 *              if it is not global.
 *
 */
angular.module('lizard-nxt')
  .controller('MasterCtrl',

  ['$scope',
   '$controller',
   '$timeout',
   'CabinetService',
   'UtilService',
   'ClickFeedbackService',
   'user',
   'versioning',
   'State',
   'MapService',

  function ($scope,
            $controller,
            $timeout,
            CabinetService,
            UtilService,
            ClickFeedbackService,
            user,
            versioning,
            State,
            MapService) {

  $scope.user = user;
  $scope.versioning = versioning;
  $scope.tooltips = CabinetService.createTooltips();

  // When the language changes we remake the tooltips for the current language.
  $scope.$on('gettextLanguageChanged', function () {
    $scope.tooltips = CabinetService.createTooltips();
  });

  // CONTEXT

  /**
   * Switch between contexts.
   *
   * @param {string} context - Context name to switch to
   */
  $scope.transitionToContext = function (context) {
    if (context !== State.context) {
      var overlay = angular.element('#context-transition-overlay')[0];
      overlay.style.minHeight = window.innerHeight + 'px';
      overlay.style.transition = 'ease .3s';
      $timeout(function () {
        overlay.style.opacity = 1;
      }, 300);
      $timeout(function () {
        State.context = context;
        $scope.context = State.context;
        overlay.style.opacity = 0;
      }, 600, true);
      $timeout(function () {
        overlay.style.transition = null;
        overlay.style.minHeight = 0;
      }, 900);
    }
  };

  // initialise context.
  $scope.context = State.context;

  // END CONTEXT

  $scope.toggleVersionVisibility = function () {
    $('.navbar-version').toggle();
  };

  UtilService.preventOldIEUsage();

  // catch window.load event
  window.addEventListener("load", function () {
    window.loaded = true;
    $scope.$apply(function () {
      $controller('UrlController', {$scope: $scope});
    });
  });


}]);

'use strict';

angular.module('lizard-nxt')
  .service("CabinetService", [
           "$q", "Restangular", "backendDomain", "gettextCatalog",
  function ($q, Restangular, backendDomain, gettextCatalog) {

  var geocodeResource,
      timeseriesResource,
      events,
      wmsGetFeatureInfo;

  // for the wizard demo's
  if (window.location.host === 'nens.github.io' ||
      window.location.host === 'lizard.sandbox.lizard.net') {
    Restangular.setBaseUrl(backendDomain);
    Restangular.setDefaultHttpFields({withCredentials: true});
  }

  timeseriesResource = Restangular.one('api/v2/timeseries/');
  events = Restangular.one('api/v2/events/?page_size=25000');
  var regions = Restangular.one('api/v2/regions/?page_size=500');

  // Wms getFeatureInfo goes through a proxy. Specify url as a param.
  wmsGetFeatureInfo = Restangular.one('proxy/');

  geocodeResource = Restangular
    // Use a different base url, go directly to our friends at google.
    // They don't mind.
    .withConfig(function(RestangularConfigurer) {
      RestangularConfigurer.setBaseUrl('https://maps.googleapis.com/maps');
    })
    .one('api/geocode/json');


  /**
   * Raster resource, last stop to the server
   * @param  {promise} q             a promise to cancel previous requests
   *                                 if none is given a local 'abortGet' is
   *                                 used.
   *                                 At the next request without a promise, the
   *                                 abortGet is cancelled.
   * @return {RestangularResource}  a gettable resource
   */
  var abortGet;
  var rasterResource = function (q) {
    var localPromise = q ? q : abortGet;
    if (localPromise === abortGet) {
      if (abortGet) {
        abortGet.resolve();
      }
      abortGet = $q.defer();
      localPromise = abortGet;
    }
    return Restangular
      .one('api/v2/raster-aggregates/')
      .withHttpConfig({timeout: localPromise.promise});
  };

  /**
   * Create tooltips for the current language.
   *
   * Tooltips are dynamic. When the language changes they have to update. This
   * function fetches the correct values from gettext and return a tooltip
   * object.
   * @return {tooltips} tooltip object with translated tooltips.
   */
  var createTooltips = function () {
    return {
      login: gettextCatalog.getString("Log in"),
      logout: gettextCatalog.getString("Log out"),
      profile: gettextCatalog.getString("Modify profile"),
      version: gettextCatalog.getString(
        "Double click for lizard version number"),
      openMenu: gettextCatalog.getString("Open data menu"),
      closeMenu: gettextCatalog.getString("Close data menu"),
      transparency: gettextCatalog.getString("Adjust opacity"),
      pointTool: gettextCatalog.getString("Point selection"),
      lineTool: gettextCatalog.getString("Line selection"),
      areaTool: gettextCatalog.getString("View selection"),
      resetQuery: gettextCatalog.getString("Close result window"),
      zoomInMap: gettextCatalog.getString("Zoom in on the map"),
      zoomOutMap: gettextCatalog.getString("Zoom out on the map"),
      zoomInTimeline: gettextCatalog.getString("Zoom in on timeline"),
      goToNow: gettextCatalog.getString("Go to the present in timeline"),
      zoomOutTimeline: gettextCatalog.getString("Zoom out of timeline"),
      startAnim: gettextCatalog.getString("Start animation"),
      stopAnim: gettextCatalog.getString("Stop animation"),
      timelineStart: gettextCatalog.getString("Start of current timeline"),
      timelineAt: gettextCatalog.getString("The 'now' of the timeline"),
      timelineEnd: gettextCatalog.getString("End of current timeline")
    };
  };

  return {
    events: events,
    createTooltips: createTooltips,
    geocode: geocodeResource,
    raster: rasterResource,
    timeseries: timeseriesResource,
    wmsGetFeatureInfo: wmsGetFeatureInfo,
    regions: regions
  };
}]);

/**
 * @ngdoc service
 * @class UtilService
 * @name UtilService
 * @summary Generic util functions.
 * @description Generic util functions.
 */
angular.module('lizard-nxt')
  .service("UtilService", ["NxtD3", "$timeout", function (NxtD3, $timeout) {

  /**
   * @function roundTimestamp
   * @memberOf UtilService
   * @summary Round javascript timestamp to nearest coefficient.
   *
   * @description For example, if you want to round timestamp to the nearest 5
   * minutes, coefficient = 1000 * 60 * 5 = 30000.
   *
   * @param {integer} timestamp - javascript timestamp in ms.
   * @param {integer} coefficient - coefficient to round to in ms.
   * @param {boolean} up - true if you want to round instead of floor.
   * offset.
   * @returns {integer} roundedTimestamp - timestamp rounded to nearest
   * coefficient.
   */
  this.roundTimestamp = function (timestamp, coefficient, up) {
    var format;

    if (up) {
      timestamp += coefficient / 2;
    }
    if (coefficient === 2635200000) { // One month
      format = NxtD3.prototype._localeFormatter.nl_NL.timeFormat("%m/01/%Y");
      return new Date(format(new Date(timestamp))).getTime();
    } else if (coefficient === 86400000) { // One day
      format = NxtD3.prototype._localeFormatter.nl_NL.timeFormat("%m/%d/%Y");
      return new Date(format(new Date(timestamp))).getTime();
    }
    var roundedTimestamp = parseInt(timestamp / coefficient, 10) * coefficient;

    return roundedTimestamp;
  };


  /**
   * Returns true for <protocol>:<domain>.
   * Or www with a domain. Both options might include paths, query params
   * and anchors. It does not return true for 'henkie.com' but basically
   * everything else is matched.
   *
   * @param  {str}  string string to test
   * @return {Boolean} true for urls, false otherwise.
   */
  this.isUrl = function (string) {
    return /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[\-;:&=\+\$,\w]+@)?[A-Za-z0-9\.\-]+|(?:www\.|[\-;:&=\+\$,\w]+@)[A-Za-z0-9\.\-]+)((?:\/[\+~%\/\.\w\-_]*)?\??(?:[\-\+=&;%@\.\w_]*)#?(?:[\.\!\/\\\w]*))?)/.test(string);
  };


  /**
   * @function fixTouch
   * @memberOf UtilService
   * @summary sets x and y for touch event.
   * @description webkit has a bug with touches.
   * this fixes the x and y coordinates of the touch.
   */
  this.fixTouch = function (touch) {
    var winPageX = window.pageXOffset,
        winPageY = window.pageYOffset,
        x = touch.clientX,
        y = touch.clientY;

    if (touch.pageY === 0 && Math.floor(y) > Math.floor(touch.pageY) ||
        touch.pageX === 0 && Math.floor(x) > Math.floor(touch.pageX)) {
      // iOS4 clientX/clientY have the value that should have been
      // in pageX/pageY. While pageX/page/ have the value 0
      x = x - winPageX;
      y = y - winPageY;
    } else if (y < (touch.pageY - winPageY) || x < (touch.pageX - winPageX)) {
      // Some Android browsers have totally bogus values for clientX/Y
      // when scrolling/zooming a page. Detectable since clientX/clientY
      // should never be smaller than pageX/pageY minus page scroll
      x = touch.pageX - winPageX;
      y = touch.pageY - winPageY;
    }

    return {
        clientX:    x,
        clientY:    y
      };
  };


  /**
   * @function getAggWindow
   * @memberOf UtilService
   *
   * @summary return aggregation window.
   *
   * @desc Returns aggWindow. Either five minutes, an hour or a day, should
   * lead to a minimum of three pixels within the drawing width.
   *
   * @param  {int} start    start of rainseries.
   * @param  {int} stop     end of rainseries.
   * @param  {int} drawingWidth size of graph in px.
   * @return {int} aggWindow in ms.
   */
  this.getAggWindow = function (start, stop, drawingWidth) {

    // TODO: Called both by omnibox and timeline, should be called only by
    // timeline, while omnibox subsequently syncs to timeState.aggWindow

    var aggWindow;
    var MIN_PX = 4; // Minimum width of a bar
    // Available zoomlevels
    var zoomLvls = {fiveMinutes: 300000,
                    hour: 3600000,
                    day: 86400000,
                    month: 2635200000}; // Month equals 30.5 days
    // ms per pixel
    var msPerPx = (stop - start) / drawingWidth;
    for (var zoomLvl in zoomLvls) {
      aggWindow = zoomLvls[zoomLvl];
      if (aggWindow > MIN_PX * msPerPx) {
        break; // If zoomlevel is sufficient to get enough width in the bars
      }
    }

    return aggWindow;
  };


  /**
   * @function fadeCurrentCards
   * @memberOf UtilService
   *
   * @summary Fade out (in) currently (in-)visible cards.
   *
   * @param {boolean} fadeIn - An Angular scope s.t.
   * scope.mapState.mapMoving is defined.
   */
  this.fadeCurrentCards = function (scope) {

    var cards = d3.selectAll(".card");

    if (!scope.mapState.mapMoving) {
      // card comes back instantaniously
      cards
        .style("opacity", 1);
    } else {
      // card fades away into transparancy, after a delay, but only if
      // the map is still moving after that delay
      setTimeout(function () {
        if (scope.mapState.mapMoving) {
          cards
            .transition(100)
            .style("opacity", 0.2);
        } else {
          cards
            .style("opacity", 1);
        }
      }, 700);
    }
  };

  /**
   * @function metersToDegs
   * @memberOf UtilService
   *
   * @summary Takes meters converts to radians, then converts degrees.
   *
   * @param  {float} meters
   * @return {float} degrees
   */
  this.metersToDegs = function (meters) {
    return (meters / 1000 / 6371) * 180 / Math.PI;
  };


  /**
   * @function createDataForTimeState
   * @memberOf UtilService
   *
   * @summary Creates a subset data object for a specific timeState.
   *
   * @param  {array} data      array of shape:
   *                           [
   *                             [t0, [[x0, y0], [x1, y1], ..., [xn, yn]],
   *                             [t1, [[x0, y0], [x1, y1], ..., [xn, yn]],
   *                             ...
   *                             [tm, [[x0, y0], [x1, y1], ..., [xn, yn]],
   *                           ]
   * @param  {object} timeState nxt timeState object
   * @return {array}           array (for timestep 1) of shape:
   *                           [[x0, y0_1], [x1, y1_1], ...]
   */
  this.createDataForTimeState = function (data, timeState) {
    var interval = timeState.end - timeState.start;
    var cur = timeState.at - timeState.start;
    var i = Math.round(data.length * cur / interval);
    var dataForTimeState = [];

    angular.forEach(data[i][1], function (value) {
      dataForTimeState.push([value[0], value[1]]);
    });

    return dataForTimeState;
  };


  /**
   * @function serveToOldIE
   * @memberOf UtilService
   * @description Check whether the client uses IE10+/non-IE browser
   *   (return false) OR that she uses an older IE version (return true)
   */
  this.serveToOldIE = function () {

    function getInternetExplorerVersion() {
      // Returns the version of Internet Explorer or -1
      // (indicating the use of another browser).

      var rv = -1, // Return value assumes failure.
          ua = navigator.userAgent,
          re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");

      if (re.exec(ua) !== null) {
        rv = parseFloat(RegExp.$1);
      }
      return rv;
    }
    var version = getInternetExplorerVersion();
    return version !== -1 && version < 10;
  };


  var checkForLine = function (geom) {
    if (geom.length > 1) {
      angular.forEach(geom, function (value) {
        if (!(value instanceof L.LatLng)) {
          return false;
        }
      });
      return true;
    }
  };


  /**
   * @function geomToWkt
   * @memberOf UtilService
   */
  this.geomToWkt = function (geom) {
    var coords = [];
    if (geom instanceof L.LatLng) {
      // geom is a L.LatLng object
      return "POINT(" + geom.lng + " " + geom.lat + ")";
    }

    else if (checkForLine(geom)) {
      // geom represents a line
      angular.forEach(geom, function (latLng) {
        coords.push(latLng.lng + " " + latLng.lat);
      });
      return "LINESTRING(" + coords.join(',') + ")";
    }

    else if (geom.type === 'Polygon') {
      var lng, lat;
      var cs = geom.coordinates[0];
      for (var i = 0; i < cs.length; i++) {
        coords.push(cs[i][0] + " " + cs[i][1]);
        if (i === 0) {
          lng = cs[i][0];
          lat = cs[i][1];
        }
      }
      return "POLYGON((" + coords.join(",") + "," + lng + " " + lat + "))";
    }

    else {
      // geom is a L.Bounds object
      return "POLYGON(("
            + geom.getWest() + " " + geom.getSouth() + ", "
            + geom.getEast() + " " + geom.getSouth() + ", "
            + geom.getEast() + " " + geom.getNorth() + ", "
            + geom.getWest() + " " + geom.getNorth() + ", "
            + geom.getWest() + " " + geom.getSouth()
            + "))";
    }
  };

  /**
   * @function buildString
   * @memberof UtilService
   * @description Glues all of it's arguments to a single string
   */
  this.buildString = function () {
    var i, result = "";
    for (i = 0; i < arguments.length; i++) {
      result += arguments[i];
    }
    return result;
  };


  /**
   * @function all
   * @memberof UtilService
   * @description - Checks whether ALL elements of the input satisfy the
   *                predicate
   * @param {arr} - An enumerable/iterable datastructure, e.g. Array
   * @param {predicate_} - A predicate, e.g.
   *                       'even': function (x) { x % 2 === 0 };
   * @return {boolean}
   */
  this.all = function (arr, predicate_) {
    var i,
        result = true,
        predicate = predicate_ || function (x) { return !!x; };
    for (i = 0; i < arr.length; i++) {
      result = result && predicate(arr[i]);
    }
    return result;
  };


  /**
   * @function any
   * @memberof UtilService
   * @description - Checks whether ANY element of the input satisfies the
   *   predicate
   * @param {arr} - An enumerable/iterable datastructure, e.g. Array
   * @param {predicate_} - A predicate, e.g. 'even':
   *   function (x) { x % 2 === 0 };
   * @return {boolean}
   */
  this.any = function (arr, predicate_) {
    var i,
        result = false,
        predicate = predicate_ || function (x) { return !!x; };
    for (i = 0; i < arr.length; i++) {
      result = result || predicate(arr[i]);
    }
    return result;
  };


  /**
   * @function
   * @memberOf UtilService
   * @description - Checks whether API response from the raster store has enough
   *                (non-null) data to actually put it on the scope.
   * @param {Object[]} response - An API response
   * @return {boolean}
   */
  this.isSufficientlyRichData = function (data) {

    if (data === undefined) {
      return false;

    } else if (data === 'null') {
      // backend did not return valid data.. log as ERROR?
      return false;

    } else if (this.nullOrNestedNull(data)) {
      // kill: null AND [null] AND [[null]] etc
      return false;

    } else if (data.constructor === Array) {

      if (data.length === 0) {
        // kill: []
        return false;

      } else if (this.all(data, function (x) { return x === null; })) {

        // kill: [null, null, ..., null]
        return false;

      } else if (data[0].constructor === Array) {

        if (data[0] === []) {
          return false;

        } else if (data[0].length === 1 && data[0][0] !== null) {
          return true;

        } else if (data[0].length > 1) {

          if (data[0][0].constructor === Array) {

            // kill: [[x0, [null]], [x1, [null]], ..., [xn, [null]]]
            return !this.all(data, function (elem) {
              return elem[1].length === 1 && elem[1][0] === null;
            });

          } else {

            // kill: [[x0, null], [x1, null], ..., [xn, null]]
            return !this.all(data, function (elem) {
              return elem[1] === null;
            });
          }
        }
      }
    }
    return true;
  };


  /**
   * @function
   * @memberOf UtilService
   * @description - checks whether passed in argument is null or nested null,
                    e.g: null, [null], [[null]] etc
   * @param {anything}
   * @return {boolean}
   */
  this.nullOrNestedNull = function (x) {

    if (x === null) {
      return true;

    } else if (x.constructor === Array && x.length === 1) {
      return this.nullOrNestedNull(x[0]);

    } else {
      return false;
    }
  };


  this.preventOldIEUsage = function () {
    if (this.serveToOldIE()) {
      document.querySelector("#dark-overlay").style.display = "block";
      document.querySelector("#mymodal").style.display = "block";
      // explicitly HIDE the layerMenu
      document.querySelector(".layer-switcher-wrapper").style.display = "none";
      // explicitly setZindex of a few items. This should NOT be in main.css
      // breaks functionality:
      var node = document.createElement('style');
      node.innerHTML = '#timeline, #searchbox, .container-fluid,'
        + '.navbar, #omnibox, .layer-menu-container,'
        + '.ribbon {'
        + ' z-index: 0;'
        + '}';
      document.body.appendChild(node);
    }
  };


  /**
   * @description - Deduce the wanted geometry-type from the passed in geomOpts
   * @param {object} geomOpts - the options.geom object
   * @return {string} - "POINT" | "LINE" | "AREA" | throw new Error!
   *
   * TODO: get rid of this maniacal reverse engineering of our own code.
   * could be as easy as `feature.geometry.type`.
   */
  this.getGeomType = function (geomOpts) {

    if (geomOpts instanceof L.LatLng) {
      return "POINT";

    } else if (geomOpts._southWest && geomOpts._northEast) {
      return "AREA";

    } else if (geomOpts.length === 2
      && geomOpts[0] instanceof L.LatLng
      && geomOpts[1] instanceof L.LatLng) {
      return "LINE";

    } else if (geomOpts.coordinates) { // geojson
      return "REGION";

    } else {
      throw new Error(
        "getGeomType could not deduce a valid geometry type from the passed " +
        " in arg: 'geomOpts' =", geomOpts
      );
    }
  };


  /**
   * @function
   * @description - Count all keys for an object (we can't do this vanilla.js
   *                style in Angular template)
   * @param {object} obj - The object for which we want to know the amount of
   *                       keys.
   * @return {integer} - The amount of keys.
   */
  this.countKeys = function (obj) {
    return obj === undefined ? 0 : Object.keys(obj).length;
  };


  /**
   * @function
   * @description Get correct icon for structure
   */
  this.getIconClass = function (str) {
    switch (str) {
    case 'pumpstation':
      return 'icon-pumpstation-diesel';
    case 'bridge':
      return 'icon-bridge';
    case 'bridge-draw':
      return 'icon-bridge';
    case 'bridge-fixed':
      return 'icon-bridge';
    default:
      return 'icon-' + str;
    }
  };


  /* @description - Convert lin to log scale, given the following 3 args.
   * @param {number} value - the value to convert
   * @param {number} minValue - the start of the scale
   * @param {number} maxValue - the end of the scale
   * @return {number} - The converted value
   */
  this.lin2log = function (value, minValue, maxValue, minDomain, maxDomain) {
    var scale = d3.scale.log()
      .domain([minDomain, maxDomain])
      .range([minValue, maxValue]);
    return scale(value);
  };


  /**
   * @description - This add a <style> tag + it's contents to the <head> of the
   *                page. Adding more will iteratively subsitute the most recent
   *                addition.
   * @param {string} newStyle - A string representing the to-be-added CSS
   * @return {void}
   */
  this.addNewStyle = function (newStyle) {
    var styleElement = document.getElementById('styles_js');
    if (!styleElement) {
      styleElement = document.createElement('style');
      styleElement.type = 'text/css';
      styleElement.id = 'styles_js';
      document.getElementsByTagName('head')[0].appendChild(styleElement);
    }
    styleElement.innerHTML = "";
    styleElement.appendChild(document.createTextNode(newStyle));
  };


  /*
   * @description - Convert string ending in px to value expressed in pixels,
   *                it denotes.
   * @param {string} str - The string to be converted.
   */
  this.pxToInt = function (str) {
    try {
      return parseInt(str.replace("px", ""));
    } catch (e) {
      throw new Error("Could not extract integer from string: '" + str + "'");
    }
  };


  /**
   * @function
   * @description - Get amount of Km^2 in the current spatial extent
   *                (bottom-limit = 1)
   * @param {latLngBounds} leafletBounds - A leaflet bounds object denoting the
   *                                       current spatial extent.
   * @return {number} - A number denoting the extent's corresponding perimeter
   *                   (expressed in Km^2)
   */
  this.extent2kilometers = function (leafletBounds) {

    var northWest = L.latLng({
          lat: leafletBounds._southWest.lat,
          lng: leafletBounds._northEast.lng
        }),
        southEast = L.latLng({
          lat: leafletBounds._northEast.lat,
          lng: leafletBounds._southWest.lng
        }),
        latDistance = leafletBounds._southWest.distanceTo(southEast) / 1000,
        lngDistance = leafletBounds._northEast.distanceTo(northWest) / 1000;

    // On high zoomlevels, we limit the area to 1km^2 since that's the
    // spatial resolution ("pixel") for radar data in the rasterstore.
    return Math.max(1, latDistance * lngDistance);
  };

  /*
   * @function
   * @description wrapper around lodash.union function
   * which works better than our own implementation..
   * Could be more efficient to call from api in a batch
   * instead of tiled/geojson stuff.
   */
  this.union = _.union;

  // Add comparator to sort lists on multiple properties to D3.
  (function () {
    d3.comparator = function () {
      var cmps = [], accessors = [];

      var comparator = function (a, b) {
        var i = -1,
            n = cmps.length,
            result;
        while (++i < n) {
          result = cmps[i](accessors[i](a), accessors[i](b));
          if (result !== 0) { return result; }
        }
        return 0;
      };

      comparator.order = function (cmp, accessor) {
        cmps.push(cmp);
        accessors.push(accessor || identity);
        return comparator;
      };

      return comparator;
    };

    function identity(d) { return d; }
  })();

  this.MIN_TIME = (new Date("Jan 01, 1900")).getTime();
  this.MAX_TIME = (new Date()).getTime() + 24 * 60 * 60 * 1000;
  this.TIMELINE_LEFT_MARGIN = 60;
  this.TIMELINE_RIGHT_MARGIN = 40;

  this.getMinTime = function (currentTime) {
    return Math.max(this.MIN_TIME, currentTime);
  };

  this.getMaxTime = function (currentTime) {
    return Math.min(this.MAX_TIME, currentTime);
  };

  this.getCurrentWidth = function () {
    return window.innerWidth - (
      this.TIMELINE_LEFT_MARGIN + this.TIMELINE_RIGHT_MARGIN
    );
  };

  this.hexColorToDecimalTriple = function (rgbString) {

    var rInt, gInt, bInt;

    if (rgbString.charAt(0) === "#") {
      rgbString = rgbString.substring(1, rgbString.length);
    }

    if (rgbString.length === 3) {
      rInt = parseInt(rgbString.charAt(0) + rgbString.charAt(0), 16);
      gInt = parseInt(rgbString.charAt(1) + rgbString.charAt(1), 16);
      bInt = parseInt(rgbString.charAt(2) + rgbString.charAt(2), 16);

    } else if (rgbString.length === 6) {
      rInt = parseInt(rgbString.substring(0, 2), 16);
      gInt = parseInt(rgbString.substring(2, 4), 16);
      bInt = parseInt(rgbString.substring(4, 6), 16);

    } else {
      throw new Error("This is not a valid color-string: '" + rgbString + "'");
    }

    return [rInt, gInt, bInt];
  };

  this.decimalTripleToHexColor = function (rgbTriple) {

    if (rgbTriple && rgbTriple.length === 3) {
      var rgbString = "#",
          currentHexString;
      rgbTriple.forEach(function (elem) {
        currentHexString = elem.toString(16);
        if (currentHexString.length === 1) {
          currentHexString = "0" + currentHexString;
        }
        rgbString += currentHexString;
      });
      return rgbString;

    } else {
      throw new Error("This aint a valid triple to convert into rgbString: " +
                      rgbTriple);
    }
  };

  /**
   * @descriptions - Round numbers, but use specified decimalCount for
   *                 resolution
   * @param {number} nr- The number to round.
   * @param {integer/undefined} - The amount of decimals wanted.
   * @return {float} - The formatted number
   */
  this.round = function (nr, decimalCount) {
    var multiplier = Math.pow(10, decimalCount || 0);
    return Math.round(nr * multiplier) / multiplier;
  };

  /**
   * @function
   * @description - "%f-in-javascript", you know the drill
   *
   * @param {number} x - The input you want to convert
   * @param {integer} wantedIntCount - The amount of leading zeros
   * @param {integer} wantedFloatCount - The amount of trailing zeros
   * @param {boolean} dutchify - Swap seperators: "." <--> ","
   *
   * @return {string} - The formatted number, formatted as string
   */
  this.formatNumber = function (x, wantedIntCount, wantedFloatCount, dutchify) {

    var i,
        splitted = x.toString().split("."),
        prefix = splitted[0],
        suffix = splitted[1] || "";

    while (prefix.length < wantedIntCount) {
      prefix = "0" + prefix;
    }

    while (suffix.length < wantedFloatCount) {
      suffix += "0";
    }

    if (dutchify) {
      prefix.replace(",", ".");
      suffix.replace(",", ".");
      return prefix + "," + suffix;
    }
    return prefix + "." + suffix;
  };

  /**
   * Set timeline to moving and back after digest loop to trigger watches
   * that do something after the timeline moved.
   *
   * @param {object} state - State object.
   */
  this.announceMovedTimeline = function (state) {
    state.temporal.timelineMoving = true;

    // Set timeline moving to false after digest loop
    $timeout(
      function () {
        state.temporal.timelineMoving = false;
      },
      0, // no delay, fire when digest ends
      true // trigger new digest loop
    );
  };

  /**
   * @function _formatDate
   * @summmary Format epoch in ms to human readable string.
   * @description Format epoch in ms to human readable string.
   *
   * @param {integer} epoch - time in ms since 1970.
   * @returns {string} formatted date.
   */
  this._formatDate = function (epoch) {
    var d = new Date(parseInt(epoch, 10));
    return [
      [d.getDate(), d.getMonth() + 1,
       d.getFullYear()].join('-'),
      [d.getHours() || "00",
       d.getMinutes() || "00",
       d.getSeconds() || "00"].join(':')
    ];
  };

  /**
   * Format CSV (exporting rain data for a point in space/interval in
   * time) in a way that makes it comprehensible for les autres.
   *
   * @param {object []} data - list with data objects to parse.
   * @param {object} latLng - latlng object with location of data.
   * @returns list of formatted data objects.
   */
  this.formatCSVColumns = function (data, latLng) {
    var i,
        formattedDateTime,
        formattedData = [];

    for (i = 0; i < data.length; i++) {

      formattedDateTime = this._formatDate(data[i]['timestamp'] || data[i][0]);

      var formattedDatum = [
        this.formatNumber(latLng.lat, 0, 0, true),
        this.formatNumber(latLng.lng, 0, 0, true),
        formattedDateTime[0],
        formattedDateTime[1]
      ];

      if (data[i].max !== undefined && data[i].min !== undefined) {
        formattedDatum.push(
          this.formatNumber(
            Math.round(100 * data[i]['min']) / 100 || 0,
            0,
            2,
            true // Dutchify seperators
          )
        );
        formattedDatum.push(
          this.formatNumber(
            Math.round(100 * data[i]['max']) / 100 || 0,
            0,
            2,
            true
          )
        );
      } else {
        formattedDatum.push(
          this.formatNumber(
            Math.round(100 * data[i][1]) / 100 || 0,
            0,
            2,
            true // Dutchify seperators
          )
        );
      }

      formattedData.push(formattedDatum);

    }

    return formattedData;
  };

}]);

/**
 * Service to handle utf grid requests.
 */
angular.module('lizard-nxt')
  .service('UtfGridService', ['$q', '$rootScope', 'UtilService',

  function ($q, $rootScope, UtilService) {


    // UtfGridService has a local cache of the last query so the dataservice can
    // get an answer of the utfgrid even if there is no map.
    // NOTE: we use this as a 'poor man's state' of the 'last selected
    // object'. We might want to include the 'last selected object' in the
    // actual state so we can refer to it directly.
    var _cache = {};

    /**
     * @function buildCacheKey
     * @summary Calculate cache key for layer and options.
     *
     * @param {object} layer    nxt layer to use as key.
     * @param {object} options  options to use as key.
     * @returns {string} key
     */
    var buildCacheKey = function (layer, options) {

      var geomString;

      try {
        // bounds have a bbox string method
        geomString = options.geom.toBBoxString();
      }
      catch (e) {
        // latlngs have a tostring method
        geomString = options.geom.toString();
      }

      return  layer.slug + geomString;
    };

    /**
     * @function setToLocalCache
     * @summary Set data to local cache.
     *
     * @param {string} key  key to store data at.
     * @param {object} data data to cache.
     */
    var setToLocalCache = function (key, data) {
      _cache = {};  // reset cache because we only need to remember the last
                    // query.
      _cache[key] = data;
    };

    /**
     * @function getFromLocalCache
     * @summary Gets data for `key` from local cache. Returns undefined if `key`
     * doesn't exist.
     *
     * @return {object} Cached data or undefined if key doesn't exist.
     */
    var getFromLocalCache = function (key) {
      return _cache[key];
    };

    var getData = function (callee, nonLeafLayer, options) {

      var leafLayer = nonLeafLayer && nonLeafLayer._leafletLayer,
          geomType = UtilService.getGeomType(options.geom),
          deferred = $q.defer(),
          e = { latlng: options.geom },
          response,
          cacheKey = buildCacheKey(nonLeafLayer, options);

      if (
        options.geom === undefined
        || geomType === "LINE"
        || geomType === "REGION") {
        deferred.reject();
        return deferred.promise;
      }

      var cached = getFromLocalCache(cacheKey);
      if (cached) {
        response = cached;
        deferred.resolve(response.data);
      } else {
        response = _getResponseForGeomType(
          leafLayer, geomType, e, options.geom);

        if (!window.loaded
          || leafLayer.isLoading
          || !leafLayer._map
          || !leafLayer._map.hasLayer(leafLayer)
        ) {
          _getDataFromUTFAsynchronous(
            nonLeafLayer, e, deferred, geomType, options);
        } else {
          setToLocalCache(cacheKey, response);
          deferred.resolve(response.data);
        }
      }

      return deferred.promise;
    };

    var _getDataFromUTFAsynchronous = function (nonLeafLayer,
                                                e,
                                                deferred,
                                                geomType,
                                                options) {
      var response, leafLayer = nonLeafLayer._leafletLayer,
          cacheKey = buildCacheKey(nonLeafLayer, options);

      leafLayer.on('load', function () {
        response = _getResponseForGeomType(
          leafLayer, geomType, e, options.geom);
        if ($rootScope.$$phase) {
          setToLocalCache(cacheKey, response);
          deferred.resolve(response.data);
        } else {
          $rootScope.$apply(function () {
            setToLocalCache(cacheKey, response);
            deferred.resolve(response.data);
          });
        }
      });
    };

    var _getResponseForGeomType = function (leafLayer, geomType, e, geomOpts) {
      switch (geomType) {
      case 'POINT':
        return leafLayer._objectForEvent(e);
      case "LINE":
        return undefined;
      case "AREA":
        return _groupStructuresByEntityName(
          leafLayer.getUniqueStructuresForExtent(),
          geomOpts
        );
      default:
        throw new Error(
          "UtfGridService._getResponseForGeomType called with invalid " +
          " arg 'geomType', which happened to be:",
          geomType
        );
      }
    };

    var _isWithinExtent = function (structureGeom, leafletBounds) {

      switch (structureGeom.type) {
      case "Point":
        return leafletBounds.contains(L.latLng(
          structureGeom.coordinates[1],
          structureGeom.coordinates[0]
        ));

      case "LineString":

        // For now (15-01-2015), don't take into account structures with a geom
        // type other than POINT. Since this will probably be reverted some time
        // in the foreseeable future, we simply comment the relevant code and
        // return false.

        // var lineStart = L.latLng(
        //       structureGeom.coordinates[0][1],
        //       structureGeom.coordinates[0][0]
        //     ),
        //     lineEnd = L.latLng(
        //       structureGeom.coordinates[1][1],
        //       structureGeom.coordinates[1][0]
        //     );

        // TODO: Fix detection of lines that overlap the extent, but that do
        // not start nor end within the extent. It negligable for now.
        //return leafletBounds.contains(lineStart) || leafletBounds.contains(lineEnd);

        return false;

      default:
        throw new Error("Did not find valid geom type:", structureGeom.type);
      }
    };

    var _groupStructuresByEntityName = function (structures, geomOpts) {

      var uniqueId,
          currentEntityName,
          structure,
          structureGeom,
          leafletBounds = L.latLngBounds(
            geomOpts._southWest, geomOpts._northEast),
          groupedStructures = { data: {} };

      for (uniqueId in structures.data) {

        structure = structures.data[uniqueId];
        structureGeom = JSON.parse(structure.geom);

        if (!_isWithinExtent(structureGeom, leafletBounds)) {
          continue;
        }

        currentEntityName = structure.entity_name;
        groupedStructures.data[currentEntityName]
          = groupedStructures.data[currentEntityName] || {};
        groupedStructures.data[currentEntityName][uniqueId] = structure;
      }
      return groupedStructures;
    };

    return { getData: getData };
  }
]);

/**
 * Service to handle raster requests.
 */
angular.module('lizard-nxt')
  .service("RasterService", ["Restangular",
                             "UtilService",
                             "CabinetService",
                             "LeafletService",
                             "$q",
  function (Restangular, UtilService, CabinetService, LeafletService, $q) {

  var intensityData,
      cancelers = {};

  var getData = function (callee, layer, options) {

    // TODO: get this from somewhere
    var GRAPH_WIDTH = UtilService.getCurrentWidth();

    var srs = 'EPSG:4326',
        agg = options.agg || '',
        startString,
        endString,
        aggWindow;

    if (options.start && options.end) {
      startString = new Date(options.start).toISOString().split('.')[0];
      endString = new Date(options.end).toISOString().split('.')[0];
    }

    aggWindow = options.aggWindow || UtilService.getAggWindow(options.start,
      options.end, GRAPH_WIDTH);

    var canceler;
    // getData can have own deferrer to prevent conflicts
    if (options.deferrer) {
      var deferSlug = options.deferrer.origin;
      canceler = options.deferrer.deferred;
      if (cancelers[options.deferrer.origin]) {
        cancelers[options.deferrer.origin].resolve();
      }
      cancelers[options.deferrer.origin] = canceler;
    }
    // if it doesn't have a deferrer in the options
    // use the layer slug..
    else {
      if (cancelers[callee + '_' + layer.slug]) {
        cancelers[callee + '_' + layer.slug].resolve();
      }

      canceler = cancelers[callee + '_' + layer.slug] = $q.defer();
    }

    var requestOptions = {
      raster_names: layer.slug,
      srs: srs,
      start: startString,
      stop: endString,
      agg: agg,
      styles: options.styles,
      window: aggWindow
    };

    if (options.geom_id) {
      requestOptions.geom_id = options.geom_id;
      requestOptions.boundary_type = options.boundary_type;
    } else {
      requestOptions.geom = UtilService.geomToWkt(options.geom);
    }

    if (options.truncate === true) {
      requestOptions.truncate = options.truncate;
    }

    return CabinetService.raster(canceler).get(requestOptions);
  };

  /**
   * Build the bounding box given an imageBounds
   */
  var _buildBbox = function (imgBounds) {
    return [imgBounds[0].x, imgBounds[0].y].toString() +
      ',' + [imgBounds[1].x, imgBounds[1].y].toString();
  };

  /**
   * Returns wms url as used by the non-tiled layer for animation.
   *
   * @param  {object} wmsLayer   nxt map layer instance with options and slug.
   * @param  {object} map        current leaflet map
   * @param  {string} store         name of store rain-5min|rain-hour etc.
   * @param  {boolean} singleTile when single it returns a proper tilesize
   *                              otherwise just 256x256px.
   * @return {string}            url
   */
  var buildURLforWMS = function (wmsLayer, map, store, singleTile, options) {
    var options = options || {},
        layerName = store || wmsLayer.slug,
        bounds = options.bounds || map.getBounds(),
        DEFAULT_TILE_SIZE = 256; // in px

    var imgBounds = [
      LeafletService.CRS.EPSG3857.project(bounds.getSouthWest()),
      LeafletService.CRS.EPSG3857.project(bounds.getNorthEast()),
    ],

    wmsOpts = wmsLayer.options,

    result = wmsLayer.url
      + '?SERVICE=WMS&REQUEST=GetMap&VERSION=1.1.1&FORMAT=image%2Fpng'
      + '&SRS=EPSG%3A3857&LAYERS=' + layerName
      + '&BBOX=' + _buildBbox(imgBounds);

    if (singleTile) {
      var size = options.size || map.getPixelBounds().getSize();
      wmsOpts.height = Math.round(size.y / size.x * DEFAULT_TILE_SIZE);
      wmsOpts.width = Math.round(size.x / size.y  * DEFAULT_TILE_SIZE);
    } else {
      // Serve square tiles
      wmsOpts.height = DEFAULT_TILE_SIZE;
      wmsOpts.width = DEFAULT_TILE_SIZE;
    }


    angular.forEach(wmsOpts, function (v, k) {
      result += UtilService.buildString('&', k.toUpperCase(), "=", v);
    });

    // key TIME needs to come last, so we can subsequently append it's value
    // for every frame in the animation:
    result += '&TIME=';

    return result;
  };

  return {
    buildURLforWMS: buildURLforWMS,
    getData: getData,
  };

}]);

/**
 * Service to handle getFeatureInfo requests for wms layers.
 */
angular.module('lizard-nxt')
.service("WmsGetFeatureInfoService", [

  "LeafletService",
  "CabinetService",
  "$q",
  'State',

  function (LeafletService, CabinetService, $q, State) {

  /**
   * Gets data from wmsGetFeatureInfo resource of cabinetService.
   *
   * It takes the private _map leaflet map from the private _leafletLayer to
   * provide the wms server with a clue of what the user clicked on. It is a
   * nasty technique that will bite us when we ask for a featureInfo of a latLng
   * without having a map. This is the way wms works. It works if the layer has
   * a _leafletLayer._map otherwise it rejects the promise.
   *
   * @param  {string}   callee  optional string indicating the origin of the
   *                            call.
   * @param  {NxtLayer} layer   nxt layer.
   * @param  {object}   options options that contain geom.
   * @return {promise}          promise that resolves with wms response object.
   *                            Or promise that gets rejected when geometry is
   *                            not a leaflet LatLng or undefined.
   *
   */
  var getData = function (callee, layer, options) {

    if (options.geom === undefined
      || !(options.geom instanceof LeafletService.LatLng)
      || !(layer._leafletLayer)
      || !(layer._leafletLayer._map)) {
      var defer = $q.defer();
      defer.reject();
      return defer.promise;
    }

    // NOTE: its ugly we know. See description above.
    var map = layer._leafletLayer._map;

    var size = map.getSize(),
        bbox = map.getBounds().toBBoxString(),
        point = map.latLngToLayerPoint(options.geom);

    var params = {
      SERVICE: 'WMS',
      VERSION: '1.1.1',
      REQUEST: 'GetFeatureInfo',
      INFO_FORMAT: 'application/json',
      LAYERS: layer.slug,
      QUERY_LAYERS: layer.slug,
      STYLES: '', // required.
      SRS: "EPSG:4326",
      BBOX: bbox,
      WIDTH: size.x,
      HEIGHT: size.y,
      X: point.x,
      Y: point.y
    };

    var url = layer.url + '/?';
    for (var key in params) {
        if (url != "") {
            url += "&";
        }
        url += key + "=" + params[key];
    }

    return CabinetService.wmsGetFeatureInfo.get({url:url});
  };

  return {
    getData: getData,
  };

}]);


'use strict';

/**
 * @ngdoc service
 * @class VectorService
 * @memberof app
 * @name VectorService
 * @summary Receives and returns vector data, as a service (or VDaaS).
 * @description VectorService is responsible for retreiving, storing
 * and exposing vector typed data.
 *
 */

angular.module('lizard-nxt')
  .service('VectorService', ['$q',
                             '$rootScope',
                             'LeafletService',
                             'UtilService',
                             'CabinetService',
  function ($q, $rootScope, LeafletService, UtilService, CabinetService) {


    /**
     * Returns true if feature has the type and id provided by the objectFilter.
     * @param  {object} objectFilter object with type and id
     * @param  {object} feature      feature to check for type and id of
     *                               properties.object.
     * @return {boolean}              [description]
     */
    var checkRelatedToObject = function (objectFilter, feature) {
      return feature.properties.object
        && feature.properties.object.type === objectFilter.type
        && feature.properties.object.id === objectFilter.id;
    };

    /**
     * @function
     * @description filters geojson array on spatial bounds.
     * @param  {L.LatLngBounds} spatial
     * @param  {featureArray}   sourceArray
     * @return {filteredSet}    filtered set of features.
     */
    var filterSpatial = function (sourceArray, spatial, objectFilter) {
      var filteredSet = [];
      var query = spatial instanceof LeafletService.LatLngBounds ? 'contains' : 'equals';
      sourceArray.forEach(function (feature) {
        var withinBounds,
            partOfObject;

        if (feature.geometry.type === "Point") {
          var latLng = new LeafletService.LatLng(
            feature.geometry.coordinates[1],
            feature.geometry.coordinates[0]
            );
          withinBounds = spatial[query](latLng);
        }

        if (objectFilter) {
          partOfObject = checkRelatedToObject(objectFilter, feature);
        }

        if (withinBounds || partOfObject) {
          filteredSet.push(feature);
        }

      });
      return filteredSet;
    };

    /**
     * @description - Checks whether a single feature must be drawn given
     *                a certain timeState.
     */
    var isInTempExtent = function (feature, temporal) {
      var eventStartBeforeTLStart = false,
          eventStartAfterTLStart = false,
          eventEndBeforeTLStart = false,
          eventEndAfterTLStart = false,
          eventEndBeforeTLEnd = false;

      if (feature.properties) { feature = feature.properties; }

      if (temporal.start) {
        eventStartBeforeTLStart
          = feature.timestamp_start < temporal.start;
        eventStartAfterTLStart
          = !eventStartBeforeTLStart;
        eventEndBeforeTLStart
          = feature.timestamp_end < temporal.start;
        eventEndAfterTLStart
          = !eventEndBeforeTLStart;
      }

      if (temporal.end) {
        eventEndBeforeTLEnd
          = feature.timestamp_end < temporal.end;
      }

      var result;
      if (eventStartBeforeTLStart
          && eventEndAfterTLStart) { result = true; }
      else if (
                (temporal.start === undefined || eventStartAfterTLStart)
                && (temporal.end === undefined || eventEndBeforeTLEnd)
              )
              { result = true; }
      else {
        result = false;
      }

      return result;
    };

    /**
     * @function
     * @description filters geojson array on temporal bounds.
     * @param  {object}      start end object
     * @param  {feature[]}   sourceArray
     * @return {filteredSet} filtered set of features.
     */
    var filterTemporal = function (sourceArray, temporal) {
      return sourceArray.filter(function (feature) {
        return isInTempExtent(feature, temporal);
      });
    };

    /**
     * @description filters data on time, spatial extent and relation to object.
     * @param  {L.LatLngBounds} spatial  Leaflet Bounds object
     * @param  {object}         temporal object with start and end in epoch
     *                          timestamp
     * @param {object}          objectFilter object with type and id of object.
     * @return {filteredSet}    Array with points within extent.
     */
    var filterSet = function (filteredSet, spatial, objectFilter, temporal) {
      if (!spatial && !temporal && !objectFilter) { return filteredSet; }

      // First filter temporal.
      if (temporal.hasOwnProperty('start') || temporal.hasOwnProperty('end')) {
        filteredSet = filterTemporal(filteredSet, temporal);
      } else if (temporal) {
        throw new Error(temporal + "is an invalid time to query VectorService");
      }

      // Second filter spatially but leave features in the set when related to
      // object.
      if (spatial instanceof LeafletService.LatLngBounds
        || spatial instanceof LeafletService.LatLng) {
        filteredSet = filterSpatial(filteredSet, spatial, objectFilter);
      } else if (spatial instanceof Array
        && spatial[0] instanceof LeafletService.LatLng) {
        // TODO: implement line intersect with vector data
        filteredSet = [];
      } else if (spatial) {
        throw new Error(
          spatial + "is an invalid geometry to query VectorService");
      }

      return filteredSet;
    };

    var vectorLayers = {};

    /**
     * @memberof app.VectorService
     * @function
     * @description gets data from backend
     * @param  {string} callee string of the callee to keep requests
     *                         seperate NOTE: not implemented in this service.
     * @param  {layer} layer as defined by layer-service
     * @param  {object} geomortime  geometry or time that it needs to get
     *                  (e.g. bboxs)
     * @param  {object} time  start, stop object
     * @return {promise}
     */
    var getData = function (callee, nonLeafLayer, options) {
      var deferred = $q.defer(),
          layerSlug, layer;

      // leaflet knows nothing, so sends slug and leaflayer
      if (typeof nonLeafLayer === 'string') {
        layerSlug = nonLeafLayer;
      } else {
        layerSlug = nonLeafLayer.slug;
      }

      if (!vectorLayers[layerSlug] || vectorLayers[layerSlug].isLoading) {
        getDataAsync(layerSlug, layer, options, deferred);
      } else {
        var set = filterSet(vectorLayers[layerSlug].data,
        options.geom, options.object, {
          start: options.start,
          end: options.end
        });

        deferred.resolve(set);
      }

      return deferred.promise;
    };

    /**
     * @description Triggers resolve callback on loaded data.
     * @param {layer}
     * @param {options}
     * @param {promise}
     */
    var getDataAsync = function (layerSlug, layer, options, deferred) {
      if (!vectorLayers[layerSlug]) {

        vectorLayers[layerSlug] = {
          data: [],
          isLoading: true,
          promise: {}
        };

        vectorLayers[layerSlug].promise = CabinetService.events
        .get({'event_series__layer__slug': layerSlug}).then(function (response) {
          vectorLayers[layerSlug].isLoading = false;
          setData(layerSlug, response.results, 1);
        });

      }

      vectorLayers[layerSlug].promise.then(function () {
        deferred.resolve(filterSet(vectorLayers[layerSlug].data,
          options.geom, options.objectFilter, {
            start: options.start,
            end: options.end
          }
        ));
      });

    };

    /**
     * @description redefines data if zoom level changed
     */
    var replaceData = function (layerSlug, data, zoom) {
      vectorLayers[layerSlug] = {
          data: [],
          zoom: zoom
        };
      vectorLayers[layerSlug].data = vectorLayers[layerSlug].data.concat(data);
    };

    /**
     * @description gets unique values and tosses duplicates
     * part of PostGis.js (ಠ_ಠ)
     */
    var getUnion = function (arr1, arr2) {
      return UtilService.union(arr1, arr2);
    };

    /**
     * @description appends data if zoom level hasn't changed
     *
     */
    var setData = function (layerSlug, data, zoom) {
      if (vectorLayers.hasOwnProperty(layerSlug)
        && vectorLayers[layerSlug].zoom === zoom) {
        vectorLayers[layerSlug].data = getUnion(
          vectorLayers[layerSlug].data, data);
      } else {
        replaceData.apply(this, arguments);
      }
    };

    return {
      getData: getData,
      setData: setData,
      isInTempExtent: isInTempExtent
    };
  }
]);

'use strict';

/**
 * @name NxtD3
 * @class angular.module('lizard-nxt')
  .NxtD3
 * @memberOf app
 *
 * @summary Service to create and update common d3 elements.
 *
 * @description Inject "NxtD3Service" and either extend this service
 * by calling: Child.prototype = Object.create(NxtD3Service.prototype) as
 * in the higher level graph and timeline services or use these methods
 * directly by calling NxtD3Service.<method>(<args>).
 */
angular.module('lizard-nxt')
  .factory("NxtD3", ["$rootScope", "$location", function ($rootScope, $location) {

  var createCanvas, createElementForAxis, resizeCanvas, createPathGenerator;

  /**
   * @constructor
   * @memberOf angular.module('lizard-nxt')
  .NxtD3
   *
   * @param {object} element    svg element for the graph.
   * @param {object} dimensions object containing, width, height and
   *                            an object containing top,
   *                            bottom, left and right padding.
   *                            All values in px.
   * @param {int} xDomainStart  unix-time; start of wanted domain
   * @param {int} xDomainEnd    unix-time; end of wanted domain
   */
  function NxtD3(element, dimensions, xDomainStart, xDomainEnd) {
    this.dimensions = angular.copy(dimensions);
    this._xDomainStart = xDomainStart;
    this._xDomainEnd = xDomainEnd;
    this._svg = createCanvas(element, this.dimensions);
  }

  NxtD3.prototype = {

    constructor: NxtD3,

    /**
     * @attribute
     * @memberOf angular.module('lizard-nxt')
     * @description        The duration of transitions in ms. Use(d)
     *                     throughout the graphs and timeline.
     */
    transTime: 120,

    /**
     * @attribute
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     * @description        Locales. Used in the axes. Currently only Dutch
     *                     is supported (and d3's default english/US en_US).
     */
    _localeFormatter: {
      'nl_NL': d3.locale({
        "decimal": ",",
        "thousands": ".",
        "grouping": [3],
        "currency": ["€", ""],
        "dateTime": "%a %b %e %X %Y",
        "date": "%d-%m-%Y",
        "time": "%H:%M:%S",
        "periods": ["AM", "PM"],
        "days": ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"],
        "shortDays": ["zo", "ma", "di", "wo", "do", "vr", "za"],
        "months": ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"],
        "shortMonths": ["jan", "feb", "mar", "apr", "mei", "jun", "jul", "aug", "sep", "okt", "nov", "dec"]
      })
    },


    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     *
     * @description Creates or modifies a clippath and features-group
     *              to the svg. Feature-group is to draw the features
     *              in, clippath is to prevent drawing outside this
     *              area.
     * @return {object} svg with clip-area and feature-group
     */
    _createDrawingArea: function () {
      var width = this._getWidth(this.dimensions),
      height = this._getHeight(this.dimensions);
      // Add clippath to limit the drawing area to inside the graph
      // See: http://bost.ocks.org/mike/path/
      //
      // NOTE: we append the height to the clippath to prevent assocating a
      // clippath with the wrong rect element. What used to happen was: the
      // elevation graph gets clipped by the clippath of the horizontalstack.
      var clip = this._svg.select('g').select("defs");
      if (!clip[0][0]) {
        clip = this._svg.select('g').append('defs').append("svg:clipPath")
        .attr('class', 'clip-path');
        clip.append("svg:rect");

      }
      clip = this._svg.select('g').select("defs").select('.clip-path')
      .attr("id", "clip" + height)
      .select('rect')
        .attr("id", "clip-rect")
        .attr("x", "0")
        // give some space to draw full stroke-width.
        .attr("y", 0 - 2)
        .attr("width", width)
        .attr("height", height + 2);
      // Put the data in this group
      var g = this._svg.select('g').select('g');
      if (!g[0][0]) {
        g = this._svg.select('g').append('g');
      }

      // Since html5 url is used we need to refer to the absolute url of the
      // clip rect
      g.attr("clip-path", "url(" + $location.absUrl() + "#clip" + height + ")")
        .attr('id', 'feature-group');
      // This url changes constantly so we set a watch.
      this._addLocationWatch(this);
      return this._svg;
    },

    /**
     * Set location watch to update absolute reference to clip-path.
     * @param {NxtD3} instance of NxtD3
     */
    _addLocationWatch: function (instance) {
      instance._locationWatch = $rootScope.$on('$locationChangeSuccess', function (e, newUrl, optOldUrl) {
        if (newUrl === optOldUrl) { return; }
        var height = instance._getHeight(instance.dimensions);
        instance._svg.select('#feature-group')
        .attr("clip-path", "url(" + newUrl + "#clip" + height + ")");
      });
    },

    /**
     * Removes listener to update absolute reference to clip-path.
     */
    destroy: function () {
      if (this._locationWatch) {
        this._locationWatch();
      }
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     *
     * @param {object} svg        d3 selection of an svg.
     * @param {object} dimensions object containing, width, height and
     *                            an object containing top,
     *                            bottom, left and right padding.
     *                            All values in px.
     * @param {array} data        Array of data objects.
     * @param {int-or-string} key key to the values for the scale and
     *                            axis in the data element
     * @param {object} options    options object that will be passed
     *                            to the d3 scale and axis.
     * @param {boolean} y         Determines whether to return a y scale.
     * @description Computes and returns maxmin, scale and axis.
     * @return {object} containing maxmin, d3 scale and d3 axis.
     */
    _createD3Objects: function (data, key, options, y) {

      // Computes and returns maxmin scale and axis
      var width = this._getWidth(this.dimensions),
          height = this._getHeight(this.dimensions),
          d3Objects = {},
          // y range runs from height till zero, x domain from 0 to width.
          range;

      if (y) {
        range = { max: 0, min: height };
        d3Objects.maxMin = this._maxMin(data, key);
      } else {
        range = { min: 0, max: width };
        d3Objects.maxMin = (this._xDomainStart && this._xDomainEnd)
          ? { min: this._xDomainStart, max: this._xDomainEnd }
          : this._maxMin(data, key);
      }
      d3Objects.scale = this._makeScale(d3Objects.maxMin, range, options);
      d3Objects.axis = this._makeAxis(d3Objects.scale, options);
      return d3Objects;
    },


    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     *
     * @param {object} dimensions object containing, width, height and
     *                            an object containing top,
     *                            bottom, left and right padding.
     *                            All values in px.
     * @description Resizes the canvas and the updates the drawing
     *              area. Does not resize the elements drawn on the
     *              canvas.
     */
    resize: function (dimensions) {
      this.dimensions = angular.extend(this.dimensions, dimensions);
      this._svg = resizeCanvas(this._svg, this.dimensions);
      this._svg = this._createDrawingArea(this._svg, this.dimensions);
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt').NxtD3
     *
     * @param {array} data        Array of data objects.
     * @param {int-or-string} key to the value in the array or object.
     * @description returns the maximum and minimum
     * @return {object} containing the max and min
     */
    _maxMin: function (data, key) {
      if (data.length < 0) {
        return {max: null, min: null};
      }

      var min, max;

      if (key.hasOwnProperty('y0') && key.hasOwnProperty('y1')) {
        var minComparator = function (d) { return d[key.y0]; };
        min = d3.min(data, minComparator);

        var maxComparator = function (d) { return d[key.y1]; };
        max = d3.max(data, maxComparator);
      }

      else {
        // min max of d3 filters nulls but not if you cast null into 0. Only cast
        // strings, and array like [0, [3]].
        var comparator = function (d) {
          return typeof(d[key]) === 'string' || d[key] instanceof Array
            ? Number(d[key])
            : d[key];
        };
        max = d3.max(data, comparator);
        min = d3.min(data, comparator);
      }

      return {
        max: max,
        min: min
      };
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     *
     * @param {object} minMax object containing the max and min
     * @param {object} range object contaning from where to where
     *                       the scale runs.
     * @param {object} options object what kind of scale to return
     * @description returns a d3 scale
     * @return {object} d3 scale
     */
    _makeScale: function (minMax, range, options) {
      // Instantiate a d3 scale based on min max and
      // width and height of plot
      var scale;
      if (options.scale === 'time') {
        scale = d3.time.scale()
          .domain([new Date(minMax.min), new Date(minMax.max)])
          .range([range.min, range.max]);
      } else if (options.scale === "ordinal") {
        scale = d3.scale.ordinal()
          .domain(function (d) {
            return d3.set(d.properties.event_sub_type).values();
          })
          .range(options.colors[8]);
      } else if (options.scale === "linear") {
        scale = d3.scale.linear()
          .domain([minMax.min, minMax.max])
          .range([range.min, range.max]);
      } else {
        throw new Error(options.scale + ' is not a valid d3 scale');
      }
      return scale;
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     *
     * @param {object} scale d3 scale
     * @param {object} options object containing the orientation
     *                         (bottom/left/right/top) and optionally
     *                         an overwrite for the default ticks (5).
     * @description returns a d3 axis
     * @return {object} d3 axis
     */
    _makeAxis: function (scale, options) {
      // Make an axis for d3 based on a scale
      var decimalCount,
          axis = d3.svg.axis()
            .scale(scale)
            .orient(options.orientation);
      if (options.ticks) {
        axis.ticks(options.ticks);
      } else {
        axis.ticks(5);
      }
      if (scale.domain()[0] instanceof Date) {
        var tickFormat = this._localeFormatter.nl_NL.timeFormat.multi([
          ["%H:%M", function (d) { return d.getMinutes(); }],
          ["%H:%M", function (d) { return d.getHours(); }],
          ["%a %d", function (d) { return d.getDay() && d.getDate() !== 1; }],
          ["%b %d", function (d) { return d.getDate() !== 1; }],
          ["%B", function (d) { return d.getMonth(); }],
          ["%Y", function () { return true; }]
        ]);
        axis.tickFormat(tickFormat);
      } else {
        if (options.tickFormat) {
          axis.tickFormat(options.tickFormat);
        } else {
          var domainDiff = scale.domain()[1] - scale.domain()[0];
          if (domainDiff < 0.5) {
            axis.tickFormat(function (d) {
              return d3.format(".2f")(d);
            });
          } else if (domainDiff < 5.0) {
            axis.tickFormat(function (d) {
              return d3.format(".1f")(d);
            });
          } else {
            axis.tickFormat(
              this._localeFormatter.nl_NL.numberFormat()
            );
          }
        }
      }
      return axis;
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     *
     * @param {object} svg  d3 selection of svg
     * @param {object} axis d3 axis
     * @param {object} dimensions object containing dimensions.
     * @param {boolean} y to draw y-axis or not (x-axis).
     * @param {int} duration if specified, transitions the drawing.
     * @description Creates axis group if necessary and draws
     *              axis.
     */
    _drawAxes: function (svg, axis, dimensions, y, duration) {
      if (typeof(y) !== 'boolean') { throw new Error('Invalid input: y is not a boolean'); }
      var id = y === true ? 'yaxis': 'xaxis';
      var axisEl = svg.select('g').select('#' + id);
      if (!axisEl[0][0]) {
        axisEl = createElementForAxis(svg, id, dimensions, y);
      }
      if (duration) {
        axisEl
          .transition()
          .duration(duration)
          .call(axis);
      } else {
        axisEl
          .call(axis);
      }
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     *
     * @param {object} dimensions object containing dimensions
     * @description Deducts the left and right padding to get
     *              the actual width of the drawing area
     * @return {int} width
     */
    _getWidth: function (dimensions) {
      return dimensions.width -
        dimensions.padding.left -
        dimensions.padding.right;
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     *
     * @param {object} dimensions object containing dimensions
     * @description Deducts the bottom padding to get
     *              the actual height of the drawing area
     * @return {int} height
     */
    _getHeight: function (dimensions) {
      return dimensions.height -
        dimensions.padding.bottom;
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt').NxtD3
     *
     * @param {object} xy object containing y.scales and x.scale.
     * @param {object} keys object containing y.key and x.key.
     * @description returns a line definition for the provided scales.
     * @return {object} d3 path generator for line.
     */
    _createLine: function (xy, keys) {
      return createPathGenerator(d3.svg.line)
        .y(function (d) { return xy.y.scale(d[keys.y]); })
        .x(function (d) { return xy.x.scale(d[keys.x]); })
        // interrupt the line when no data
        .defined(function (d) { return !isNaN(parseFloat(d[keys.y])); });
    },


    /**
     * @function
     * @memberOf angular.module('lizard-nxt').NxtD3
     *s
     * @param {object} xy object containing y.scales and x.scale.
     * @param {object} keys object containing y.key and x.key.
     * @description returns an area definition for the provided scales.
     * @return {object} d3 path generator for area.
     */
    _createArea: function (xy, keys) {
      return createPathGenerator(d3.svg.area)
        .x(function(d) { return Math.round(xy.x.scale(d[keys.x]), 10); })
        .y0(function(d) { return Math.round(xy.y.scale(d[keys.y.y0]), 10); })
        .y1(function(d) { return Math.round(xy.y.scale(d[keys.y.y1]), 10); })
        // interrupt the line when no data
        .defined(function (d) {
          var y0 = !isNaN(parseFloat(d[keys.y.y0]));
          var y1 = !isNaN(parseFloat(d[keys.y.y1]));
          return y0 && y1;
        });
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .NxtD3
     *
     * @param {int} now timestamp from epoch in ms
     * @param {object} scale d3 scale for time
     * @description draws a line.
     */
    _drawNow: function (now, scale) {
      var height = this._getHeight(this.dimensions);
      var x = scale(now);
      var nowIndicator = this._svg.select('g').select('#feature-group').select('.now-indicator');

      if (!nowIndicator[0][0]) {
        nowIndicator = this._svg.select('g').select('#feature-group').append('line')
          .attr('class', 'now-indicator')
          .style("stroke", "#c0392b") // pommegranate
          .style("stroke-width", 2)
          // create without transition
          .attr('x1', x)
          .attr('x2', x)
          .attr('y1', height)
          .attr('y2', 0);
      }
      nowIndicator.transition().duration(2 * this.transTime)
        .attr('x1', x)
        .attr('x2', x)
        .attr('y1', height)
        .attr('y2', 0);
    }
  };


  /**
   * Creates a svg canvas for drawing,
   *
   * @param  {object} svg element to create canvas.
   * @param  {object} dimensions  object containing, width, height and an
   *                              object containing top,
   *                              bottom, left and right padding. All
   *                              values in px.
   * @return {object} svg         svg.
   */
  createCanvas = function (element, dimensions) {

    var width = NxtD3.prototype._getWidth(dimensions),
        height = NxtD3.prototype._getHeight(dimensions),
        svg = d3.select(element);

    // Create the svg as big as the dimensions
    svg.attr('width', dimensions.width)
      .attr('height', dimensions.height)
      // Create a drawing group that is shifted left side padding to the right
      .append("g")
        .attr("transform", "translate(" + dimensions.padding.left + ", " + dimensions.padding.top + ")")
        // Add rect element to attach listeners
        .append('rect')
          .attr('id', 'listeners')
          .attr('width', width)
          .attr('height', height);
    return svg;
  };

  resizeCanvas = function (svg, dimensions) {
    var width = NxtD3.prototype._getWidth(dimensions),
    height = NxtD3.prototype._getHeight(dimensions);
    // Create the svg as big as the dimensions
    svg.attr('width', dimensions.width)
      .attr('height', dimensions.height)
      // Create a drawing group that is shifted left side padding to the right
      .select("g")
        .attr("transform", "translate(" + dimensions.padding.left + ", " + dimensions.padding.top + ")")
        .select('#listeners')
          .attr('width', width)
          .attr('height', height);
    return svg;
  };

  createElementForAxis = function (svg, id, dimensions, y) {
    var className = y ? 'y axis': 'x axis',
    transform = y ? 0: NxtD3.prototype._getHeight(dimensions);
    return svg.select('g').append('g')
      .attr('class', className)
      .attr('id', id)
      .attr("transform", "translate(0 ," + transform + ")");
  };

  /**
   * Returns a d3 path.
   *
   * The path used to have .interpolate('monotone') to create a smoothed
   * line through datapoints, but it makes lines messy when data is missing.
   * Currently no interpolation is used.
   *
   * @param  {object} d3Generator d3 [line|area] generator function.
   * @return {object}             d3 path generator.
   */
  createPathGenerator = function (d3Generator) {
    // Monotone line goes through all datapoints. Other options are 'basis'
    // which looks nice but can give inaccurate results, or 'cardinal' which
    // results in a line with a bigger domain/amplitute than the data.
    return d3Generator();
  };


  return NxtD3;

}]);


/**
 * Service to draw click feedback.
 */
angular.module('lizard-nxt')
  .service('ClickFeedbackService', ['$rootScope', 'LeafletService',
  function ($rootScope, LeafletService) {
    var ClickLayer = function () {

      /**
       * @description Removes clicklayer, adds a new one.
       *              Clicklayer has a default color, opacity
       *              and a way to transform points.
       * @param {object} mapState
       */
      this.emptyClickLayer = function (mapState) {
        clearInterval(this._vibration);

        if (this.clickLayer) {
          mapState.removeLeafletLayer(this.clickLayer);
        }

        this.clickLayer = LeafletService.geoJson(null, {
          style: function (feature) {
            return {
              name: 'click',
              clickable: true,
              color: '#c0392b',
              stroke: '#c0392b',
              opacity: 0.8,
              'stroke-opacity': 0.8,
              radius: getRadius(feature),
            };
          }
        });

        var self = this;
        // Explain leaflet to draw points as circlemarkers.
        this.clickLayer.options.pointToLayer = function (feature, latlng) {
          var circleMarker = L.circleMarker(latlng, {
            radius: 0,
            weight: self.strokeWidth,
            fill: false,
            zIndexOffset: 1000,
            clickable: true
          });
          self._circleMarker = circleMarker;
          return circleMarker;
        };

        // Hack to make click on the clicklayer bubble down to the map it is
        // part of.
        this.clickLayer.on('click', function (e) {
            this._map.fire('click', e);
          }
        );

        mapState.addLeafletLayer(this.clickLayer);
      };

      /**
       * Returns the svg as a d3 selection of leaflet layer.
       *
       * @param  {object} layer
       * @return {object} the svg of the leaflet object layer
       */
      this._getSelection = function (layer) {
        // Due to some leaflet obscurity you have to get the first item with an
        // unknown key.
        var _layers = layer._layers;
        var selection;
        for (var key in _layers) {
          selection = d3.select(_layers[key]._container);
          break;
        }
        return selection;
      };

      /**
       * @description add data to the clicklayer
       */
      this.drawFeature = function (geojson) {
        this.strokeWidth = 5;
        this.clickLayer.addData(geojson);
      };

      /**
       * @function drawLineElement
       * @memberof clickFeedbackService
       * @summary Draws a line between the given points.
       * @description Draws a line between `first` and `second`. If `first` or
       * `second` don't exist, return. If `dashed` is `true`, draw a dashed
       * line.
       *
       * @param  {L.LatLng} first - start of the line
       * @param  {L.LatLng} second - end of the line
       * @param  {boolean} dashed - when true draws a dashed line
       */
      this.drawLineElement = function (first, second, dashed) {

        if (first === undefined || second === undefined) {
          return;
        }

        this.strokeWidth = 2;

        var geojsonFeature = { "type": "Feature" };
        geojsonFeature.geometry = {
          "type": "LineString",
          "coordinates": [[first.lng, first.lat], [second.lng, second.lat]]
        };
        this.clickLayer.options.style = {
          color: '#c0392b',
          weight: this.strokeWidth,
          opacity: 1,
          smoothFactor: 1
        };
        if (dashed) {
          this.clickLayer.options.style.dashArray = "5, 5";
        }
        this.clickLayer.addData(geojsonFeature);
      };

      /**
       * @description vibrates the features in the clickLayer.
       */
      this.vibrateFeatures = function () {
        var sel = this._selection = this._getSelection(this.clickLayer);
        clearInterval(this._vibration);
        var vibrate = this.vibrate;
        var self = this;
        this._vibration = setInterval(
          function () { vibrate.call(self, sel, false); }, 400);
      };

      /**
       * @describtion Vibrate the features in the clicklayer once.
       *
       * @param  {geojson} geojson if provided draws the features in
       *                           the geojson, vibrates it and removes it.
       */
      this.vibrateOnce = function (geojson) {
        var sel = this._selection = this._getSelection(this.clickLayer);
        var remove = false;
        if (geojson) {
          this.clickLayer.addData(geojson);
          sel = this._selection = this._getSelection(this.clickLayer);
          remove = true;
        }
        this.vibrate(sel, remove);
      };

      /**
       * @description add a locationMarker as a leaflet marker with
       *              a leaflet divIcon. Overwrites the pointTolayer
       *              of the clicklayer.
       * @param {object} mapState nxt mapState
       * @param {L.latLng} latLng location of marker
       */
      this.addLocationMarker = function (mapState, latLng) {
        var divIcon = L.divIcon({
          className: 'selected',
          iconAnchor: [10, 48],
          html: '<svg width=20 height=48><path d="M10,16'
            + 'c-5.523 0-10 4.477-10 10 0 10 10 22 10 22'
            + 's10-12 10-22c0-5.523-4.477-10-10-10z M10,32'
            + ' c-3.314 0-6-2.686-6-6s2.686-6 6-6 6 2.686'
            + ' 6 6-2.686 6-6 6z"></path></svg>'
        });

        this.clickLayer.options.pointToLayer = function (feature, latlng) {
          return L.marker(latlng, {
            icon: divIcon,
            clickable: true
          });
        };

      };

      /**
       * @descriptions vibretes a selection.paths by varying the stroke-width
       * @param  {d3 selection} sel selection contaning a path.
       * @param  {boolean} remove to remove or not. When true, stroke-widh
       *                          is set to 0 at the end the vibration.
       */
      this.vibrate = function (sel, remove) {
        if (sel.empty()) { return; } // bail when empty
        var width = this.strokeWidth;

        sel.selectAll("path")
          .classed("vibrator", true)
          .attr("stroke-width", function () { return width * 2; })
          .transition().duration(200)
          .attr("stroke-width", function () { return width * 3; })
          .transition().duration(200)
          .attr("stroke-width", function () { return remove ? 0 : width; });
      };

      /**
       * @description returns specific radius for water-objects coming from
       *              the utfGrid
       * @param  {geojson feature} feature containing the entity_name of the
       *                           water-object
       * @return {int}             radius
       */
      var getRadius = function (feature) {
        var entityName = feature.properties.entity_name,
            entityType = feature.properties.type;
        var radius = feature.properties.radius || 0;
        if (entityName) {
          radius = 12;
          if (entityName === "pumpstation" && entityType !== "Rioolgemaal") {
            radius =  13;
          } else if (entityType === "Rioolgemaal" || entityName === "weir") {
            radius =  11;
          } else if (entityName === "bridge" || entityName === "manhole") {
            radius =  14;
          }
        }
        return radius;
      };

    };

    var clickLayer = new ClickLayer(),
        emptyClickLayer,
        drawCircle,
        drawArrow,
        drawLine,
        drawGeometry,
        startVibration,
        vibrateOnce;


    /**
     * @description empties the clicklayer.
     */
    emptyClickLayer = function (mapState) {
      clickLayer.emptyClickLayer(mapState);
    };

    /**
     * Draws visible feedback on the map after a click.
     *
     * Removes possible click feedback layer and creates a new clickLayer
     * containing a circle.
     *
     * @param {object} latLng Leaflet object specifying the latitude
     * and longitude of a click
     */
    drawCircle = function (mapState, latlng) {
      clickLayer.emptyClickLayer(mapState);
      var geometry = {
        "type": "Point",
        "coordinates":
          [latlng.lng, latlng.lat]
      };
      clickLayer.drawFeature(geometry);
    };

    drawGeometry = function (mapState, geometry, entityName) {
      clickLayer.drawFeature(geometry);
    };

    /**
     * @function drawArrow
     * @memberof ClickFeedbackService
     * @summary Draws an arrow at latLng.
     * @description Draws arrow at specified location to indicate click. Used
     * to indicate location of rain graph. Returns void if latLng doesn't exist.
     *
     * @param {object} mapState - the mapState object, which assumes the key
     *   'here' to be defined.
     */
    drawArrow = function (mapState, latLng) {

      if (latLng === undefined) {
        return;
      }

      clickLayer.emptyClickLayer(mapState);
      var geometry = {
        "type": "Point",
        "coordinates": [latLng.lng, latLng.lat]
      };
      clickLayer.addLocationMarker(mapState, latLng);
      clickLayer.drawFeature(geometry);
    };

    drawLine = function (first, second, dashed) {
      clickLayer.drawLineElement(first, second, dashed);
    };

    startVibration = function () {
      clickLayer.vibrateFeatures();
    };

    vibrateOnce = function (geojson) {
      clickLayer.vibrateOnce(geojson);
    };

    return {
      emptyClickLayer: emptyClickLayer,
      drawArrow: drawArrow,
      drawCircle: drawCircle,
      drawGeometry: drawGeometry,
      startVibration: startVibration,
      drawLine: drawLine,
      vibrateOnce: vibrateOnce
    };
  }
]);


/**
 * @ngdoc service
 * @class EventAggregateService
 * @name EventAggregateService
 * @summary Event aggregation functions.
 * @description Functions to aggregate event series over time with d3
 */
angular.module('lizard-nxt')
  .service("EventAggregateService", ["UtilService", function (UtilService) {

    var that = this; // the mind's a terrible thing to taste 8)

    this.colorScales = {};
    this.colorMaps = {};
    this.categoryIndex = {};

    /**
     * @function getColorMap
     * @summary Helper function to get colormap from outside this module.
     * @description Helper function to get colormap from outside this module.
     *
     * @param {string} baseColor - hex color string.
     * @returns {object} colormap.
     */
    this.getColorMap = function (baseColor) {
      return that.colorMaps[baseColor];
    };

    /**
     * @function timeCatComparator
     * @summary comparator function to use for javascript array sort.
     *
     * @description Sorts arrays of object on properties timestamp and category
     */
    var timeCatComparator = d3.comparator()
      .order(d3.ascending, function (d) { return d.timestamp; })
      .order(d3.ascending, function (d) { return d.category; });

    /**
     * @function _buildColorScale
     * @summary Build color scale based on base color and number of classes.
     * @description Build color scale based on base color.
     *
     * @param {string} baseColor - hex color string.
     * @param {integer} numClasses - number of classes to build.
     * @returns {array[]} list of hex colors.
     */
    var _buildColorScale = function (baseColor, numClasses) {

      var MAX_CATS = 7;
      numClasses = Math.min(numClasses, MAX_CATS);

      var i,
          derivedColors = [],
          baseColorTriple = UtilService.hexColorToDecimalTriple(baseColor),
          shifts = _.map([0, 1, 2], function (i) {
            return Math.round((255 - baseColorTriple[i]) / numClasses);
          });

      _.each(_.range(numClasses), function (i) {
        derivedColors.push(_.map([0, 1, 2], function (j) {
          return baseColorTriple[j] + i * shifts[j];
        }));
      });

      return derivedColors.map(UtilService.decimalTripleToHexColor);
    };

    /**
     * @function _getColor
     * @summary helper function to get color for category
     *
     * @param {string} categoryName  - Name of the current category.
     * @param {string} baseColor     - Hex color.
     * @returns {string} HTML HEX color code.
     */
    var _getColor = function (

      categoryName,
      baseColor

      ) {

      // if colorscale doesn't exist yet, build a new one plus a new colormap.
      if (!that.colorScales.hasOwnProperty(baseColor)) {
        that.colorScales[baseColor] = _buildColorScale(baseColor, 7);
        that.colorMaps[baseColor] = {};
        that.categoryIndex[baseColor] = 0;
      }

      // if entry for categoryName doesn't exist yet, make one and assign a
      // color from colorscale.
      if (!that.colorMaps[baseColor].hasOwnProperty(categoryName)) {
        that.colorMaps[baseColor][categoryName] =
          that.colorScales[baseColor][that.categoryIndex[baseColor]++];
      }

      return that.colorMaps[baseColor][categoryName];
    };

    /**
     * @function _getValue
     * @summary helper function to get value property of geojson feature.
     *
     * @param {object} d - geojson feature.
     * @returns {float} value field of properties.
     */
    var _getValue = function (d) {return parseFloat(d.properties.value); };

    /**
     * @function _getTimeIntervalDats
     * @summary helper function to get difference between timestamp_end and
     * timestamp_start
     *
     * @param {object} d - geojson feature.
     * @returns {integer} time interval in days.
     */
    var _getTimeIntervalDays = function (d) {
      return (d.properties.timestamp_end - d.properties.timestamp_start) /
              1000 / 60 / 60 / 24;
    };

    /**
     * @function aggregate
     * @memberOf EventAggregateService
     * @summary Aggregates list of geojson features by category.
     *
     * @description Uses d3.nest() to aggregate lists of geojson events by
     * interval and category, additionaly returns average duration of events
     * when timestamp_start and timestamp_end are set.
     *
     * When the `value` property of a feature is a `float` or `int`, additional
     * statistics are calculated: min, max, sum, mean,
     *
     * If data is empty returns empty array.
     *
     * @param {object[]} data - list of event geojson features.
     * @param {integer} aggWindow - aggregation window in ms.
     * @param {string} baseColor - hex color.
     * @returns {array} - array of objects with keys
     *   for ordinal en nominal:
     *     timestamp, category, count, mean_duration
     *
     *   for ratio and interval:
     *     timestamp, mean, min, max,
     *
     */
    this.aggregate = function (data, aggWindow, baseColor) {

      if (data.length === 0) {
        return [];
      }

      var isString = true,
          // isString = isNaN(parseFloat(data[0].properties.value)),
          nestedData = {},
          aggregatedArray = [],
          timestampKey = function (d) {
            return UtilService.roundTimestamp(d.properties.timestamp_start,
                                              aggWindow);
          };

      if (baseColor === undefined) {

        nestedData = d3.nest()
          .key(timestampKey)
          .rollup(function (leaves) {
            var stats = {
              count: leaves.length,
            };

            return stats;
          })
          .map(data, d3.map);

        // rewrite d3 nested map to array of flat objects
        nestedData
          .forEach(function (timestamp, value) {
            var tmpObj = {
              timestamp: Number(timestamp) + aggWindow,
              count: value.count
            };
            aggregatedArray.push(tmpObj);
          }
        );

      // if value is string, data is nominal or ordinal, calculate counts
      // per cateogry
      } else if (isString) {

        nestedData = d3.nest()
          .key(timestampKey)
          .key(function (d) {return d.properties.category; })
          .rollup(function (leaves) {
            var stats = {
              "count": leaves.length,
              "mean_duration": d3.mean(leaves, _getTimeIntervalDays)
            };
            return stats;
          })
          .map(data, d3.map);

        // rewrite d3 nested map to array of flat objects
        nestedData
          .forEach(function (timestamp, value) {
            var tmpObj;
            value.forEach(function (category, value) {
              tmpObj = {timestamp: Number(timestamp) + aggWindow,
                        category: category,
                        mean_duration: value.mean_duration,
                        color: _getColor(category,
                                         baseColor),
                        count: value.count};
              aggregatedArray.push(tmpObj);
            });
          }
        );

        // sort array by timestamp and category
        aggregatedArray.sort(timeCatComparator);
      } else {

        nestedData = d3.nest()
          .key(timestampKey)
          .rollup(function (leaves) {
            var stats = {
              count: leaves.length,
              min: d3.min(leaves, _getValue),
              max: d3.max(leaves, _getValue),
              mean: d3.mean(leaves, _getValue),
              median: d3.median(leaves, _getValue),
              sum: d3.sum(leaves, _getValue),
              mean_duration: d3.mean(leaves, _getTimeIntervalDays),
            };

            return stats;
          })
          .map(data, d3.map);

        // rewrite d3 nested map to array of flat objects
        nestedData
          .forEach(function (timestamp, value) {
            var tmpObj = {
              color: baseColor,
              timestamp: Number(timestamp) + aggWindow,
              mean_duration: value.mean_duration,
              min: value.min,
              max: value.max,
              mean: value.mean,
              median: value.median,
              sum: value.sum,
              count: value.count
            };
            aggregatedArray.push(tmpObj);
          }
        );

      }

      return aggregatedArray;
    };

  }]);

angular.module('lizard-nxt')
.service("CSVService",

  [

  "UtilService",
  "DataService",
  "State",

  function (

    UtilService,
    DataService,
    State

    ) {

    // CONSTANTS

    var NO_DATA_MSG = "Geen waarde bekend",
        TOO_MUCH_DATA_MSG = "De door u getrokken lijn of het temporeel interval is te lang. Er zijn te veel metingen om in een CSV weer te geven: ",
        COORD_DECIMAL_COUNT = 8,
        DUTCHIFY_TIMESTAMPS = true,
        MAX_ROW_COUNT = 50000;

    // PUBLIC /////////////////////////////////////////////////////////////////

    /**
     * @description - Delegates between the two CSV generating functions, one
     *                for temporal rasters and on for non-temporal rasters.
     * @param {string} lgSlug - The slug for the layergroup we want to intersect.
     * @param {object} layer - The layer we want to intersect.
     * @return {string/number[][]} - The result, which can be formatted to an
     *                               actual CSV by the ng-csv directive.
     */
    this.formatLineCSV = function (lgSlug, layer) {
      if (layer.data) {
        return _dataIsTemporal(lgSlug)
          // NB! Sometimes a resolved API call uses layer.data for housing it's
          // raw response, and sometimes it uses layer.temporalData; in the latter
          // case layer.data is already needed for the Graph svc, where D3 requires
          // specifically formatted data:
          ? _formatLineCSVTemporal(layer.temporalData || layer.data, lgSlug)
          : _formatLineCSVNonTemporal(layer.data);
      } else {
        _throwDataError(layer);
      }
    };

    /*
     * @description - Get the column names for CSV
     * @param {string} lgSlug - The slug for the layergroup we want to intersect.
     * @param {object} layer - The layer we want to intersect.
     * @return {string[]} - A list with the column names.
     */
    this.getLineCSVHeaders = function (lgSlug, layer) {

      var DEFAULT_HUMAN_READABLE_X = "Afstand [m]",
          humanReadableX = {
            // someLGslug: someHumanReadableXforThatLG
          }[lgSlug] || DEFAULT_HUMAN_READABLE_X,
          humanReadableY = layer.quantity + ' [' + layer.unit + ']';

      if (layer.data) {
        return _dataIsTemporal(lgSlug)
          ? [ 'Timestamp',
              humanReadableX,
              humanReadableY,
              'Lijn start (latitude)',
              'Lijn start (longitude)',
              'Lijn eind (latitude)',
              'Lijn eind (longitude)'
          ]
          : [
              humanReadableX,
              humanReadableY,
              'Lijn start (latitude)',
              'Lijn start (longitude)',
              'Lijn eind (latitude)',
              'Lijn eind (longitude)'
          ];
      } else {
        _throwDataError(layer);
      }
    };

    // PRIVATE ////////////////////////////////////////////////////////////////

    /**
     * @description - Throws error because insufficient data.
     * @param {object} layer - The layer we want to intersect.
     * @return {void}
     */
    var _throwDataError = function (layer) {
      throw new Error(
        "Cannot format CSV since the specified layer has not enough data. layer.slug =" + layer.slug
      );
    };

    /**
     * @description - Throws error because incorrect layergroup slug.
     * @param {object} lgSlug - The slug for the layergroup we want to intersect.
     * @return {void}
     */
    var _throwLayerGroupError = function (lgSlug) {
      throw new Error(
        "No layerGroup retrievable from DataService when using the slug: " + lgSlug
      );
    };

    /**
     * @description - Check whether a layergroup has a temporal component.
     * @param {string} lgSlug - The slug for the layergroup we want to intersect.
     * @return {boolean}
     */
    var _dataIsTemporal = function (lgSlug) {
      var lg = DataService.layerGroups[lgSlug];
      if (lg !== undefined) {
        return lg.isTemporal();
      } else {
        _throwLayerGroupError(lgSlug);
      }
    };

    var _getStoreResolution = function (lgSlug) {
      var lg = DataService.layerGroups[lgSlug];
      if (lg !== undefined && lg.temporalResolution) {
        return lg.temporalResolution;
      } else {
        _throwLayerGroupError(lgSlug);
      }
    };

    /**
     * @description - Get start-/end coordinates for current line.
     * @return {float[]} - A list with the 4 floats denoting the start-/end of
     *                     the line.
     */
    var _getLineCoordinates = function () {

      return {

        startLat: UtilService.formatNumber(UtilService.round(
          State.spatial.points[0].lat, COORD_DECIMAL_COUNT
        ), 0, COORD_DECIMAL_COUNT, true),

        startLng: UtilService.formatNumber(UtilService.round(
          State.spatial.points[0].lng, COORD_DECIMAL_COUNT
        ), 0, COORD_DECIMAL_COUNT, true),

        endLat: UtilService.formatNumber(UtilService.round(
          State.spatial.points[1].lat, COORD_DECIMAL_COUNT
        ), 0, COORD_DECIMAL_COUNT, true),

        endLng: UtilService.formatNumber(UtilService.round(
          State.spatial.points[1].lng, COORD_DECIMAL_COUNT
        ), 0, COORD_DECIMAL_COUNT, true)
      };
    };

    /**
     * @description - Make timestamps readable for dutch-only people
     * @param {integer} epoch - Seconds since 1970-01-01 00:00:00 .
     * @return {string} - Timestamp in "horlogetijd"
     */
    var _dutchifyTimestamp = function (epoch) {

      var d = new Date(epoch),
          datePart = [
            d.getDate(),
            d.getMonth() + 1,
            d.getFullYear()
          ].join('-'),
          timePart = [
            d.getHours() || "00",
            d.getMinutes() || "00",
            d.getSeconds() || "00"
          ].join(':');

      return timePart + " " + datePart;
    };

    /**
     * @description - format the CSV data (non-temporal raster data)
     * @param {number[][]} data - The data to be formatted.
     * @return {number/string[][]} - the formatted data
     */
    var _formatLineCSVNonTemporal = function (data) {

      var i,
          datum,
          result = [],
          coords = _getLineCoordinates(),
          startLat = coords.startLat,
          startLng = coords.startLng,
          endLat = coords.endLat,
          endLng = coords.endLng;

      if (data.length > MAX_ROW_COUNT) {
        return [[TOO_MUCH_DATA_MSG + data.length]];
      }

      for (i = 0; i < data.length; i++) {
        datum = data[i];
        if (datum[1] === null) { continue; }
        result.push([
          typeof data[i][0] === 'number'
            ? UtilService.formatNumber(UtilService.round(datum[0], 2), 0, 2, true)
            : NO_DATA_MSG,
          typeof data[i][1] === 'number'
            ? UtilService.formatNumber(UtilService.round(datum[1], 2), 0, 2, true)
            : NO_DATA_MSG,
          startLat,
          startLng,
          endLat,
          endLng
        ]);
      }
      return result;
    };

    /**
     * @description - format the CSV data (temporal raster data)
     * @param {number[][]} data - The data to be formatted.
     * @return {number/string[][]} - the formatted data
     */
    var _formatLineCSVTemporal = function (data, lgSlug) {

      var t,
          i,
          datum,
          result = [],
          timestamp,
          coords = _getLineCoordinates(),
          startLat = coords.startLat,
          startLng = coords.startLng,
          endLat = coords.endLat,
          endLng = coords.endLng,
          amountOfTimestamps = data.length,
          tempExtentInterval = State.temporal.end - State.temporal.start,
          // Assumption which holds when measurements (i) are present for full
          // temp.extent and (ii) are equidistant with distance equal to aggWindow:
          durationPerMeasurement = _getStoreResolution(lgSlug);

      if (amountOfTimestamps * data[0][1].length > MAX_ROW_COUNT) {
        return [[TOO_MUCH_DATA_MSG + amountOfTimestamps * data.length]];
      }

      var roundedStartTime = State.temporal.start - (
        State.temporal.start % durationPerMeasurement
      );

      for (t = 0; t < amountOfTimestamps; t++) {

        timestamp = DUTCHIFY_TIMESTAMPS
          ? _dutchifyTimestamp(roundedStartTime + (t * durationPerMeasurement))
          : roundedStartTime + (t * durationPerMeasurement);

        datum = data[t];
        for (i = 0; i < datum[1].length; i++) {
          var datum_ = datum[1][i];
          result.push([
            timestamp,
            typeof datum_[0] === 'number'
              ? UtilService.formatNumber(UtilService.round(datum_[0], 2), 0, 2, true)
              : NO_DATA_MSG,
            typeof datum_[1] === 'number'
              ? UtilService.formatNumber(UtilService.round(datum_[1], 2), 0, 2, true)
              : NO_DATA_MSG,
            startLat,
            startLng,
            endLat,
            endLng,
          ]);
        }
      }
      return result;
    };
}]);

'use strict';

/**
 * Lizard-nxt filters
 *
 * Overview
 * ========
 *
 * Defines custom filters
 *
 */

angular.module('lizard-nxt-filters', []);

/**
 * Filter to order objects instead of angulars orderBy
 * that only orders array
 */
angular.module('lizard-nxt-filters')
  .filter('orderObjectBy', function () {
  return function (items, field, reverse) {
    var filtered = [];
    angular.forEach(items, function (item) {
      filtered.push(item);
    });
    filtered.sort(function (a, b) {
      return (a[field] > b[field] ? 1 : -1);
    });
    if (reverse) { filtered.reverse(); }
    return filtered;
  };
});


/**
 * Returns a rounded number or a '...' based on input type.
 *
 * @param {string} input to round or convert to dash, can be string or number
 * @param {number} optional decimals to round the number to
 * @return {string} when input is a number: returns a number
 * rounded to specified decimals else returns '-'
 */
angular.module('lizard-nxt-filters')
  .filter('niceNumberOrEllipsis', function () {
  return function (input, decimals) {
    var out;
    if (typeof(input) === 'number') {
      var factor = 1;
      if (decimals) {
        factor = Math.pow(10, decimals);
      }
      out = Math.round(input * factor) / factor;
    } else {
      out = '...';
    }
    return out;
  };
});

// lookups: manhole

angular.module('lizard-nxt-filters')
  .filter('lookupManholeShape', function () {
  return function (input) {
    var out;
    switch (input) {
    case '0.0':
      out = 'vierkant';
      break;
    case '1.0':
      out = 'rond';
      break;
    case '2.0':
      out = 'rechthoekig';
      break;
    default:
      out = 'Afwijkende vorm';
    }
    return out;
  };
});

angular.module('lizard-nxt-filters')
  .filter('lookupManholeMaterial', function () {
  return function (input) {
    var out;
    out = '...';
    return out;
  };
});

// lookups: culvert

angular.module('lizard-nxt-filters')
  .filter('lookupCulvertShape', function () {
  return function (input) {
    var out;
    switch (input) {
    case '0':
      out = 'rond';
      break;
    case '1':
      out = 'eivorm';
      break;
    case '2':
      out = 'rechthoek';
      break;
    case '3':
      out = 'muilvorm';
      break;
    case '4':
      out = 'vierkant';
      break;
    case '5':
      out = 'heul';
      break;
    case '6':
      out = 'trapezium';
      break;
    case '98':
      out = 'Vorm afwijkend';
      break;
    case '99':
      out = 'Vorm onbekend';
      break;
    default:
      out = 'Vorm afwijkend';
    }
    return out;
  };
});

angular.module('lizard-nxt-filters')
  .filter('lookupCulvertMaterial', function () {
  return function (input) {
    var out;
    switch (input) {
    case '0':
      out = 'beton';
      break;
    case '1':
      out = 'PVC';
      break;
    case '2':
      out = 'gres';
      break;
    default:
      out = 'Materiaal afwijkend';
    }
    return out;
  };
});

// lookups: weir

angular.module('lizard-nxt-filters')
  .filter('lookupWeirControl', function () {
  return function (input) {
    var out;
    switch (input) {
    case '1':
      out = 'Vast';
      break;
    case '2':
      out = 'Regelbaar, niet auto';
      break;
    case '3':
      out = 'Regelbaar, auto';
      break;
    case '4':
      out = 'Handmatig';
      break;
    case '98':
      out = 'Overig';
      break;
    default:
      out = 'Niet bekend';
    }
    return out;
  };
});


// lookups: levee

angular.module('lizard-nxt-filters')
  .filter('lookupLeveeType', function () {
  return function (input) {
    var out;
    switch (input) {
    case 1:
      out = 'Primair';
      break;
    case 2:
      out = 'Regionaal';
      break;
    case 3:
      out = 'c-type';
      break;
    default:
      out = 'Afwijkend type';
    }
    return out;
  };
});

angular.module('lizard-nxt-filters')
  .filter('lookupLeveeReferencePointType', function () {
  return function (input) {
    var out;
    switch (input) {
    case 1:
      out = 'Dijkpaal';
      break;
    case 2:
      out = 'Virtueel';
      break;
    default:
      out = 'Afwijkend type';
    }
    return out;
  };
});


angular.module('lizard-nxt-filters')
  .filter('allowedFlowDirection', function () {
  return function (input) {
    var out;
    if (input !== null && input !== undefined) {
      out = input;
    } else {
      out = '...';
    }
    return out;
  };
});


angular.module('lizard-nxt-filters')
  .filter('lookupPumpStationType', function () {
  return function (input) {
      switch (input) {
      case 'HOUSEHOLD':
        return 'Drukgemaal';
      case 'SEWER':
        return 'Rioolgemaal';
      case 'TRANSPORT':
        return 'Transportgemaal';
      case 'UNDER':
        return 'Onderbemaling';
      case 'POLDER':
        return 'Poldergemaal';
      case 'BOSOM':
        return 'Boezemgemaal';
      case 'OTHER':
        return 'Gemaaltype afwijkend';
      default:
        return 'Gemaaltype onbekend';
      }
    };
});

angular.module('lizard-nxt-filters')
  .filter('lookupPipeType', function () {
  return function (input) {
    var out;
    switch (input) {
    case '00':
      out = 'Gemengde leiding';
      break;
    case '01':
      out = 'Regenwaterleiding';
      break;
    case '02':
      out = 'Vuilwaterleiding';
      break;
    case '03':
      out = 'Transportleiding';
      break;
    case '04':
      out = 'Overstortleiding';
      break;
    case '05':
      out = 'Zinker';
      break;
    case '06':
      out = 'Bergingsleiding';
      break;
    case '07':
      out = 'Berg-/Bezinkleiding';
      break;
    default:
      out = 'Leidingtype afwijkend';
    }
    return out;
  };
});

angular.module('lizard-nxt-filters')
  .filter('lookupPipeShape', function () {
  return function (input) {
    var out;
    switch (input) {
    case '0.0':
      out = 'rond';
      break;
    case '1.0':
      out = 'eivorm';
      break;
    case '2.0':
      out = 'rechthoek';
      break;
    case '4.0':
      out = 'vierkant';
      break;
    default:
      out = 'Vorm afwijkend';
    }
    return out;
  };
});

angular.module('lizard-nxt-filters')
  .filter('lookupPressurePipeType', function () {
  return function (input) {
    var out;
    switch (input) {
    case '1':
      out = 'Drukriolering';
      break;
    case '2':
      out = 'Persleiding';
      break;
    case '3':
      out = 'Pers-/transportleiding';
      break;
    default:
      out = 'Persleidingtype afwijkend';
    }
    return out;
  };
});

angular.module('lizard-nxt-filters')
  .filter('pipeMaterialOrEllipsis', function () {
  return function (input) {
    var out;
    switch (input) {
    case '0.0':
      out = 'beton';
      break;
    case '1.0':
      out = 'PVC';
      break;
    case '2.0':
      out = 'gres';
      break;
    default:
      out = 'Materiaal afwijkend';
    }
    return out;
  };
});

angular.module('lizard-nxt-filters')
  .filter('aggWinToYLabel', function () {
  return function (input) {
    var out;
    switch (input) {
    case 300000:
      out = 'mm / 5 min';
      break;
    case 3600000:
      out = 'mm / uur';
      break;
    case 86400000:
      out = 'mm / dag';
      break;
    case 2635200000:
      out = 'mm / maand';
      break;
    default:
      out = '...';
    }
    return out;
  };
});

/**
 * Truncates a string to have no more than maxLength characters.
 * Used in the righthand menu for truncating lengthy layer names.
 *
 * @param {integer} maxLength - Length at which string gets truncated.
 * @return {string} The truncated layer name
 */
angular.module('lizard-nxt-filters')
  .filter('truncate', function () {

  return function (input, maxLength) {

    var MAX_LENGTH = maxLength || 20;

    if (input.length > MAX_LENGTH) {
      return input.slice(0, MAX_LENGTH - 3) + "...";

    } else {
      return input;
    }
  };
});

/**
 * For the n timeseries related to a structure, remove the ones with an
 * insufficient amount of measurements to be able draw a graph. Since ts events
 * have a max and a min, it is possible to draw a line between 1 data point.
 *
 * @param {Object[]} A list of timeseries
 * @return  {Object[]} A list of timeseries with sufficient data
 */
angular.module('lizard-nxt-filters')
  .filter('rmZeroDatumTimeseries', function () {

  return function (input) {
    var result = [];
    angular.forEach(input, function (datum) {
      if (datum.events.length > 0) { result.push(datum); }
    });
    return result;
  };
});


angular.module('lizard-nxt-filters')
  .filter('objectTitle', function () {

  return function (input) {

    return {
      'bridge': 'Brug',
      'channel': 'Watergang',
      'channel_Boezem': 'Boezemkanaal',
      'channel_Primair': 'Primaire watergang',
      'crossprofile': 'Kruisprofiel',
      'culvert': 'Duiker',
      'groundwaterstation': 'Grondwaterstation',
      'manhole': 'Put',
      'measuringstation': 'Meetstation',
      'orifice': 'Doorlaat',
      'outlet': 'Uitlaat',
      'overflow': 'Overstort',
      'pipe': 'Rioolleiding',
      'pumpstation': 'Gemaal',
      'weir': 'Stuw',
      'pressurepipe': 'Persleiding',
      'sluice': 'Sluis',
      'wastewatertreatmentplant': 'Rioolwaterzuiveringsinstallatie',
      'levee': 'Kering',
      'leveereferencepoint': 'Referentiepunt kering',
      'pump': 'Pump',
      'filter': 'Filter'
    }[input] || input;
  };

});

/**
 * Expects a string of '<anything - ...> - <source> - <value>' or only '<value>'
 * Return the last part (value).
 */
angular.module('lizard-nxt-filters')
  .filter('discreteRasterType', function () {
  return function (input) {
    var labelParts = input.split(' - ');
    return labelParts[labelParts.length - 1];
  };
});

/**
 * Expects a string of '<anything - ...> - <source> - <value>' or only '<value>'
 * Try to return the 2nd to last part (source), if it does not have so many
 * parts, return empty string.
 */
angular.module('lizard-nxt-filters')
  .filter('discreteRasterSource', function () {
  return function (input) {
    var labelParts = input.split(' - ');
    var output = labelParts[labelParts.length - 2];
    if (output === undefined) { output = ''; }
    return output;
  };
});


/**
 * @ngdoc service
 * @class LeafletService
 * @memberof app
 * @name LeafletService
 * @description Trivial wrapper for global Leaflet object.
 *
 * Perhaps in the future this can be done with CommonJS style requires.
 */
angular.module('lizard-nxt')
  .service('LeafletService', [function () {
  if (L) {
    // Leaflet global variable to speed up vector layer,
    // see: http://leafletjs.com/reference.html#path-canvas
    window.L_PREFER_CANVAS = true;

    // Set max margin of latLng.equals method. This way
    // the vectorservice is able to return the features
    // within 0.0001 degree of the click.
    L.LatLng.MAX_MARGIN = 0.0001;

    return L;
  } else {
    throw new Error('Leaflet can not be found');
  }
}]);

/*
 Copyright (c) 2012, Smartrak, David Leaver
 Leaflet.utfgrid is an open-source JavaScript library that provides utfgrid interaction on leaflet powered maps.
 https://github.com/danzel/Leaflet.utfgrid
*/
(function (window, undefined) {

  L.Util.ajax = function (url, cb) {
    // the following is from JavaScript: The Definitive Guide
    // and https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest_in_IE6
    if (window.XMLHttpRequest === undefined) {
      window.XMLHttpRequest = function () {
        /*global ActiveXObject:true */
        try {
            return new ActiveXObject("Microsoft.XMLHTTP");
        }
        catch  (e) {
            throw new Error("XMLHttpRequest is not supported");
        }
      };
    }
    var response, request = new XMLHttpRequest();
    request.open("GET", url, true); // async
    request.withCredentials = true;
    // request.open("GET", url, false); // sync
    request.onreadystatechange = function () {
      /*jshint evil: true */
      if (request.readyState === 4 && request.status === 200) {
        if (window.JSON) {
            response = JSON.parse(request.responseText);
        } else {
            response = eval("(" + request.responseText + ")");
        }
        cb(response);
      }
    };
    request.send();
  };


  L.UtfGrid = L.Class.extend({

    includes: L.Mixin.Events,
    options: {
      subdomains: 'abc',

      minZoom: 0,
      maxZoom: 18,
      tileSize: 256,

      resolution: 4,

      useJsonP: true,
      pointerCursor: true
    },

    //The thing the mouse is currently on
    _mouseOn: null,

    isLoading: false,

    initialize: function (url, options) {
      L.Util.setOptions(this, options);

      this._url = url;
      this._cache = {};
      // We keep track of the tiles which are at least partially within
      // the current spatial extent.
      this._extentCache = {};

      //Find a unique id in window we can use for our callbacks
      //Required for jsonP
      var i = 0;
      while (window['lu' + i]) {
          i++;
      }
      this._windowKey = 'lu' + i;
      window[this._windowKey] = {};

      var subdomains = this.options.subdomains;
      if (typeof this.options.subdomains === 'string') {
          this.options.subdomains = subdomains.split('');
      }
    },

    onAdd: function (map) {
      this._map = map;
      this._container = this._map._container;

      this._update();

      var zoom = this._map.getZoom();

      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
        return;
      }

      map.on('click', this._click, this);
      map.on('mousemove', this._move, this);
      map.on('moveend', this._update, this);

      this._tileLoaded(); // Check whether more tiles need loading
    },

    onRemove: function () {
      this._map.off('click', this._click, this);
      this._map.off('mousemove', this._move, this);
      this._map.off('moveend', this._update, this);
      // I am free, I'm free at last
      this._cache = {};
      if (this.options.pointerCursor) {
        this._container.style.cursor = '';
      }
    },

    _click: function (e) {
      this.fire('click', this._objectForEvent(e));
    },
    _move: function (e) {
      var on = this._objectForEvent(e);

      if (on.data !== this._mouseOn) {
        if (this._mouseOn) {
          this.fire('mouseout', { latlng: e.latlng, data: this._mouseOn });
          if (this.options.pointerCursor) {
            this._container.style.cursor = '';
          }
        }
        if (on.data) {
          this.fire('mouseover', on);
          if (this.options.pointerCursor) {
            this._container.style.cursor = 'pointer';
          }
        }

        this._mouseOn = on.data;
      } else if (on.data) {
        this.fire('mousemove', on);
      }
    },

    _objectForEvent: function (e) {

      var map = this._map;
      if (!map) {
        // This layer has not been not added to the map yet
        return { latlng: e.latlng, data: null };
      }

      var point = map.project(e.latlng),
        tileSize = this.options.tileSize,
        resolution = this.options.resolution,
        x = Math.floor(point.x / tileSize),
        y = Math.floor(point.y / tileSize),
        gridX = Math.floor((point.x - (x * tileSize)) / resolution),
        gridY = Math.floor((point.y - (y * tileSize)) / resolution),
          max = map.options.crs.scale(map.getZoom()) / tileSize;

      x = (x + max) % max;
      y = (y + max) % max;

      var data = this._cache[map.getZoom() + '_' + x + '_' + y];
      if (!data) {
        return { latlng: e.latlng, data: null };
      }

      var idx = this._utfDecode(data.grid[gridY].charCodeAt(gridX)),
        key = data.keys[idx],
        result = data.data[key];

      if (!data.data.hasOwnProperty(key)) {
        result = null;
      }

      return { latlng: e.latlng, data: result};
    },

    //Load up all required json grid files
    //TODO: Load from center etc
    _update: function () {

      var bounds = this._map.getPixelBounds(),
          zoom = this._map.getZoom(),
          tileSize = this.options.tileSize;

      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
        return;
      }

      var nwTilePoint = new L.Point(
            Math.floor(bounds.min.x / tileSize),
            Math.floor(bounds.min.y / tileSize)
          ),
          seTilePoint = new L.Point(
            Math.floor(bounds.max.x / tileSize),
            Math.floor(bounds.max.y / tileSize)
          ),
          max = this._map.options.crs.scale(zoom) / tileSize;

      this._extentCache = {}; // empty the _extentCache

      //Load all required ones
      for (var x = nwTilePoint.x; x <= seTilePoint.x; x++) {
        for (var y = nwTilePoint.y; y <= seTilePoint.y; y++) {

          var xw = (x + max) % max, yw = (y + max) % max;
          var key = zoom + '_' + xw + '_' + yw;

          if (!this._cache.hasOwnProperty(key)) {
            // We prepare the new tiles that are to be rendered:
            this._cache[key] = null;
            this._extentCache[key] = null;
            this._loadTile(zoom, xw, yw);
          } else {
            // We keep the old tiles that are still rendered:
            this._extentCache[key] = this._cache[key];
          }
        }
      }
    },

    _tileLoaded: function () {
      var isLoading = false;
      for (var i in this._cache) {
        if (this._cache[i] === null) { isLoading = true; }
      }
      this.isLoading = isLoading;
      if (!this.isLoading) { this.fireEvent('load'); }
    },

    _loadTile: function (zoom, x, y) {
      var url = L.Util.template(this._url, L.Util.extend({
        s: L.TileLayer.prototype._getSubdomain.call(this, { x: x, y: y }),
        z: zoom,
        x: x,
        y: y
      }, this.options));

      var key = zoom + '_' + x + '_' + y;

      this.isLoading = true;

      var self = this;

      L.Util.ajax(url, function (data) {
        self._cache[key] = data;
        self._extentCache[key] = data;
        self._tileLoaded();
      });
    },

    _utfDecode: function (c) {
      if (c >= 93) {
        c--;
      }
      if (c >= 35) {
        c--;
      }
      return c - 32;
    },

    _getUniqueStructureId: function (structureData) {
      try {
        return structureData.entity_name + "$" + structureData.id;
      } catch (e) {
        throw new Error("Tried to derive a unique structure ID from incomplete data: its not gonna w0rk. Error 'e' =", e);
      }
    },

    getUniqueStructuresForExtent: function () {

      var tile,
          tileSlug,
          uniqueStructures = { data: {} };

      for (tileSlug in this._extentCache) {
        tile = this._extentCache[tileSlug];
        if (tile && tile.data) {

          var datum,
              datumSlug,
              structureKey;

          for (datumSlug in tile.data) {
            datum = tile.data[datumSlug];
            structureKey = this._getUniqueStructureId(datum);
            if (!uniqueStructures.data[structureKey])
            {
              uniqueStructures.data[structureKey] = datum;
            }
          }
        }
      }
      return uniqueStructures;
    }
  });

  L.utfGrid = function (url, options) {
    return new L.UtfGrid(url, options);
  };

}(this));

'use strict';

/**
 * @ngdoc service
 * @name LeafletVectorService
 * @description
 * # LeafletVector
 * Creates a Tiled Layer for retrieving and drawing vector data.
 */
angular.module('lizard-nxt')
  .service('LeafletVectorService', ["LeafletService", "VectorService", "UtilService",
      function (LeafletService, VectorService, UtilService) {

  var MarkerClusterLayer = LeafletService.MarkerClusterGroup.extend({

    /**
     * @function
     * @description adds functionality to original Add function
     * of Leaflet.
     */
    onAdd: function (map) {
      LeafletService.MarkerClusterGroup.prototype.onAdd.call(this, map);

      this._map = map;

      this.addMarker = this.addLayer;
      this.removeMarker = this.removeLayer;
      this.hasMarker = this.hasLayer;
      this.markers = [];

      var color = this.options.color,
          layer = this;

      VectorService.getData('leaflet', this.options.slug, {})
      .then(function (response) {
        layer.markers = [];

        var pxSize = 10,
            marker;

        var icon = L.divIcon({
          iconAnchor: [pxSize, pxSize],
          html: '<svg height="' + (pxSize * 2) + '" width="' + (pxSize * 2)
                + '">'
                + '<circle cx="' + pxSize + '" cy="' + pxSize
                + '" r="' + pxSize + '" fill-opacity="0.4" fill="'
                + color + '" />'
                + '<circle cx="' + pxSize + '" cy="' + pxSize + '" r="'
                + (pxSize - 2) + '" fill-opacity="1" fill="'
                + color + '" />'
                + '<text x="' + pxSize + '" y="' + (pxSize + 5)
                + '" style="text-anchor: middle; fill: white;">'
                + 1 + '</text>'
                + '</svg>'
        });


        response.forEach(function (f) {
          marker = L.marker(
            [f.geometry.coordinates[1], f.geometry.coordinates[0]],
            {
              icon: icon,
              timestamp_start: f.properties.timestamp_start,
              timestamp_end: f.properties.timestamp_end
            });
          layer.addMarker(marker);
          layer.markers.push(marker);
        });

        layer.syncTime();
      });

      // simulate click on map instead of this event;
      var fireMapClick = function (e) {
        layer._map.fire('click', {
          latlng: e.latlng,
        });
      };

      this.on('clusterclick', function (e) {
        fireMapClick(e);
      });

      this.on('click', function (e) {
        fireMapClick(e);
      });

    },


    /**
     * @function
     * @description Remove geojson sublayer
     * plus call original onremove event
     * @param {object} instance of Leaflet.Map
     */
    onRemove: function (map) {
      LeafletService.MarkerClusterGroup.prototype.onRemove.call(this, map);
      this.markers.forEach(function (marker) { this.removeMarker(marker); }, this);
      this.markers = [];
    },

    /**
     * @function
     * @description Implements opacity handler like other TileLayers
     * @params {float} amount of opacity between 0 and 1.
     */
    setOpacity: function (opacity) {
      // TODO: figure out why it is possible to call setOpacity while there is
      // no geojsonlayer.
      if (this.geojsonLayer) {
        this.geojsonLayer.setStyle({
          opacity: opacity,
          fillOpacity: opacity
        });
      }
    },

    /**
     * @function
     * @description sync the time
     */
    syncTime: function (timeState) {
      if (timeState) {
        this.timeState = timeState;
      }

      if (this.markers && this.markers.length > 0) {
        var start = this.timeState.playing ? this.timeState.at : this.timeState.start,
            end = this.timeState.playing
            ? this.timeState.at + this.timeState.aggWindow
            : this.timeState.end,
          markerTimeObject,
          mustRemoveMarker;

        this.markers.forEach(function (marker) {

          markerTimeObject = {
            timestamp_start: marker.options.timestamp_start,
            timestamp_end: marker.options.timestamp_end
          };

          mustRemoveMarker = !VectorService.isInTempExtent(markerTimeObject, {start: start, end: end});
          if (this.hasMarker(marker) && mustRemoveMarker) {
            this.removeMarker(marker);
          } else if (!this.hasMarker(marker) && !mustRemoveMarker) {
            this.addMarker(marker);
          }
        }, this);
      }

    },
  });

  return MarkerClusterLayer;

}]);

angular.module("global-state", []);


/**
 * @name dataLayers
 * @memberOf app
 * @description Contains the dataLayers set by the server. Used by the
 *              map-directive and layer-chooser directive to build layer
 *              groups.
 */
angular.module('global-state')
  .constant('dataLayers', window.data_layers);

/**
 * @name dataBounds
 * @memberOf app
 * @description Contains the bounds of the data set by the server at load
 */
angular.module('global-state')
  .constant('dataBounds', window.data_bounds);

angular.module('global-state')
  .run(function (dataLayers, dataBounds) {
    if (!dataLayers) {
      document.getElementsByTagName('body')[0].innerHTML =
      '<div class="error-message error-text" style="height: 135px">' +
        'Oops, this is not what you were looking for.' +
        'If you have any questions, please contact us. ' +
        '<a href="mailto:servicedesk@nelen-schuurmans.nl?subject=Lizard">servicedesk@nelen-schuurmans.nl</a>' +
      '</div>';
      throw new Error('No lizard-bs.js or no data layers in lizard-bs.js');
    }
  });

/**
 * Lizard-client global state object.
 */
angular.module('global-state')
  .service('State', ['dataLayers', 'UtilService',
    function (dataLayers, UtilService) {

    var state = {};

    /**
     * returns a function that returns a string representation of the provided
     * attribute of the state. When the state. does not exist, it returns a
     * function that returns "undefined". Useful to $watch the state.
     */
    state.toString = function (stateStr) {
      return function () {
        var property = state;
        angular.forEach(stateStr.split('.'), function (accessor) {
          if (property) {
            property = property[accessor];
          }
        });
        if (typeof property === 'string') {
          return property;
        } else {
          return JSON.stringify(property);
        }
      };
    };

    // Context. State.context returns 'map' or 'db', it can only be set with
    // either one of those values.
    var _context = 'map'; // The default
    var CONTEXT_VALUES = ['map', 'time', 'dashboard', 'scenarios'];
    Object.defineProperty(state, 'context', {
      get: function () { return _context; },
      set: function (context) {
        if (CONTEXT_VALUES.indexOf(context) > -1) {
          _context = context;
        } else {
          throw new Error("Attemped to assign an illegal value ('"
            + context
            + "') to state.context. Only ["
            + CONTEXT_VALUES.join(',')
            + "] are accepted values."
          );
        }
      }
    });

    // Default language.
    state.language = 'nl';

    // State of data layer groups, stores slugs of all layergroups and the
    // active layergroups.
    state.layerGroups = {
      all: [], // Immutable representation of all layergroups
      active: [],
      isLoading: null, // Either gettingData or syncingTime
      gettingData: false, // Making server requests through DataService
      timeIsSyncing: false // Getting new layers and so on
    };

    // Combination of data and time syncing
    Object.defineProperty(state.layerGroups, 'isLoading', {
      get: function () {
        return state.layerGroups.timeIsSyncing || state.layerGroups.gettingData;
      }
    });

    // Box
    state.box = {};

    var _type = 'point'; // Default box type
    var TYPE_VALUES = ["point", "line", "region", "area"];
    Object.defineProperty(state.box, 'type', {
      get: function () { return _type; },
      set: function (type) {
        if (TYPE_VALUES.indexOf(type) > -1) {
          _type = type;
        } else {
          throw new Error("Attemped to assign an illegal value ('"
            + type
            + "') to state.box.type. Only ["
            + TYPE_VALUES.join(',')
            + "] are accepted values."
          );
        }
      }
    });

    // Spatial
    state.spatial = {
      here: {},
      points: [], // History of here for drawing and creating line and polygons
      region: {},// geojson feature describing region, with name and type in
              // properties
      bounds: { // leaflet bounds object, initialized with a validity check
                // function.
        isValid: function () { return false; }
      },
      view: {}, // { lat: <int>, lng:<int>, zoom:<int> }
      userHere: {}, // Geographical location of the users mouse only set by
                    // map-directive when box type is 'line'
      mapMoving: false
    };

    // Temporal
    var now = Date.now(),
        hour = 60 * 60 * 1000,
        day = 24 * hour,
        INITIAL_START_FOR_EXTENT = now - 3 * hour,
        INITIAL_END_FOR_EXTENT = now + 3 * hour;

    state.temporal = {
      at: now,
      aggWindow: 1000 * 60 * 5,  // 5 minutes
      buffering: false,
      timelineMoving: false,
      playing: false,
      start: null, // defined below
      end: null // defined below
    };

    // State.temporal.start must be higher than MIN_TIME_FOR_EXTENT
    var _start = INITIAL_START_FOR_EXTENT;
    Object.defineProperty(state.temporal, 'start', {
      get: function () { return _start; },
      set: function (start) {
        _start = UtilService.getMinTime(start);
        state.temporal.at = _moveAtInTemporalExtent(state.temporal);
      }
    });

    // State.temporal.end must be lower than MAX_TIME_FOR_EXTENT
    var _end = INITIAL_END_FOR_EXTENT;
    Object.defineProperty(state.temporal, 'end', {
      get: function () { return _end; },
      set: function (end) {
        _end = UtilService.getMaxTime(end);
        state.temporal.at = _moveAtInTemporalExtent(state.temporal);
      }
    });

    /**
     * Checks given temporal state object whether `at` is within extent. If not
     * returns rounded `at` at start or end of time extent depending on
     * location of original `at`
     *
     * @param  {object} ts temporal state
     * @return {int}    at in ms from epoch.
     */
    var _moveAtInTemporalExtent = function (ts) {
      var _at = ts.at;
      if ((ts.at + ts.aggWindow) > ts.end) {
        _at = UtilService.roundTimestamp(
          ts.end,
          ts.aggWindow,
          true
        ) - ts.aggWindow;
      } else if (ts.at < ts.start) {
        _at = UtilService.roundTimestamp(
          ts.start,
          ts.aggWindow,
          true // round up.
        );
      }
      return _at;
    };

    return state;
  }]);

angular.module('data-menu', [
  'global-state'
]);
//layer-directive.js

angular.module('data-menu')
  .directive("layerChooser", [function () {

  var link = function (scope) {

    // Scope gets the mapState layerGroup, here we create a new layerGroup which
    // goes into its own NxtMap to always be turned on
    scope.showOpacitySlider = true;
  };

  return {
    link: link,
    templateUrl: 'layer-chooser/layer-chooser.html',
    restrict: 'E',
  };
}]);

'use strict';

/**
 * @ngdoc service
 * @name lizard-nxt.Layer
 * @description
 * # NxtLayer
 * Factory in the lizard-nxt.
 */
angular.module('data-menu')
  .factory('NxtLayer', ['$q', 'backendDomain', function ($q, backendDomain) {

      /*
       * @constructor
       * @memberOf app.Layer
       * @description Instantiates a layer with non-readable and
       *              non-configurable properties
       * @param  {object} layer definition as coming from the server.
       * @param  {object} temporal resolution from the parent layergroup.
       */
      function NxtLayer(layer, temporalResolution) {
        Object.defineProperty(this, 'slug', {
          value: layer.slug,
          writable: false,
        });
        Object.defineProperty(this, 'type', {
          value: layer.type,
          writable: false,
        });
        Object.defineProperty(this, 'format', {
          value: layer.format,
          writable: false,
        });
        Object.defineProperty(this, 'minZoom', {
          value: layer.min_zoom,
          writable: false,
        });
        Object.defineProperty(this, 'maxZoom', {
          value: layer.max_zoom,
          writable: false,
        });
        Object.defineProperty(this, 'url', {
          value: layer.url,
          // on github.io it needs to be prepended to
          writable: (window.location.host === 'nens.github.io' ||
                     window.location.host === 'lizard.sandbox.lizard.net'),
        });
        // Physical time in millieseconds between frames.
        Object.defineProperty(this, '_temporalResolution', {
          value: temporalResolution,
          writable: true,
        });
        // Bounds are set from the layer config in lizard-bs or set from the
        // layergroup when data-layer-group-service initiates layergroups.
        Object.defineProperty(this, 'bounds', {
          value: layer.meta && layer.meta.spatial_bounds,
          writable: true,
        });
        Object.defineProperty(this, 'color', {
          value: layer.color,
          writable: false,
        });
        Object.defineProperty(this, 'aggregationType', {
          value: layer.aggregation_type,
          writable: false,
        });
        Object.defineProperty(this, 'scale', {
          value: layer.scale,
          writable: false,
        });
        Object.defineProperty(this, 'quantity', {
          value: layer.quantity,
          writable: false,
        });
        Object.defineProperty(this, 'unit', {
          value: layer.unit,
          writable: false,
        });
        Object.defineProperty(this, 'zIndex', {
          value: layer.z_index,
          writable: false,
        });
        Object.defineProperty(this, 'tiled', {
          value: layer.tiled,
          writable: false,
        });
        Object.defineProperty(this, 'options', {
          value: layer.options,
          writable: false,
        });
        Object.defineProperty(this, 'rescalable', {
          value: layer.rescalable,
          writable: false,
        });
        Object.defineProperty(this, 'loadOrder', {
          value: layer.load_order,
          writable: false,
        });

        // this allows for the demo's to be run from github.io
        if ((this.url.indexOf('api/v2') > -1) &&
            (window.location.host === 'nens.github.io' ||
             window.location.host === 'lizard.sandbox.lizard.net')) {
          this.url = backendDomain + this.url;
        }


      }

      return NxtLayer;

    }
  ]);

'use strict';

/**
 * @ngdoc service
 * @name lizard-nxt.Layer
 * @description
 * # NxtDataLayer
 * Factory in the lizard-nxt.
 */
angular.module('data-menu')
  .factory('NxtDataLayer', ['$q', '$injector', 'NxtLayer',
  function ($q, $injector, NxtLayer) {

      var SERVICES = {
        Store: 'RasterService',
        Vector: 'VectorService',
        UTFGrid: 'UtfGridService',
        WMS: 'WmsGetFeatureInfoService'
      };

      function NxtDataLayer(layer, tempRes) {
        NxtLayer.call(this, layer, tempRes);

        this._service = $injector.get(SERVICES[this.format]);
      }

      NxtDataLayer.prototype = Object.create(NxtLayer.prototype, {

        constructor: NxtDataLayer,

       /**
        * @function
        * @memberOf app.Layer
        * @description Abstract method to be overridden by the layers that
        *              implement Layer can return data (Store and vector).
        * @param  {string} callee string of the callee to keep requests
        *                         seperate.
        * @param lgSlug slug of the layer.
        * @param options options object with geom and time.
        * @param deferred the defer to resolve when getting data.
        */
        getData: {
          value: function (callee, lgSlug, options, deferred) {
            if (this._filter(options)) {
              return this._buildPromise(
                callee,
                lgSlug,
                options,
                deferred,
                this._service
              );
            } else { return; }
          }
        },

        /**
         * Filters getData request. If the options dictate that this layer
         * should make a request this function returns true.
         * @param {object} options to match with this layer.
         */
        _filter: {
          value: function (options) {
            if (options.type) {
              if (options.type !== this.type) {
                return false;
              }
            }
            if (options.truncate) {
              if (this.format !== 'Store'
                || this._temporalResolution === undefined
                || this._temporalResolution === 0) {
                return false;
              }
            }
            if (options.exclude) {
              if (options.exclude === this.slug) {
                return false;
              }
            }
            return true;
          }
        },

       /**
        * @function
        * @memberOf app.Layer
        * @description creates a promise for the given layer and the provided
        *              service. The service should have a getData function that
        *              returns a promise that is resolved when data is recieved.
        * @param  {string} callee string of the callee to keep requests
        *                         seperate.
        * @param lg layerGroup slug to include in the response.
        * @param layer nxtLayer definition.
        * @param options options containing geometry or time.
        * @param deffered deffered to notify when service.getData resolves.
        * @param wantedService Service to getData from.
        */
        _buildPromise: {
          value: function (callee, lgSlug, options, deferred, wantedService) {

            var aggType = this.aggregationType,
                color = this.color,
                scale = this.scale,
                slug = this.slug,
                summary = this.summary,
                format = this.format,
                type = this.type,
                quantity = this.quantity,
                unit = this.unit;

            var buildSuccesCallback = function (data) {
              deferred.notify({
                color: color,
                data: (data && data.data) || data, // data or if exists data.data
                format: format,
                layerGroupSlug: lgSlug,
                layerSlug: slug,
                aggType: aggType,
                summary: summary,
                scale: scale,
                type: type,
                quantity: quantity,
                unit: unit
              });
            };

            var buildErrorCallback = function (msg) {
              deferred.notify({
                data:  null,
                type: type,
                layerGroupSlug: lgSlug,
                layerSlug: slug
              });
            };

            // Pass layer options to the services making the request.
            // RasterServices uses this to add options.styles.
            var extendedOpts = angular.extend({}, options, this.options);
            extendedOpts.agg = this.aggregationType;

            return wantedService.getData(callee, this, extendedOpts)
              .then(buildSuccesCallback, buildErrorCallback);
          }
        }

      });

      return NxtDataLayer;

    }
  ]);


/**
 * @ngdoc service
 * @class LayerGroup
 * @memberof app
 * @name LayerGroup
 * @summary LayerGroup abstracts the notion of layers out of the app.
 * @description Only layergroups are approachable, from the outside world
 *              LayerGroup defines a group of layers which are loaded at
 *              initialization of the page. They can be toggled on/off and
 *              queried for data. Layergroup draws all its layers and returns
 *              data for all layers.
 */
angular.module('data-menu')
  .factory('DataLayerGroup', [
  'NxtLayer', 'NxtDataLayer', 'UtilService', '$q', '$http',
  function (NxtLayer, NxtDataLayer, UtilService, $q, $http) {

    /*
     * @constructor
     * @memberOf app.LayerGroup
     * @description Instantiates a layerGroup with non-readable and
     *              non-configurable properties
     * @param  {object} layergroup definition as coming from the server
     */
    function LayerGroup(layerGroup, callbackFns) {
      Object.defineProperty(this, 'temporal', {
        value: layerGroup.temporal,
        writable: false,
      });
      Object.defineProperty(this, 'temporalResolution', {
        value: layerGroup.temporal_resolution,
        writable: false,
      });
      Object.defineProperty(this, 'name', {
        value: layerGroup.name,
        writable: false,
      });
      Object.defineProperty(this, 'order', {
        value: layerGroup.order,
        writable: false,
      });
      Object.defineProperty(this, 'baselayer', {
        value: layerGroup.baselayer,
        writable: false,
      });
      Object.defineProperty(this, 'slug', {
        value: layerGroup.slug,
        writable: false,
      });
      Object.defineProperty(this, 'defaultActive', {
        value: layerGroup.active,
        writable: false,
      });
      Object.defineProperty(this, '_dataLayers', {
        value: [],
        writable: true,
      });
      Object.defineProperty(this, 'mapLayers', {
        value: [],
        writable: true,
      });
      Object.defineProperty(this, '_opacity', {
        value: layerGroup.opacity,
        writable: true,
      });
      Object.defineProperty(this, '_active', {
        value: false,
        writable: true,
      });
      Object.defineProperty(this, 'spatialBounds', {
        value: {'east': 0, 'south': 0, 'north': 0, 'west': 0},
        writable: true,
      });
      Object.defineProperty(this, 'temporalBounds', {
        value: {'start': 0, 'end': 0},
        writable: true,
      });


      this.instantiateLayers(layerGroup.layers, layerGroup.temporal_resolution);

      // Let the map-service know there is a new layergroup
      if (this.callbackFns) {
        this.callbackFns.onCreateLayerGroup(this);
      }
    }

    LayerGroup.prototype = {

      constructor: LayerGroup,

      instantiateLayers: function (layers, tempRes) {
        // Instantiate a Layer for every servserside layer of
        // the layergroup. There are layers that are drawn on the
        // map by the map-servie that go in mapLayers, layers that
        // are just used for data purposes are put in dataLayers
        // and layers that do both.

        angular.forEach(layers, function (layer) {

          if (layer.format === 'UTFGrid'
            || layer.format === 'Vector'
            || (layer.format === 'WMS' && layer.get_feature_info)) {
            var nxtLayer = new NxtDataLayer(layer, tempRes);
            this._dataLayers.push(nxtLayer);
            this.mapLayers.push(nxtLayer);
            // NOTE: crappy solution, we should set meta to None or
            // empty to do better checking.
            if (typeof layer.meta !== "string") {
              this.temporalBounds = layer.meta.temporal_bounds;
              this.spatialBounds = layer.meta.spatial_bounds;
            }
          }
          else if (layer.format === 'Store') {
            this._dataLayers.push(new NxtDataLayer(layer, tempRes));
            if (layer.meta) {
              this.temporalBounds = layer.meta.temporal_bounds;
              this.spatialBounds = layer.meta.spatial_bounds;
            }
          }
          else if (layer.format === 'TMS'
            || (layer.format === 'WMS' && !layer.get_feature_info)) {
            this.mapLayers.push(new NxtLayer(layer, tempRes));
          }
        }, this);
      },

     /**
      * @function
      * @memberOf app.LayerGroup.prototype
      * @description toggles a layergroup on the given map.
      * @param  {object} map Leaflet map to toggle this layer on
      */
      toggle: function (map) {
        this._active = !this._active;
        if (this.callbackFns && this.callbackFns.onToggleLayerGroup) {
          this.callbackFns.onToggleLayerGroup(this);
        }
      },

      /**
       * Returns true if the current layerGroup (i.e. "this") is active and
       * false otherwise.
       */
      isActive: function () {
        return this._active;
      },

      isTemporal: function () {
        return this.temporal;
      },

      /**
       * Returns true iff the current layerGroup (i.e. "this") has only layers
       * with format 'Vector'.
       */
      isEventLayerGroup: function () {
        if (this.mapLayers.length > 0) {
          return this.mapLayers.every(function (mapLayer) {
            return mapLayer.format === 'Vector';
          });
        } else {
          return false;
        }

      },

      getColorForEventLayerGroup: function () {
        return this.mapLayers[0].color;
      },

     /**
      * @function
      * @memberOf app.LayerGroup.prototype
      * @description Returns a promise that notifies with data for every layer
      *              of the layergroup that is appplicable (i.e: rain and
      *              several vector layers). It resolves when all data is in.
      * @param  {string} callee string of the callee to keep requests seperate.
      * @param  {object} options with geom, start, end and other properties that
      *                          are send to the data-services.
      * @return  {promise} notifies with data per layer and resolves with value
      *                    true when layergroup was active, or false when
      *                    layergroup was inactive.
      */
      getData: function (callee, options) {
        var lgSlug = this.slug,
            lgActive = this._active,
            deferred = $q.defer(),
            promises = [];

        if (!this._active) {
          deferred.resolve({slug: this.slug, active: this._active});
          return deferred.promise;
        }
        else {
          angular.forEach(this._dataLayers, function (layer) {
            promises.push(layer.getData(callee, lgSlug, options, deferred));
          });
        }

        // Bear with me: the promises from the individual getData's(),
        // notify() the defer from LayerGroup.getData() on resolve.
        // When all the individual promises have resolved, this defer
        // should be resolved. It resolves with 'true' to indicate activity
        // of layer. No need to keep a counter of the individual promises.
        $q.all(promises).then(function () {
          deferred.resolve({
            slug: lgSlug,
            active: lgActive
          });
        });

        return deferred.promise;
      },


      /**
       * @function
       * @memberof app.LayerGroup
       * @param {float} new opacity value
       * @return {void}
       * @description Changes opacity in layers that have
       * an opacity to be set
       */
      setOpacity: function (newOpacity) {
        if (typeof newOpacity !== 'number' ||
            newOpacity < 0 && newOpacity > 1) {
          throw new Error(newOpacity + "is not a valid opacity value, it is"
            + "either of the wrong type or not between 0 and 1");
        }
        this._opacity = newOpacity;
        if (this.callbackFns && this.callbackFns.onOpacityChange) {
          this.callbackFns.onOpacityChange(this);
        }
      },

      /**
       * @function
       * @member app.LayerGroup
       * @return {float} opacity from 0 to 1.
       * @description retrieve opacity from layer
       */
      getOpacity: function () {
        return this._opacity;
      },

      /**
       * calls double click callback function when layergroup item in menu
       * is double clicked. Used by the map to rescale.
       */
      dblClick: function () {
        if (this.callbackFns && this.callbackFns.onDblClick) {
          this.callbackFns.onDblClick(this);
        }
      }

    };

    return LayerGroup;
  }
]);

'use strict';


/**
 * @ngdoc service
 * @class NxtData /
 * @memberof app
 * @name NxtData
 * @requires $q, dataLayers, LayerGroup and State
 * @summary Encapsulates layergroups
 * @description NxtData service encapsulates layergroups from the server side
 *              configuration of layergroups. It enables to perform actions
 *              on all layergroups simultaneously. When provided with a string
 *              representation of the service containing the global map it
 *              it performs these actions on the map from this service, else
 *              it needs a map object when calling toggleLayerGroup and
 *              syncTime.
 */

angular.module('data-menu')
  .service('DataService', [
    '$q',
    'TimeseriesService',
    'dataLayers',
    'DataLayerGroup',
    'State',

    function (
      $q,
      TimeseriesService,
      dataLayers,
      DataLayerGroup,
      State
    ) {

      // Attributes ////////////////////////////////////////////////////////////

      // Event callbacks are used to performa actions on the map when the
      // state of layergroups changes, may contain a onOpacityChange, OnDblClick
      // and on layerGroupToggled callback functions.
      Object.defineProperty(this, 'eventCallbacks', {
        set: function (newCallBacks) {
          DataLayerGroup.prototype.callbackFns = newCallBacks;
        }
      });


      /**
       * Creates a new layerGroup and adds to the layerGroups
       * @param  {object} lgConfig config of layergroup
       * @return {layerGroup instance}
       */
      this.createLayerGroup = function (lgConfig) {
        return this.layerGroups[lgConfig.slug] = new DataLayerGroup(lgConfig);
      };

      /**
       * @function
       * @memberof app.NxtMapService
       * @param  {object} nonLeafLayers object from database
       * @description Throw in layers as served from the backend
       */
      this._createLayerGroups = function (serverSideLayerGroups) {
        var layerGroups = {};
        angular.forEach(serverSideLayerGroups, function (sslg) {
          this.createLayerGroup(sslg);
        }, this);
        return this.layerGroups;
      };

      this.layerGroups = {};
      var layerGroups = this._createLayerGroups(dataLayers);

      this.baselayerGroups = _.filter(layerGroups, function (lgValue, lgKey) {
        return lgValue.baselayer;
      });


      // Immutable representation of all layergroups set on State.layerGroups
      Object.defineProperty(State.layerGroups, 'all', {
        value: Object.keys(layerGroups),
        writeable: false,
        configurable: false
      });

      this.REJECTION_REASONS = {};

      Object.defineProperty(this.REJECTION_REASONS, 'OVERRIDDEN', {
        value: 'overridden',
        writeable: false,
        configurable: false
      });

      // List of slugs of active layerGroups, two-way.
      var instance = this;
      Object.defineProperty(State.layerGroups, 'active', {
        get: function () {
          return Object.keys(layerGroups).filter(function (layerGroup) {
            return layerGroups[layerGroup].isActive();
          });
        },
        set: function (newActivelayerGroups) {
          angular.forEach(layerGroups, function (_lg, slug) {
            if (newActivelayerGroups.indexOf(slug) !== -1 && !_lg.isActive()) {
              this.toggleLayerGroup(_lg);
            } else if (_lg.isActive()) {
              this.toggleLayerGroup(_lg);
            }
          }, instance);
        }
      });

      this._dataDefers = {}; // Per callee a list with a defer for every time
                             // getData gets called before the last one
                             // resolves.


      // Methods //////////////////////////////////////////////////////////////

      /**
       * @function
       * @memberOf app.NxtMap
       * @description Toggles a layergroup when layergroups should be toggled
       *              takes into account that baselayers should toggle eachother
       * @param  layerGroup layergroup that should be toggled
       */
      this.toggleLayerGroup = function (layerGroup) {
        // turn layer group on
        if (!(layerGroup.baselayer && layerGroup.isActive())) {
          layerGroup.toggle();
        }
        if (layerGroup.baselayer) {
          angular.forEach(this.layerGroups, function (_layerGroup) {
            if (_layerGroup.baselayer
              && _layerGroup.isActive()
              && _layerGroup.slug !== layerGroup.slug
              )
            {
              _layerGroup.toggle();
            }
          });
        }
      };

      /**
       * Adds the provided layerGroups to the layerGroups
       * @param {layerGroup instance}
       */
      this.addLayergroup = function (layerGroup) {
        return this.layerGroups[layerGroup.slug] = layerGroup;
      };

      /**
       * Removes the provided layerGroups from nxt
       * @param {layerGroup instance}
       */
      this.removeLayerGroup = function (layerGroup) {
        delete this.layerGroups[layerGroup.slug];
        return this.layerGroups;
      };

      /**
       * Gets data from all layergroups.
       *
       * @param  {object} options
       * @param  {str} callee that gets a list of defers for every time getdata
       *                      is called before a request finishes.
       * @param  {defer} recursiveDefer optional. When supplied is notified with
       *                                data. Used for recursively calling get
       *                                data with data from waterchain of a
       *                                previous getData call.
       * @return {promise} notifies with data from layergroup and resolves when
       *                   all layergroups and the timeseries returned data.
       */
      this.getData = function (callee, options, recursiveDefer) {
        var defer = $q.defer();

        if (recursiveDefer === undefined) {
          this.reject(callee, this.REJECTION_REASONS.OVERRIDDEN);
          if (!this._dataDefers[callee]) {
            this._dataDefers[callee] = []; // It is a list because $q.all can not
          }                                // be deregistered.
          var defers = this._dataDefers[callee];
          defers.push(defer); // add to list
        }

        var promises = [];
        var waitForTimeseriesAndEvents = false;
        var instance = this;
        angular.forEach(this.layerGroups, function (layerGroup) {
          promises.push(
            layerGroup.getData(callee, options).then(null, null, function (response) {

              // TS and events are dependent on the waterchain response. So the
              // waterchain response is checked for signs of timeseries. If
              // neccessary we will wait for the timeseries request to finish.
              // Else we keep checking every response.
              if (!waitForTimeseriesAndEvents) {
                waitForTimeseriesAndEvents = instance.getTimeseriesAndEvents(
                  response,
                  options,
                  defer,
                  callee
                );
              }

              if (recursiveDefer) {
                recursiveDefer.notify(response);
              } else {
                defer.notify(response);
              }

            })
          );
        });

        $q.all(promises).then(function () {
          if (waitForTimeseriesAndEvents) {
            waitForTimeseriesAndEvents.then(function () {
              finishDefers();
            });
          } else {
            finishDefers();
          }
        });

        /**
         * @function finishDefers
         * @memberof DataService
         * @summary Checks if current defer is the last one, if so resolves the
         * defer and clears the defers
         */
        var finishDefers = function () {
          // If this defer is the last one in the list of defers the getData
          // is truly finished, otherwise the getData is still getting data for
          // the callee.
          if (recursiveDefer) {
            defer.resolve();
          }
          else if (defers.indexOf(defer) === defers.length - 1) {
            State.layerGroups.gettingData = false;
            defer.resolve(); // Resolve the last one, the others have been
                             // rejected.
            defers.length = 0; // Clear the defers, by using .length = 0 the
                               // reference to this._dataDefers persists.
          }
        };

        State.layerGroups.gettingData = true;
        return defer.promise;
      };

      /**
       * Rejects call for data and sets loading to false.
       */
      this.reject = function (callee, reason) {
        State.layerGroups.gettingData = false;
        if (this._dataDefers[callee]) {
          this._dataDefers[callee].forEach(function (defer) {
            defer.reject(reason);
          });
        }
      };

      /**
       * @function
       * @memberOf app.NxtMap
       * @description Sets the layergroups to the state they came from the
       *              server. Is called by the urlCtrl when no layergroup
       *              info is found on the server
       */
      this.setLayerGoupsToDefault = function () {
        angular.forEach(this.layerGroups, function (layerGroup) {
          if (layerGroup.defaultActive && !layerGroup.isActive()) {
            this.toggleLayerGroup(layerGroup);
          } else if (!layerGroup.defaultActive && layerGroup.isActive()) {
            this.toggleLayerGroup(layerGroup);
          }
        }, this);
      };

      /**
       * Checks response for id and entity_name and passes this
       * getTimeSeriesForObject with start and end.
       *
       * NOTE, TODO: Since now (october 2015) getting timeseries is a job of the
       * timeseries module with a dedicated directive. This code is legacey,
       * used by the time context and for events. This will change when we
       * implement the livedijk xl features.
       *
       * @param  {object} response response from layergroup
       * @param  {int}    start    time start
       * @param  {int}    end      time end
       * @param  {defer}  defer    defer object to notify with timeseries
       * @param  {string} callee   the origin of the data request, specified by
       *                           the function calling DataService.getData.
       *
       * @return {promise || false} false when no id and entity name or promise
       *                            when making request to timeseries endpoint.
       */
      this.getTimeseriesAndEvents = function (
        response,
        options,
        defer,
        callee
      ) {
        if (response.format === 'UTFGrid'
          && response.data
          && response.data.id
          && response.data.entity_name
        ) {
          // Apparently, we're dealing with the waterchain:
          // The defer from getData is recycled, no need to pass a callee param.
          options.type = 'Event';
          options.object = {
            type: response.data.entity_name,
            id: response.data.id
          };
          // Get all events for the provided options and the events belonging to
          // this object.
          var promises = [this.getData(null, options, defer)];

          // LEGACY: getting timeseries is only done for legacy time context.
          // Omnibox uses the timeseries module for this.
          if (callee === 'time') {
            promises.push(TimeseriesService.getTimeSeriesForObject(
              response.data.entity_name + '$' + response.data.id,
              options.start,
              options.end,
              options.minPoints,
              defer
            ));
          }

          return $q.all(promises);
        } else { return false; }
      };

    }
  ]);

/**
 * @ngdoc
 * @class areaCtrl
 * @memberOf app
 * @name areaCtrl
 * @description
 * area is the object which collects different
 * sets of aggregation data. If there is no activeObject,
 * this is the default collection of data to be shown in the
 * client.
 *
 * Contains data of all active layers with an aggregation_type
 *
 */
angular.module('data-menu')
  .controller('DatamenuController',
              ['$scope', 'DataService', 'State', 'MapService', 'UtilService',
               function ($scope, DataService, State, MapService, UtilService) {

    this.layerGroups = DataService.layerGroups;

    this.toggleLayerGroup = DataService.toggleLayerGroup;

    this.box = State.box;

    this.enabled = false;

    this.state = State.layerGroups;

    // move this function to service.
    this.zoomToBounds = function (spatialBounds, temporalBounds) {

      // zoom to spatial bounds
      MapService.fitBounds(spatialBounds);

      // zoom to temporal bounds
      if (temporalBounds.start !== temporalBounds.end) {
        State.temporal.start = temporalBounds.start;
        State.temporal.end = temporalBounds.end;
        State.temporal.at = temporalBounds.start;
        UtilService.announceMovedTimeline(State);
      }
    };
  }
]);


'use strict';

/**
 * Data menu directive
 *
 * Overview
 * ========
 *
 * Defines the data menu.
 */
angular.module('data-menu')
  .directive('datamenu', [function () {

    var link = function (scope, element, attrs) {
    };


    return {
      link: link,
      restrict: 'E',
      replace: true,
      templateUrl: 'data-menu/data-menu.html'
    };

  }
]);
'use strict';

/**
 * @ngdoc controller
 * @class UrlController
 * @memberof app
 * @name UrlController
 * @summary Sets and gets the url to the state and vice versa.
 * @description UrlController reacts to $locationChangeSucces to read
 * the url and configure lizard-nxt state accordingly. Writes state
 * changes to url. At initial load of app, url leads. Afterwards the
 * state leads the url.
 */
angular.module('lizard-nxt')
.controller('UrlController', [
  '$scope',
  '$timeout',
  'LocationGetterSetter',
  'UrlState',
  'UtilService',
  'dataBounds',
  'defaultLocale',
  'DataService',
  'MapService',
  'NxtRegionsLayer',
  'State',
  '$rootScope',
  'LeafletService',
  'gettextCatalog',
  function (
    $scope,
    $timeout,
    LocationGetterSetter,
    UrlState,
    UtilService,
    dataBounds,
    defaultLocale,
    DataService,
    MapService,
    NxtRegionsLayer,
    State,
    $rootScope,
    LeafletService,
    gettextCatalog
  ) {

    // Configuration object for url state.
    var state = {
      language: {
        part: 'path',
        index: 0
      },
      context: { // Locally used name for the state
        value: 'map', // default
        part: 'path', // Part of the url where this state is stored,
        index: 1, // Position of the state in the part
      },
      layerGroups: {
        part: 'path',
        index: 2,
      },
      boxType: {
        part: 'path',
        index: 3,
      },
      geom: {
        part: 'path',
        index: 4,
      },
      mapView: {
        part: 'at',
        index: 0,
      },
      timeState: {
        part: 'at',
        index: 1,
      }
    };

   /**
    * @function
    * @memberOf app.UrlController
    * @summary Enables or disables layerGroups on the basis of the url.
    * @description Takes the layerGroups as defined in the url to turn
    *              layerGroups on afterwards it initializes all other
    *              layerGroups. This is done here so MapService does not turn
    *              on layerGroups which are turned of later by this controller.
    * @param {string} String representation of layerGroups on url
    */
    var enablelayerGroups = function (layerGroupString) {
      if (layerGroupString) {
        // Either layerGroups are on url
        State.layerGroups.active = layerGroupString.split(',');
        // Or layerGroups are not on url, turn default layerGroups on
      } else {
        DataService.setLayerGoupsToDefault();
      }
      UrlState.setlayerGroupsUrl(state, State.layerGroups.active);
    };

   /**
    * @function
    * @memberOf app.UrlController
    * @summary Sets the mapView on the url or the url on the mapView
    * @description If mapView as string from the url is a parseable
    *              mapView, the map is set to this view. Else the map
    *              is set to bounds of data as defined by the server.
    * @param {string} String representation of mapView on url
    */
    var enableMapView = function (mapView) {
      var defaultBounds = LeafletService.latLngBounds(
        L.latLng(dataBounds.south, dataBounds.east),
        L.latLng(dataBounds.north, dataBounds.west)
      );

      if (mapView) {
        var view = UrlState.parseMapView(mapView);
        if (view) {
          State.spatial.view = {
            lat: view.latLng[0],
            lng: view.latLng[1],
            zoom: view.zoom
          };
        } else {
          State.spatial.bounds = defaultBounds;
        }
      } else {
        State.spatial.bounds = defaultBounds;
      }
    };

    /**
     * Attempts to set the language based on what is provided, what is the
     * Injected default value or the hardcoded value in this function.
     *
     * If all fails, their will be no translation and all text will be in
     * English.
     *
     * @param {str} lang language code according to ISO-639-1.
     */
    var setLanguage = function (lang) {
      var defaultLang = State.language;

      if (lang === undefined && defaultLocale) {
        lang = defaultLocale.slice(0,2); // language is the first 2 places of
                                         // locale e.g.: nl_NL;
      } else if (lang === undefined) {
        lang = defaultLang;
      }

      // Check if this language exists, otherwise use the default.
      if (!gettextCatalog.strings[lang]
        && lang !==gettextCatalog.baseLanguage) {
        lang = defaultLang;
      }

      gettextCatalog.setCurrentLanguage(lang);

      // Store language in global state object. Among other, it is used for
      // searchresults.
      State.language = lang;
    };

    /**
     * set layer(s) when these change.
     */
    $scope.$watch(State.toString('layerGroups.active'),
      function (n, o) {
        if (n === o) { return true; }
        UrlState.setlayerGroupsUrl(state, State.layerGroups.active);
      }
    );

    /**
     * Set location when map moved.
     */
    $scope.$watch(State.toString('spatial.bounds'), function (n, o) {
      if (n === o || !State.spatial.view.lat) { return true; }
      UrlState.setCoordinatesUrl(state,
        State.spatial.view.lat,
        State.spatial.view.lng,
        State.spatial.view.zoom
      );
    });

    /**
     * Set timeState, when timeState changed. The helper serves eliminating
     * redundant code, within this file.
     */
    var setTimeStateUrlHelper = function () {
      if (!State.temporal.timelineMoving) {
        UrlState.setTimeStateUrl(
          state,
          State.temporal.start,
          State.temporal.end
        );
      }
    };

    /**
     * Set timeState, when timeState changed in response to panning/zooming the
     * timeline and in response to the user clicking the 3 timeline buttons.
     */
    $scope.$watch(State.toString('temporal.timelineMoving'), function (n, o) {
      if (n === o) { return true; }
      setTimeStateUrlHelper();
    });

    /*
     * Set boxType when box.type changed
     */
    $scope.$watch(State.toString('box.type'), function (n, old) {
      if (n === old) { return true; }
      LocationGetterSetter.setUrlValue(
        state.boxType.part, state.boxType.index, State.box.type
      );

      if (old === 'point' || old === 'line' || old === 'region') {
        // Remove geometry from url
        state.boxType.update = false;
        LocationGetterSetter.setUrlValue(
          state.geom.part, state.geom.index, undefined);
      }

    });

    /*
     * Set context when context changed
     */
    $scope.$watch(State.toString('context'), function (n, old) {
      if (n === old) { return true; }
      state.context.update = false;
      LocationGetterSetter.setUrlValue(
        state.context.part, state.context.index, $scope.context
      );
    });

    /**
     * Set geom when mapState.here changed and box.type is point.
     */
    $scope.$watch(State.toString('spatial.here'), function (n, o) {
      if (n === o || State.box.type !== 'point') { return true; }
      state.geom.update = false;
      UrlState.setgeomUrl(
        state,
        State.box.type,
        State.spatial.here,
        State.spatial.points
      );
    });

    /**
     * Set geom when mapState.points changed and box.type is line.
     */
    $scope.$watch(State.toString('spatial.points'), function (n, o) {
      if (n === o || State.box.type !== 'line') { return true; }
      UrlState.setgeomUrl(state,
        State.box.type,
        State.spatial.here,
        State.spatial.points
      );
    });

    /**
     * Set region when State.spatial.region changed and box.type is region.
     */
    $scope.$watch(State.toString('spatial.region'), function (n, o) {
      if (n === o || State.box.type !== 'region') { return true; }
      if (State.spatial.region.properties) {
        LocationGetterSetter.setUrlValue(
          state.geom.part, state.geom.index, State.spatial.region.properties.name
        );
      } else {
        LocationGetterSetter.setUrlValue(
          state.geom.part, state.geom.index, ''
        );
      }
    });

    /**
     * Set the state from the url on init or set the url from the default state
     * when the url is empty.
     */
    var setStateFromUrl = function () {
      var language = LocationGetterSetter.getUrlValue(state.language.part, state.language.index),
        boxType = LocationGetterSetter.getUrlValue(state.boxType.part, state.boxType.index),
        geom = LocationGetterSetter.getUrlValue(state.geom.part, state.geom.index),
        layerGroupsFromURL = LocationGetterSetter.getUrlValue(state.layerGroups.part, state.layerGroups.index),
        mapView = LocationGetterSetter.getUrlValue(state.mapView.part, state.mapView.index),
        time = LocationGetterSetter.getUrlValue(state.timeState.part, state.timeState.index),
        context = LocationGetterSetter.getUrlValue(state.context.part, state.context.index);

      setLanguage(language);

      LocationGetterSetter.setUrlValue(
        state.language.part,
        state.language.index,
        gettextCatalog.getCurrentLanguage()
      );

      if (context) {
        // Set context after digest loop because we need to enter on 'map'
        $timeout(
          function () {
            $scope.transitionToContext(context);
          },
          0, // no delay, fire when digest ends
          true // trigger new digest loop
        );
      } else {
        LocationGetterSetter.setUrlValue(state.context.part, state.context.index, state.context.value);
      }

      if (boxType) {
        State.box.type = boxType;
      } else {
        LocationGetterSetter.setUrlValue(state.boxType.part, state.boxType.index, State.box.type);
      }

      if (geom) {
        if (/\d/.test(geom)) {
          State.spatial = UrlState.parseGeom(State.box.type, geom, State.spatial);
        } else {
          NxtRegionsLayer.setActiveRegion(geom);
        }
      }

      enablelayerGroups(layerGroupsFromURL);
      enableMapView(mapView);

      if (time) {
        State.temporal = UrlState.parseTimeState(time, State.temporal);
      } else {
        state.timeState.update = false;
        UrlState.setTimeStateUrl(state, State.temporal.start, State.temporal.end);
      }

      UtilService.announceMovedTimeline(State);

    };

    setStateFromUrl();

  }
]);


/**
 * @class LocationGetterSetter
 * @memberOf app
 *
 * @summary Lower level service to set $location.
 *
 * @description
 * Provides a setter and getter function to manipulate parts of the url to
 * keep the url synchronised with the actual application state. That way
 * you can use the url to share application state.
 */
angular.module('lizard-nxt')
  .service('LocationGetterSetter', ['$location', function ($location) {

    var _getPath, _getPathParts,

    service = {

     /**
      * @function
      * @memberOf angular.module('lizard-nxt').LocationGetterSetter
      * @description returns the value in the path of url at the specified part
      * @param {str} part, part url looking for currently <path | @>
      * @param {str} index location in the part
      * @return {str} value
      */
      getUrlValue: function (part, index) {
        if (!(part === 'path' || part === 'at')) {
          throw new Error(String(part) + ' is not a supported part of the url');
        }
        var pathParts = _getPathParts(part);
        var value = pathParts[index] === '' ? undefined : pathParts[index];
        return value;
      },

     /**
      * @function
      * @memberOf angular.module('lizard-nxt').LocationGetterSetter
      * @description sets the value in the path of url at the specified part
      * @param {str} part, part url looking for currently <path | @>
      * @param {str} index location in the part
      * @param {str} value
      */
      setUrlValue: function (part, index, value) {
        if (!(part === 'path' || part === 'at')) {
          throw new Error(String(part) + ' is not a supported part of the url');
        }
        if (value && !(typeof(value) === 'string' || typeof(value) === 'number')) {
          throw new Error(String(value) + ' cannot be set on the url');
        }
        var halfPath, otherHalf, parts = _getPathParts(part);
        if (!value && parts.length - 1 === index) {
          parts.splice(index, 1); // remove if no value and index is last one.
        } else {
          parts[index] = value; //replace
        }
        halfPath = parts.join('/');
        if (part === 'path') {
          otherHalf = _getPath('at') ? '@' + _getPath('at') : '';
          $location.path('/' + halfPath + otherHalf);
        } else {
          otherHalf = _getPath('path') ? _getPath('path') + '@' : '@';
          $location.path('/' + otherHalf + halfPath);
        }
      }
    };

   /**
    * @function
    * @memberOf angular.module('lizard-nxt')
  .LocationGetterSetter
    * @description returns the part of the path without first slash.
    * @param {str} part, part url looking for currently <path | @>
    * @return {str} the part the path.
    */
    _getPath = function (part) {

      var paths,
          pathPart,
          path = $location.path();

      paths = path.split('@'); //splits path in two at the @.
      pathPart = paths[part === 'path' ? 0 : 1] || ''; //gets before @ when 'path' after when 'at'
      // we do not want the first slash
      pathPart = part === 'path' ? pathPart.slice(1) : pathPart;
      return pathPart;
    };

   /**
    * @function
    * @memberOf angular.module('lizard-nxt')
  .LocationGetterSetter
    * @description splits the part of the path further in individual values.
    * @param {str} part of the path without first slash.
    * @return {array} the values in the part of the path.
    */
    _getPathParts = function (part) {
      var pathPart = _getPath(part);
      if (!pathPart) { return []; }
      return pathPart.split('/');
    };
    return service;
  }]);


/**
 * @ngdoc service
 * @class UrlState
 * @name UrlState
 * @description Higher level functions to parse and set URL.
 */
angular.module('lizard-nxt')
  .service("UrlState", ["LocationGetterSetter", "UtilService", function (LocationGetterSetter, UtilService) {

    // Amount of decimals of coordinates stored in url.
    var COORD_PRECISION = 4;

    var service = {

     /**
      * @function
      * @memberOf angular.module('lizard-nxt').UrlState
      * @description Sets the points or the here on the url when
      *              respectively point or line is specified as type.
      * @param {object} state config object
      * @param {str} type box.type
      * @param {object} here leaflet LatLng object
      * @param {array} points array of leaflet LatLng objects
      */
      setgeomUrl: function (state, type, here, points) {
        var pointsStr = '';
        if (type === 'line') {
          angular.forEach(points, function (point) {
            pointsStr += point.lat.toFixed(COORD_PRECISION) + ',' + point.lng.toFixed(COORD_PRECISION) + '-';
          });
          pointsStr = pointsStr.substring(0, pointsStr.length - 1);
        } else {
          pointsStr = here === undefined
            ? ''
            : here.lat.toFixed(COORD_PRECISION) + ',' + here.lng.toFixed(COORD_PRECISION);
        }
        LocationGetterSetter.setUrlValue(state.geom.part, state.geom.index, pointsStr);
      },

     /**
      * @function
      * @memberOf angular.module('lizard-nxt')
  .UrlState
      * @description Sets the start and end epoch ms on the url
      * @param {object} state config object
      * @param {int} start time in ms
      * @param {int} end time in ms
      */
      setTimeStateUrl: function (state, start, end) {
        var startDate = new Date(start);
        var endDate = new Date(end);
        var startDateString = startDate.toDateString()
          .slice(4) // Cut off day name
          .split(' ') // Replace spaces by hyphens
          .join(',');
        var endDateString = endDate.toDateString()
          .slice(4) // Cut off day name
          .split(' ') // Replace spaces by hyphens
          .join(',');
        LocationGetterSetter.setUrlValue(
          state.timeState.part,
          state.timeState.index,
          startDateString + '-' + endDateString);
      },

     /**
      * @function
      * @memberOf angular.module('lizard-nxt')
  .UrlState
      * @description Sets the mapView coordinates on the url.
      * @param {object} state config object
      * @param {object} lat leaflet Latitude object
      * @param {object} lng leaflet Lng object
      * @param {int} zoom level
      */
      setCoordinatesUrl: function (state, lat, lng, zoom) {
        var COORD_PRECISION = 4;
        var newHash = [
          lat.toFixed(COORD_PRECISION),
          lng.toFixed(COORD_PRECISION),
          zoom
        ].join(',');
        LocationGetterSetter.setUrlValue(
          state.mapView.part,
          state.mapView.index,
          newHash);
      },

      /**
       * @function
       * @memberOf angular.module('lizard-nxt')
  .UrlState
       * @description Sets the layer slugs on the url.
       * @param {object} state config object
       * @param {object} layerGroups list
       */
      setlayerGroupsUrl: function (state, layerGroups) {
        if (layerGroups === undefined) { return; }
        LocationGetterSetter.setUrlValue(
          state.layerGroups.part,
          state.layerGroups.index,
          layerGroups.toString()
        );
      },
      /**
       * @function
       * @memberOf angular.module('lizard-nxt')
  .UrlState
       * @description Sets the layer slugs on the url.
       * @param  {str} time time value of the url
       * @param  {object} timeState nxt timeState
       * @return {object} nxt timeState
       */
      parseTimeState: function (time, timeState) {
        // Browser independent. IE requires datestrings in a certain format.
        var times = time.replace(/,/g, ' ').split('-');
        var msStartTime = Date.parse(times[0]);
        // bail if time is not parsable, but return timeState
        if (isNaN(msStartTime)) { return timeState; }
        timeState.start = msStartTime;

        var msEndTime = Date.parse(times[1]);
        if (isNaN(msEndTime)) { return timeState; }
        if (msEndTime <= timeState.start) {
          msEndTime = timeState.start + 43200000; // half a day
        }
        timeState.end = msEndTime;
        timeState.aggWindow = UtilService.getAggWindow(
          timeState.start,
          timeState.end,
          UtilService.getCurrentWidth()
        );
        var timeAt = timeState.start + (timeState.end - timeState.start) / 2;
        timeState.at = UtilService.roundTimestamp(
          timeAt,
          timeState.aggWindow,
          true
        );
        return timeState;
      },
      /**
       * @function
       * @memberOf angular.module('lizard-nxt')
  .UrlState
       * @description returns the mapview value parsed to
       *              latlonzoom
       * @param  {str} mapView
       * @return {object_or_false} Lat lon zoom object or false
       *                               when not valid.
       */
      parseMapView: function (mapView) {
        var latlonzoom = mapView.split(',');
        if (latlonzoom.length === 3
          && parseFloat(latlonzoom[0])
          && parseFloat(latlonzoom[1])
          && parseFloat(latlonzoom[2])) {
          return {
            latLng: [parseFloat(latlonzoom[0]), parseFloat(latlonzoom[1])],
            zoom: parseFloat(latlonzoom[2]),
            options: {reset: true, animate: true}
          };
        } else {
          return false;
        }
      },
      parseGeom: function (type, geom, mapState) {
        if (type === 'point') {
          var point = geom.split(',');
          if (parseFloat(point[0]) &&
              parseFloat(point[1])) {
            mapState.here = L.latLng(point[0], point[1]);
          }
        } else if (type === 'line') {
          var points = geom.split('-');
          angular.forEach(points, function (pointStr, key) {
            var point = pointStr.split(',');
            if (parseFloat(point[0]) &&
                parseFloat(point[1])) {
              mapState.points[key] = L.latLng(point[0], point[1]);
            }
          });
        }
        return mapState;
      },
      update: function (state) {
        var u = true;
        angular.forEach(state, function (value) {
          if (!value.update) {
            u = false;
          }
        });
        return u;
      }
    };

    return service;

  }
]);

angular.module('map', [
  'global-state',
  'data-menu'
]);

'use strict';

/**
 * @ngdoc service
 * @name map.NxtRegionsLayer
 * @description
 * Adds a leaflet geojson layer to draw regions.
 */
angular.module('map')
.factory('NxtRegionsLayer', [
  'MapService',
  'CabinetService',
  'LeafletService',
  function (MapService, CabinetService, LeafletService) {

    // Leaflet geojson layer.
    var regionsLayer;

    // String of feature.properties.name that should be active.
    var activeRegionString;

    // ILayer of last region that recieved click.
    var previousActiveLayer;

    var deafaultRegionStyle = {
      weight: 2,
      opacity: 0.6,
      color: '#7f8c8d', // asbestos
      fillOpacity: 0
    };

    var mouseOverStyle = {
      fillColor: '#e74c3c', // alizarin
      fillOpacity: 0.1
    };

    var activeRegionStyle = {
      weight: 4,
      fillColor: '#e74c3c', // alizarin
      color: '#c0392b', // pomegranate
      dashArray: '6',
      fillOpacity: 0.1
    };

    /**
     * Draws regions as a L.geoJson layer on the map. Sets click function. And
     * Fires click if ActiveRegionString is not falsy.
     *
     * @param  {geojson}  regions
     * @param  {funciton} clickCb callback fires when layer is clicked.
     */
    var addRegions = function (regions, clickCb) {
      MapService.removeLeafletLayer(regionsLayer);
      regionsLayer = LeafletService.geoJson(regions, {
        // Style function must be included in order to overwrite style on click.
        style: function (feature) {
          return deafaultRegionStyle;
        },
        onEachFeature: function (d, layer) {
          layer.on({
            mouseover: function (e) {
              var layer = e.target;

              layer.setStyle(mouseOverStyle);

            },
            mouseout: function (e) {
              if (e.target.feature.properties.name !== activeRegionString) {
                regionsLayer.resetStyle(e.target);
              }
            },
            click: function (e) {

              if (previousActiveLayer) {
                regionsLayer.resetStyle(previousActiveLayer);
              }

              var newActiveLayer = e.target;
              newActiveLayer.setStyle(activeRegionStyle);

              clickCb(this);

              activeRegionString = newActiveLayer.feature.properties.name;
              previousActiveLayer = newActiveLayer;
            }
          });
        }
      });
      MapService.addLeafletLayer(regionsLayer);
      if (activeRegionString) { setActiveRegion(activeRegionString); }
    };

    /**
     * Removes the regions from the map and sets activeRegioString to null.
     */
    var removeRegions = function () {
      activeRegionString = null;
      MapService.removeLeafletLayer(regionsLayer);
    };

    /**
     * Sets the activeRegion, by firing a click when regionsLayer exists, or
     * sets activeRegionString that triggers a call of this function onload.
     *
     * @param {string} region properties.name of region.
     */
    var setActiveRegion = function (region) {
      if (regionsLayer) {
        var layer = _getRegion(regionsLayer, region);
        if (layer) {
          layer.fire('click');
        }
        else {
          activeRegionString = null;
        }
      } else {
        activeRegionString = region;
      }
    };

    var getActiveRegion = function () {
      return activeRegionString;
    };

    /**
     * Gets region layer with properties.name === regionName of the currently
     * drawn regions.
     *
     * @param  {L.GeoJson} lGeo        Leaflet L.GeoJson instance.
     * @param  {string} regionName     Properties.name of region
     * @return {L.ILayer || undefined} Region layer.
     */
    var _getRegion = function (lGeo, regionName) {
      var region;
      lGeo.eachLayer(function (layer) {
        if (layer.feature.properties.name === regionName) {
          region = layer;
        }
      });
      return region;
    };

    return {
      add: addRegions,
      remove: removeRegions,
      setActiveRegion: setActiveRegion,
      getActiveRegion: getActiveRegion
    };

  }]
);

'use strict';

/**
 * @ngdoc service
 * @name lizard-nxt.Layer
 * @description
 *
 * Non tiled wms layers use a bounding box to make request to a wms for one tile
 * which is displayed as a leaflet image overlay. Nxt-non-tiled-wms-layer is
 * used to create a wms layer that is animatable. When synced to time, it builds
 * a buffer of images, fills the buffer with new images or turns one of the
 * images from the buffer on and start loading a new image in the place of the
 * previous.
 *
 * Usage: add animation functionality to an instance NxtLayer by using
 * NxtNonTiledWMSLayer.create(<layer>);
 *
 */
angular.module('map')
.factory('NxtNonTiledWMSLayer', [
  'NxtLayer',
  'LeafletService',
  'RasterService',
  'UtilService',
  '$http',
  '$q',
  function (NxtLayer, LeafletService, RasterService, UtilService, $http, $q) {

      /**
       * @function
       * @memberof app.LayerGroup
       * @param {L.Class} Leaflet layer.
       * @description Adds layer to map
       */
      var addLeafletLayer = function (map, leafletLayer) { // Leaflet NxtLayer
        if (map.hasLayer(leafletLayer)) {
          throw new Error(
            'Attempted to add layer' + leafletLayer._id
            + 'while it was already part of the map'
          );
        } else {
          map.addLayer(leafletLayer);
        }
        return leafletLayer;
      };

      /**
       * @function
       * @memberof app.LayerGroup
       * @param  {L.Class} Leaflet map
       * @param  {L.Class} Leaflet layer
       * @description Removes layer from map
       */
      var removeLeafletLayer = function (map, leafletLayer) { // Leaflet NxtLayer
        if (map.hasLayer(leafletLayer)) {
          map.removeLayer(leafletLayer);
        } else {
          throw new Error(
            'Attempted to remove layer' + leafletLayer._id
            + 'while it was NOT part of provided the map'
          );
        }
      };

      return {
        create: function (layer) {

          // Array of imageoverlays used as buffer.
          Object.defineProperty(layer, '_imageOverlays', {
            value: [],
            writable: true,
          });
          // Formatter used to format a data object.
          Object.defineProperty(layer, '_formatter', {
            value: d3.time.format.utc("%Y-%m-%dT%H:%M:%S"),
            writable: true,
          });
          // Base of the image url without the time.
          Object.defineProperty(layer, '_imageUrlBase', {
            value: '',
            writable: true,
          });
          // Lookup to store which data correspond to which imageOverlay.
          Object.defineProperty(layer, '_frameLookup', {
            value: {},
            writable: true,
          });
          // Length of the buffer, set in the initialization. Ideally the buffer
          // is small to get up to speed fast, for slow connections or high
          // frequent images it should be large. When having a very sparse
          // resolution, animation will also move slowly, so there is no need
          // for a big buffer.
          Object.defineProperty(layer, '_bufferLength', {
            value: layer._temporalResolution >= 3600000 ? 2 : 6,
            writable: true,
          });
          // Number of rasters currently underway.
          Object.defineProperty(layer, '_nLoadingRasters', {
            value: 0,
            writable: true,
          });

          angular.extend(layer, {

            /**
             * @description Adds one imageOverlay with the current time to the map.
             * @return a promise that resolves when the image has loaded. Usefull
             *         for sequential loading of layers.
             */
            add: function (map, optionalDefer) {

              var defer = optionalDefer || $q.defer(),
                  opacity = this._opacity,
                  date = new Date(this._mkTimeStamp(this.timeState.at)),
                  store = this._determineStore(this.timeState);

              var options = {
                layers: store.name,
                format: 'image/png',
                version: '1.1.1',
                minZoom: layer.min_zoom || 0,
                maxZoom: 19,
                opacity: layer.opacity,
                zIndex: layer.zIndex,
                crs: LeafletService.CRS.EPSG3857,
                time: this._formatter(date)
              };

              options = angular.extend(options, layer.options);

              // This breaks styles with negative values
              // and for the moment only applies to radar.
              if (this.slug.split('/')[0] === 'radar') {
                this.options.styles = this.options.styles.split('-')[0]
                  + '-'
                  + store.name.split('/')[1];
              }

              this._imageOverlays = [
                LeafletService.tileLayer.wms(layer.url, options)
              ];

              // defer is passed to loadlistener to be resolved when done.
              this._addLoadListener(
                this._imageOverlays[0].addTo(map),
                this.timeState.at,
                defer
              );

              return defer.promise;
            },

            /**
             * @summary    Sets the new timeState on the layer. And updates the layer
             *             to the new time.
             *
             * @parameter timeState nxt object containing current time on at.
             * @parameter map leaflet map to add layers to.
             *
             * @return a promise that resolves when the layer has finished
             *         syncing. It is considered finished when it finishes loading
             *         a new buffer or when it was able to set a new frame from its
             *         buffer.
             */
            syncTime: function (timeState, map) {
              var defer = $q.defer();

              // Resolve and return when nothing changed.
              if (timeState.at === this.timeState.at
                && timeState.aggWindow === this.timeState.aggWindow
                && timeState.playing === this.timeState.playing) {
                defer.resolve();
                return defer.promise;
              }

              // Store copy no reference.
              this.timeState = angular.copy(timeState);

              // this only works for stores with different aggregation levels
              // for now this is only for the radar stores
              // change image url based on timestate.
              var store = this._determineStore(this.timeState);

              this._temporalResolution = store.resolution;

              // This breaks styles with negative values
              // and for the moment only applies to radar.
              if (this.slug.split('/')[0] === 'radar') {
                this.options.styles = this.options.styles.split('-')[0]
                  + '-'
                  + store.name.split('/')[1];
              }

              this._syncToNewTime(timeState, map, defer);

              return defer.promise;
            },

            /**
             * @description removes all _imageOverlays from the map. Removes
             *              listeners from the _imageOverlays, the _imageOverlays
             *              from this layer and removes the references to
             *              the _imageOverlays.
             */
            remove: function (map) {
              for (var i in this._imageOverlays) {
                if (map.hasLayer(this._imageOverlays[i])) {
                  this._imageOverlays[i].off('load');
                  map.removeLayer(this._imageOverlays[i]);
                }
              }
              this._nLoadingRasters = 0;
              this._imageOverlays = [];
              this._frameLookup = {};
            },

            /**
             * @description sets the provided opacity to the layer and all the
             *              _imageOverlays that have an opacity other than 0. Sets
             *              the opacity to nearly 0 when the provided opacity is
             *              exactly 0 in order to distinguish layers that are off
             *              and layers that have are transparant.
             */
            setOpacity: function (opacity) {
              if (opacity === 0) { opacity = 0.1; }
              this._opacity = opacity;
              angular.forEach(this._frameLookup, function (frameIndex) {
                if (this._imageOverlays[frameIndex].options.opacity !== 0) {
                  this._imageOverlays[frameIndex].setOpacity(this._opacity);
                }
              }, this);
              return;
            },

            /**
             * Takes a new timeState and delegates to sync functions for
             * animation or non-animation.
             * @param  {object} map         leaflet map
             * @param  {int}    currentDate ms from epoch
             * @param  {object} defer       defer to resolve when done
             */
            _syncToNewTime: function (timeState, map, defer) {
              var currentDate = this._mkTimeStamp(timeState.at);
              if (timeState.playing) {
                this._animateSyncTime(map, currentDate, defer);
              }
              else {
                this._tiledSyncTime(map, currentDate, defer);
              }
            },

            /**
             * syncToTime with a tiled layer. Simpy removes everything and uses
             * add method to create a new tiled layer
             * @param  {object} map         leaflet map
             * @param  {int}    currentDate ms from epoch
             * @param  {object} defer       defer to resolve when done
             */
            _tiledSyncTime: function (map, currentDate, defer) {
              this.remove(map);
              this.add(map, defer);
            },

            /**
             * syncToTime with imageOverlays for animation. See syncTime docstr
             * for more info.
             *
             * @decription When there are not enough or the imageOverlays have
             *             an outdated bounds, more overlays are added to the
             *             map. The curent timeState.at is rounded
             *             to the nearest date value present on the wms server. The
             *             currentDate value is used to lookup the index of the
             *             frame in the _frameLookup. The _frameLookup contains all
             *             the dates that are present in the buffer and the index
             *             of the imageoverlay it is stored on:
             *
             *               { <date in ms from epoch> : <index on _imageOverlays> }
             *
             *               length is 0, 1 or _bufferLength.
             *
             *             The date is either: 1. present in the lookup in case the
             *             index is defined or 2. not present in case this frame is
             *             not loaded yet.
             *
             *             When 1. The imageOverlay with index <currentOverlayIndex>
             *             is set to _opacity and the defer is resolved. The image
             *             sources of the _imageOverlays with opacity !== 0 are set
             *             to the next date not in the _frameLookup, the opacity is
             *             set to 0 and the reference is removed from the
             *             _frameLookup. A loadListener adds a new reference to the
             *             _frameLookup when the layer finishes loading a new frame.
             *
             *             When 2. All references are removed and all layers get a
             *             new source. When the new source is different than the one
             *             it currently has, the loadListener is removed and a new
             *             one source and loadlistener are added. When all layers
             *             have loaded, the first layer's opacity is set to _opacity
             *             and the defer is resolved.
             *
             * @param  {object} map         leaflet map
             * @param  {int}    currentDate ms from epoch
             * @param  {object} defer       defer to resolve when done
             */
            _animateSyncTime: function (map, currentDate, defer) {
              var newBounds = this._getAnimationBounds(map);

              if (this._imageOverlays.length < this._bufferLength
                || newBounds.getNorth() !== this._animationBounds.getNorth()
                || newBounds.getWest() !== this._animationBounds.getWest()) {
                this._animationBounds = newBounds;

                // add leaflet layers to fill up the buffer and set imageUrlBase
                // which depends on the bounds of the map and the layer and the
                // store that corresponds to the timeState.

                var store = this._determineStore(this.timeState);

                var options = {
                  bounds: this._animationBounds,
                  size: this._getImageSize(map, this._animationBounds)
                };

                this._imageUrlBase = RasterService.buildURLforWMS(
                  this,
                  map,
                  store.name,
                  this.timeState.playing,
                  options
                );

                this._imageOverlays = this._createImageOverlays(
                  map,
                  this._bufferLength,
                  this._animationBounds
                );
              }

              var currentOverlayIndex = this._frameLookup[currentDate];

              if (currentOverlayIndex === undefined) {
                // Ran out of buffered frames
                this._imageOverlays = this._fetchNewFrames(
                  currentDate,
                  this._imageOverlays,
                  defer
                );
              }

              else {
                this._progressFrame(currentOverlayIndex);
                // Done!
                defer.resolve();
              }

            },

            /**
             * @description Adds new imageoverlays.
             * @param  {L.Map} map.
             * @param  {overlays} overlays current overlays to add to.
             * @param  {bounds} bounds   bounds of overlays.
             * @param  {int} buffer   amount of imageOverlays to include.
             * @return {array} array of L.imageOverlays.
             */
            _createImageOverlays: function (map, buffer, bounds) {
              // detach all listeners and references to the imageOverlays.
              this.remove(map);
              // create new ones.
              for (var i = this._imageOverlays.length; i < buffer; i++) {
                this._imageOverlays.push(
                  addLeafletLayer(map, LeafletService.imageOverlay('', bounds))
                );
              }
              return this._imageOverlays;
            },

            /**
             * Takes the bounds of the map and creates an intersection of the
             * layer and the map for animation.
             *
             * @param  {L.Map} map with getBounds
             * @return {L.LatLngBounds} leaflet bounds of intersection
             */
            _getAnimationBounds: function (map) {
              var mapBounds = map.getBounds();

              var smallestSoutWest = LeafletService.latLng(
                Math.max(this.bounds.south, mapBounds.getSouth()),
                Math.max(this.bounds.west, mapBounds.getWest())
              );

              var smallesNorthEast = LeafletService.latLng(
                Math.min(this.bounds.north, mapBounds.getNorth()),
                Math.min(this.bounds.east, mapBounds.getEast())
              );

              return LeafletService.latLngBounds(
                smallestSoutWest,
                smallesNorthEast
              );

            },

            /**
             * Determines the pixel size of the imageoverlay on the map.
             *
             * @param  {L.Map} map
             * @param  {L.LatLngBounds} animationBounds intersection of map
             *                          bounds and layer bounds.
             *
             * @return {object with x and y} size in horizontal (x) and
             *                               vertical (y) direction.
             */
            _getImageSize: function (map, animationBounds) {
              var bottomLeft = map.latLngToContainerPoint(
                animationBounds.getSouthWest()
              );

              var topRight = map.latLngToContainerPoint(
                animationBounds.getNorthEast()
              );

              return {
                x : topRight.x - bottomLeft.x,
                y: bottomLeft.y- topRight.y
              };
            },

            /**
             * Local helper that returns a rounded timestamp
             */
            _mkTimeStamp: function (t) {
              var result = UtilService.roundTimestamp(t, this._temporalResolution, false);
              return result;
            },

            /**
             * @description based on the temporal window. The time between
             * timestate.start and timestate.end determines which store is to be used.
             * This only works for radar stuff.
             *
             */
            _determineStore: function (timeState) {

              if (this.slug.split('/')[0] !== 'radar') {
                return {
                  name: layer.slug,
                  resolution: layer._temporalResolution
                };
              }

              var resolutionHours = (timeState.aggWindow) / 60 / 60 / 1000;

              var aggType = this.slug.split('/');

              if (resolutionHours >= 24) {
                aggType[1] = 'day';
              } else if (resolutionHours >= 1 && resolutionHours < 24) {
                aggType[1] = 'hour';
              } else {
                aggType[1] = '5min';
              }
              var resolutions = {
                '5min': 300000,
                'hour': 3600000,
                'day': 86400000
              };

              return {
                name: aggType.join('/'),
                resolution: resolutions[aggType[1]]
              };

            },


            /**
             * @description Removes old frame by looking for a frame that has an
             *              opacity that is not 0 and setting it to 0, deleting it
             *              from the lookup and replacing the image source. NewFrame
             *              is turned on by setting opacity to _opacity.
             * @param {int} currentOverlayIndex index of the overlay in
             *              _imageOverlays.
             */
            _progressFrame: function (currentOverlayIndex) {
              angular.forEach(this._frameLookup, function (frameIndex, key) {

                if (this._imageOverlays[frameIndex].options.opacity !== 0
                  && frameIndex !== currentOverlayIndex) {
                  // Delete the old overlay from the lookup, it is gone.
                  delete this._frameLookup[key];
                  this._replaceUrlFromFrame(frameIndex);
                }
              }, this);

              var newFrame = this._imageOverlays[currentOverlayIndex];
              // Turn on new frame
              newFrame.setOpacity(this._opacity);
            },

            /**
             * @description Replaces the image source of the provided frame. Turns
             *              frame off by setting opacity to 0. When new url is
             *              different from previous, removes loadlistener, replaces
             *              url and adds new loadlistener. When new url is the same
             *              puts the old one back in the frameLookup and turns it
             *              back on when thge first of the list. When defer is
             *              provided passes it on the loadlistener that resolves it
             *              whenn all layers finished loading.
             * @param {int} currentOverlayIndex index of the overlay in
             * @param {defer} defer <optional> gets resolved when image is loaded
             *                      and _nLoadingRasters === 0.
             */
            _replaceUrlFromFrame: function (frameIndex, defer) {
              var url = this._imageUrlBase + this._formatter(new Date(this._nxtDate));
              var frame = this._imageOverlays[frameIndex];
              frame.off('load');
              frame.setOpacity(0);
              if (url !== frame._url) {
                this._addLoadListener(frame, this._nxtDate, defer);
                frame.setUrl(url);
              }
              else {
                var index = this._imageOverlays.indexOf(frame);
                this._frameLookup[this._nxtDate] = index;
                if (index === 0) {
                  this._imageOverlays[0].setOpacity(this._opacity);
                }
              }
              this._nxtDate += this._temporalResolution;
            },

            /**
             * @description Removes all references, sets _nLoadingRasters to 0. And
             *              calls replaceUrlFromFrame for every frame in the
             *              provided overlays
             *
             * @param {int} currentData in ms from epoch
             * @param {array} overlays L.ImageOverlay s
             * @param {defer} defer that gets resolved when all frames finished
             *                      loading.
             */
            _fetchNewFrames: function (currentDate, overlays, defer) {
              this._nxtDate = currentDate;
              this._frameLookup = {};
              this._nLoadingRasters = 0;

              angular.forEach(overlays, function (overlay, i) {
                this._replaceUrlFromFrame(i, defer);
              }, this);

              return overlays;
            },

            /**
             * @description Adds loadlistener to the provided overlay. On load a
             *              reference to the image is added to the _frameLookup,
             *              turns first layer on when defer was provided and
             *              resolves defer when provided and all images are loaded.
             * @param {L.ImageOverlay} overlay to add listener to
             * @param {int} data in ms from epoch the overlay belongs to.
             * @param {object} defer defer to resolve when all layers finished
             *                       loading.
             */
            _addLoadListener: function (overlay, date, defer) {
              this._nLoadingRasters++;
              overlay.addOneTimeEventListener("load", function () {
                this._nLoadingRasters--;
                var index = this._imageOverlays.indexOf(overlay);
                this._frameLookup[date] = index;
                if (defer && index === 0) {
                  this._imageOverlays[0].setOpacity(this._opacity);
                }
                if (defer && this._nLoadingRasters === 0) {
                  defer.resolve();
                }
              }, this);
            }
          });

          return layer;

        }

      };

    }
  ]);

'use strict';

/**
 * @ngdoc service
 * @name map.Layer
 * @description
 * # NxtLayer
 * Additional methods used to extend nxtLayer with leaflet/map specific methods.
 */
angular.module('map')
  .factory('NxtMapLayer', ['$q', '$http', function ($q, $http) {

      return {

        add: function (map) {
          var defer = $q.defer();
          if (this._leafletLayer) {
            // Vector layers need a timeState when added.
            this._leafletLayer.timeState = this.timeState;
            this._addLeafletLayer(map, this._leafletLayer);
            this._leafletLayer.on('load', function () {
              defer.resolve();
            });
          }
          else {
            defer.resolve();
          }
          return defer.promise;
        },

        remove: function (map) {
          if (this._leafletLayer) {
            this._removeLeafletLayer(map, this._leafletLayer);
          }
        },

        /**
         * @function
         * @description rescales layer and updates url
         */
        rescale: function (bounds) {
          if (this.rescalable) {
            var url = this.url +
              '?request=getlimits&layers=' + this.slug +
              '&width=16&height=16&srs=epsg:4326&bbox=' +
              bounds.toBBoxString();
            var self = this;
            $http.get(url).success(function (data) {
              self.limits = ':' + data[0][0] + ':' + data[0][1];
              // strip existing domain if already present.
              self.options.styles = self.options.styles.split(':')[0];
              self._leafletLayer.setParams({
                styles: self.options.styles + self.limits
              });
              self._leafletLayer.redraw();
            });
          }
        },

        setOpacity: function (opacity) {
          if (this._leafletLayer && this._leafletLayer.setOpacity) {
            this._leafletLayer.setOpacity(opacity);
          }
        },

        syncTime: function (timeState) {
          if (this.format !== 'Vector') { return; }
          this._leafletLayer.syncTime(timeState);
          return;
        },

        /**
         * @function
         * @memberof app.layerService
         * @param  {L.Class} Leaflet map
         * @param  {L.Class} Leaflet layer
         * @description Removes layer from map
         */
        _addLeafletLayer: function (map, leafletLayer) {
          if (map.hasLayer(leafletLayer)) {
            throw new Error(
              'Attempted to add layer' + leafletLayer._id
              + 'while it was already part of the map'
            );
          } else {
            map.addLayer(leafletLayer);
          }
        },

        /**
         * @function
         * @memberof app.layerService
         * @param  {L.Class} Leaflet map
         * @param  {L.Class} Leaflet layer
         * @description Removes layer from map
         */
        _removeLeafletLayer: function (map, leafletLayer) { // Leaflet NxtLayer
          if (map.hasLayer(leafletLayer)) {
            map.removeLayer(leafletLayer);
          }
        }

      };

    }
  ]);

'use strict';

/**
 * @ngdoc service
 * @class MapService
 * @memberof app
 * @name MapService
 * @requires NxtMap
 * @summary stores global NxtMap instance of the app.
 */

angular.module('map')
.service('MapService', ['$rootScope', '$q', 'LeafletService', 'LeafletVectorService', 'DataService', 'NxtNonTiledWMSLayer', 'NxtMapLayer', 'State',
  function ($rootScope, $q, LeafletService, LeafletVectorService, DataService, NxtNonTiledWMSLayer, NxtMapLayer, State) {

    var service = {

      _map: {}, // exposure is legacy, we should not mingle with the leaflet
                // map instance outside of the map component.

      /**
       * Initializes the map service
       * @param  {DOMelement} element      used by leaflet as the map container.
       * @param  {object} mapOptions       passed to leaflet for the map
       * @param  {object} eventCallbackFns used on leaflet map events [onmove etc]
       */
      initializeMap: function (element, mapOptions, eventCallbackFns) {
        service._map = createLeafletMap(element, mapOptions);
        this.initializeLayers(State.temporal);
        this._initializeNxtMapEvents(eventCallbackFns);
        // Map-services is dependant on the dataservice. This is to prevent
        // a bunch of complicated and slow watches and still keep the data-
        // service as the data authority.
        DataService.eventCallbacks = {
          onCreateLayerGroup: this.initializeLayer,
          onToggleLayerGroup: this._toggleLayers,
          onOpacityChange: this._setOpacity,
          onDblClick: this._rescaleContinuousData
        };
        // Turn active layergroups on.
        angular.forEach(State.layerGroups.active, function (lgSlug) {
          this._toggleLayers(DataService.layerGroups[lgSlug]);
        }, this);
      },

      /**
       * Syncs all layer groups to provided timeState object.
       * @param  {object} timeState   State.temporal object, containing start,
       *                              end, at and aggwindow.
       * @param  {leaflet map} optionalMap map object to sync the data to.
       * @return {promise}             promise that resolves layergroups synced.
       */
      syncTime: function (timeState) {
        var defer = $q.defer();
        var promises = [];
        angular.forEach(DataService.layerGroups, function (layerGroup) {
          if (layerGroup.isActive()) {
            angular.forEach(layerGroup.mapLayers, function (layer) {
              var p = layer.syncTime(timeState, service._map);
              if (p) {
                promises.push(p);
              }
            });
          } else {
            angular.forEach(layerGroup.mapLayers, function (layer) {
              layer.timeState = angular.copy(timeState);
            });
          }
        });
        var that = this;
        $q.all(promises).then(function () {
          State.layerGroups.timeIsSyncing = false;
          defer.resolve();
          return defer.promise;
        });
        if (promises.length > 0) {
          State.layerGroups.timeIsSyncing = true;
        }
        return defer.promise;
      },

      /**
       * @function
       * @memberOf map.MapService
       * @description sets leaflet View based on panZoom
       * @param {object} panZoom Hashtable with, lat, lng, zoom
       */
      setView: function (panZoom) {
        if (panZoom.hasOwnProperty('lat') &&
            panZoom.hasOwnProperty('lng') &&
            panZoom.hasOwnProperty('zoom'))
        {
          service._map.setView(new LeafletService.LatLng(
            panZoom.lat, panZoom.lng), panZoom.zoom);
        } else {
          service._map.setView.apply(service._map, arguments);
        }
      },

      /**
       * @function
       * @memberOf map.MapService
       * @description fits leaflet to extent
       * @param  {array} extent Array with NW, NE, SW,SE
       */
      fitBounds: function (bounds) {
        if (service._map instanceof LeafletService.Map) {
          if (bounds instanceof LeafletService.LatLngBounds) {
            service._map.fitBounds(bounds);
          }
          else if (bounds.hasOwnProperty('south')
            && bounds.hasOwnProperty('north')
            && bounds.hasOwnProperty('east')
            && bounds.hasOwnProperty('west')) {
            service._map.fitBounds(L.latLngBounds(
              L.latLng(bounds.south, bounds.east),
              L.latLng(bounds.north, bounds.west)));
          }
        }
      },

      getView: function () {
        return {
          lat: service._map.getCenter().lat,
          lng: service._map.getCenter().lng,
          zoom: service._map.getZoom()
        };
      },

      getBounds: function () {
        return service._map.getBounds();
      },

      /**
       * @description legacy function.
       */
      latLngToLayerPoint: function (latlng) {
        return service._map.latLngToLayerPoint(latlng);
      },

      /**
       * @function
       * @memberOf map.MapService
       * @description Initiate map events
       * @return {void}
       */
      _initializeNxtMapEvents: function (cbs) {
        var map = service._map;
        var conditionalApply = function (fn, e) {
          if (!$rootScope.$$phase) {
            $rootScope.$apply(fn(e, map));
          } else {
            fn(e, map);
          }
        };

        map.on('click',     function (e) { conditionalApply(cbs.onClick, e); });
        map.on('movestart', function (e) { conditionalApply(cbs.onMoveStart, e); });
        map.on('mousemove', function (e) { conditionalApply(cbs.onMouseMove, e); });
        map.on('moveend',   function (e) { conditionalApply(cbs.onMoveEnd, e); });
      },

      /**
       * @function
       * @memberOf map.MapService
       * @param  {L.Class} Leaflet map
       * @param  {L.Class} Leaflet layer
       * @description Removes layer from map
       */
      addLeafletLayer: function (leafletLayer) {
        if (service._map.hasLayer(leafletLayer)) {
          throw new Error(
            'Attempted to add layer' + leafletLayer._id
            + 'while it was already part of the map'
          );
        } else {
          service._map.addLayer(leafletLayer);
        }
      },

      /**
       * @function
       * @memberOf map.MapService
       * @param  {L.Class} Leaflet map
       * @param  {L.Class} Leaflet layer
       * @description Removes layer from map
       */
      removeLeafletLayer: function (leafletLayer) { // Leaflet NxtLayer
        if (service._map.hasLayer(leafletLayer)) {
          service._map.removeLayer(leafletLayer);
        }
      },


      _toggleLayers: function (lg) {
        if (lg.isActive() && lg.mapLayers.length > 0) {
          if (lg.temporal) {
            // copy timeState to layers so when added they will respect the
            // current timestate and can make independent descisions about when
            // to sync to new timestate.
            angular.forEach(lg.mapLayers, function (layer) {
              layer.timeState = angular.copy(State.temporal);
            });
          }
          addLayersRecursively(service._map, lg.mapLayers, 0);
        }
        else {
          angular.forEach(lg.mapLayers, function (layer) {
            if (layer._leafletLayer) {
              layer._leafletLayer.off('load');
              layer._leafletLayer.off('loading');
            }
            layer.remove(service._map);
          });
        }
        if (lg.getOpacity()) {
          angular.forEach(lg.mapLayers, function (layer) {
            layer.setOpacity(lg.getOpacity());
          });
        }
      },

      /**
       * @memberOf map.MapService
       * @param {object} layer passed
       * @description determine if raster layer can be rescaled
       */
      _rescaleContinuousData: function (lg) {
        var bounds = service._map.getBounds();
        angular.forEach(lg.mapLayers, function (layer) {
          layer.rescale(bounds);
        });
      },


      /**
       * @function
       * @memberOf map.MapService
       * @param {float} new opacity value
       * @return {void}
       * @description Changes opacity in layers that have
       * an opacity to be set
       */
      _setOpacity: function (lg) {
        if (lg.isActive()) {
          angular.forEach(lg.mapLayers, function (layer) {
            layer.setOpacity(lg.getOpacity());
          });
        }
      },

      zoomIn: function () {
        service._map.setZoom(service._map.getZoom() + 1);
      },

      zoomOut: function () {
        service._map.setZoom(service._map.getZoom() - 1);
      },

      /**
       * Initializes map layers for every layergroup.mapLayers.
       * @param  {object} timeState used to set an initial time on layers
       */
      initializeLayers: function (timeState) {
        angular.forEach(DataService.layerGroups, function (lg, lgSlug) {
          this.initializeLayer(lg);
        }, this);
      },

      initializeLayer: function (lg) {
        sortLayers(lg.mapLayers);
        angular.forEach(lg.mapLayers, function (layer, lSlug) {
          if (layer.tiled) {
            layer._leafletLayer = initializers[layer.format](layer);
            angular.extend(layer, NxtMapLayer);
          } else if (layer.format === 'WMS') {
            if (!layer.bounds) { layer.bounds = lg.spatialBounds; }
            layer = NxtNonTiledWMSLayer.create(layer);
          }
        });
      }

    };



    /**
     * @function
     * @memberOf map.MapService
     * @param  {array} Array of nxt layers
     * @return {array} Array of object sorted by property loadOrder in
     *                 descending order.
     * @description Sorts layers by descending loadOrder
     */
    var sortLayers = function (layers) {
      layers.sort(function (a, b) {
        if (a.loadOrder > b.loadOrder) {
          return -1;
        }
        if (a.loadOrder < b.loadOrder
          || a.loadOrder === null) {
          return 1;
        }
        // a must be equal to b
        return 0;
      });
      return layers;
    };

    /**
     * @function
     * @memberOf map.MapService
     * @param  {object} map Leaflet map to add layers to
     * @param  {array} Array of nxt layers
     * @param  {int} i index to start from
     * @description Adds the layers with the loadorder of layers[i]. Catches
     *              the returned promises and calls itself with the nxt index.
     *              When all layers are loaded it adds a listener to the last
     *              layer with the highest loadOrder.
     */
    var addLayersRecursively = function (map, layers, i) {
      var currentLoadOrder = layers[i].loadOrder;
      // Wrap contains the promises and the nxt index.
      var wrap = loadLayersByLoadOrder(map, layers, i, currentLoadOrder);
      // If there is more, wait for these layers to resolve
      // and start over with the remaining layers.
      if (wrap.i < layers.length) {
        startOverWhenDone(wrap.promises, map, layers, wrap.i);
      }
      // When done, add listener to the last layer with the max loadOrder
      // that is drawn on the map.
      else if (layers.length > 1) {
        var index = getIndexOfLeadingLayer(layers);
        if (typeof(index) === 'number') {
          addLoadListenersToLayer(map, layers, index);
        }
      }
    };


    /**
     * @function
     * @memberOf map.MapService
     * @param  {object} map Leaflet map to add layers to.
     * @param  {array} layers Array of nxt layers.
     * @param  {int} i index to start from.
     * @param  {inte} loadOrder Current load order to add layers.
     * @return {object} next index and list of promises that resolve when layer
     *                       is fully loaded.
     * @description Adds the layers from index i with the given loadorder to the
     *              map. Returns the current index and a list of promises for
     *              all the added layers when a layer with a lower loadorder is
     *              found.
     */
    var loadLayersByLoadOrder = function (map, layers, i, loadOrder) {
      // Add all layers with the current load order
      var promises = [];
      while (i < layers.length
        && layers[i].loadOrder === loadOrder) {
        promises.push(layers[i].add(map));
        i++;
      }
      return {
        i: i,
        promises: promises
      };
    };

    /**
     * @function
     * @memberOf map.MapService
     * @param  {array} layers Array of nxt layers.
     * @return {int} Index of the last layer with the highest loadOrder.
     * @description Loops through the sorted layers and returns the index of the
     *              last layer in the array with the highest loadOrder.
     */
    var getIndexOfLeadingLayer = function (layers) {
      var index;
      var highestLoadingOrder = 0;
      for (var i = 0; i < layers.length; i++) {
        if (layers[i].tiled
          && (layers[i].loadOrder > highestLoadingOrder
          || layers[i].loadOrder === highestLoadingOrder)) {
          index = i;
          highestLoadingOrder = index;
        }
      }
      return index;
    };

    /**
     * @function
     * @memberOf map.MapService
     * @param  {array} Array of promises.
     * @param  {object} map Leaflet map to add layers to.
     * @param  {array} layers Array of nxt layers.
     * @param  {int} i index to start from.
     * @description Takes a list of promises and calls addLayersRecursively when
     *              all promises have resolved.
     */
    var startOverWhenDone = function (promises, map, layers, i) {
      $q.all(promises).then(function () {
        addLayersRecursively(map, layers, i);
      });
    };

    /**
     * @function
     * @memberOf map.MapService
     * @param  {object} map Leaflet map to add layers to.
     * @param  {array} layers Array of nxt layers.
     * @param  {int} i index to start from.
     * @description Adds listeners that call when load starts and finished to
     *              the layer at index i of layers. Callbacks remove layers of
     *              the map after index i when load starts and adds layers after
     *              index i recursively when load finishes.
     */
    var addLoadListenersToLayer = function (map, layers, i) {
      var layer = layers[i];
      var j = i + 1;

      var removeAllAfterI = function () {
        for (j; j < layers.length; j++) {
          layers[j].remove(map);
        }
      };

      var reAdd = function () {
        addLayersRecursively(map, layers, i + 1);
      };

      layer._leafletLayer.off('load');
      layer._leafletLayer.off('loading');
      layer._leafletLayer.on('loading', removeAllAfterI);
      layer._leafletLayer.on('load', reAdd);
    };

    /**
     * @function
     * @memberOf map.MapService
     * @param  {dynamic} mapElem can be string or Element.
     * @param  {options} Options (bounds, attribution etc.)
     * @return {L.NxtMap}   Leaflet.NxtMap instance
     * @description Creates a Leaflet map based on idString or Element.
     */
    var createLeafletMap = function (mapElem, options) { // String or Element.

      var leafletMap = LeafletService.map(mapElem, options);

      return leafletMap;
    };

    /**
     * Initializers for every layer format
     */
    var initializers = {

      TMS: function (nonLeafLayer) {

        var layerUrl = nonLeafLayer.url + '/{slug}/{z}/{x}/{y}{retina}.{ext}';

        // Mapbox layers support retina tiles, our own do not yet. Check whether
        // tiles are from mapbox source.
        var retinaSupport = /tiles.mapbox/g.test(nonLeafLayer.url);

        var layer = LeafletService.tileLayer(
          layerUrl, {
            retina: retinaSupport && L.Browser.retina ? '@2x' : '',
            slug: nonLeafLayer.slug,
            minZoom: nonLeafLayer.min_zoom || 0,
            maxZoom: 19,
            detectRetina: retinaSupport,
            zIndex: nonLeafLayer.zIndex,
            ext: 'png'
          });

        return layer;
      },

      WMS: function (nonLeafLayer) {
        var _options = {
          layers: nonLeafLayer.slug,
          format: 'image/png',
          version: '1.1.1',
          minZoom: nonLeafLayer.min_zoom || 0,
          maxZoom: 19,
          crs: LeafletService.CRS.EPSG3857,
          opacity: nonLeafLayer.opacity,
          zIndex: nonLeafLayer.zIndex
        };
        _options = angular.extend(_options, nonLeafLayer.options);

        return LeafletService.tileLayer.wms(nonLeafLayer.url, _options);
      },

      UTFGrid: function (nonLeafLayer) {

        var url = nonLeafLayer.url + '/{slug}/{z}/{x}/{y}.{ext}';

        var layer = new LeafletService.UtfGrid(url, {
          ext: 'grid',
          slug: nonLeafLayer.slug,
          name: nonLeafLayer.slug,
          useJsonP: false,
          minZoom: nonLeafLayer.min_zoom_click || 0,
          maxZoom: 19,
          order: nonLeafLayer.zIndex,
          zIndex: nonLeafLayer.zIndex
        });
        return layer;
      },

      Vector: function (nonLeafLayer) {
        var leafletLayer = new LeafletVectorService({
          slug: nonLeafLayer.slug,
          color: nonLeafLayer.color,
          showCoverageOnHover: false,  // When you mouse over a cluster it shows
                                       // the bounds of its markers.
          zoomToBoundsOnClick: true,   // When you click a cluster we zoom to
                                       // its bounds.
          spiderfyOnMaxZoom: false,    // When you click a cluster at the bottom
                                       // zoom level we  do not spiderfy it
                                       // so you can see all of its markers.
          maxClusterRadius: 80,        // The maximum radius that a cluster will
                                       // cover from the central marker
                                       // (in pixels). Default 80. Decreasing
                                       // will make more and smaller clusters.
                                       // Set to 1 for clustering only when
                                       // events are on the same spot.
          animateAddingMarkers: false, // Enable for cool animations but its
                                       // too slow for > 1000 events.
          iconCreateFunction: function (cluster) {
            var size = cluster.getAllChildMarkers().length,
                pxSize;

            if (size > 1024) {
              pxSize = 30;
            } else if (size > 256) {
              pxSize = 26;
            } else if (size > 64) {
              pxSize = 22;
            } else if (size > 32) {
              pxSize = 20;
            } else if (size > 16) {
              pxSize = 18;
            } else if (size > 8) {
              pxSize = 16;
            } else if (size > 4) {
              pxSize = 14;
            } else {
              pxSize = 12;
            }

            // Return two circles, an opaque big one with a smaller one on top
            // and white text in the middle. With radius = pxSize.
            return L.divIcon({
              iconAnchor: [pxSize, pxSize],
              html: '<svg height="' + (pxSize * 2) + '" width="' + (pxSize * 2)
                    + '">'
                    + '<circle cx="' + pxSize + '" cy="' + pxSize
                    + '" r="' + pxSize + '" fill-opacity="0.4" fill="'
                    + nonLeafLayer.color + '" />'
                    + '<circle cx="' + pxSize + '" cy="' + pxSize + '" r="'
                    + (pxSize - 2) + '" fill-opacity="1" fill="'
                    + nonLeafLayer.color + '" />'
                    + '<text x="' + pxSize + '" y="' + (pxSize + 5)
                    + '" style="text-anchor: middle; fill: white;">'
                    + size + '</text>'
                    + '</svg>'
            });
          }

        });
        return leafletLayer;
      }

    };

    return service;
  }]);

'use strict';

/**
 * Map directive
 *
 * Overview
 * ========
 *
 * Defines the map. Directive does all the watching and DOM binding, MapDirCtrl
 * holds all the testable logic. Ideally the directive has no logic and the
 * MapDirCtrl is independent of the rest of the application.
 *
 */
angular.module('map')
  .directive('map', [
  '$controller',
  'MapService',
  'DataService',
  'UtilService',
  'State',
  function (
    $controller,
    MapService,
    DataService,
    UtilService,
    State
  ) {

    var link = function (scope, element, attrs) {

      var mapSetsBounds = false,
          mapSetsView = false;

      /**
       * Init is called when directive is compiled and listeners are attached
       * Alligns state with map.
       */
      var init = function () {
        if (Object.keys(State.spatial.view).length !== 0) {
          mapSetsView = true;
          MapService.setView(State.spatial.view);
        }
        else if (Object.keys(State.spatial.bounds).length !== 0) {
          mapSetsBounds = true;
          MapService.fitBounds(State.spatial.bounds);
        }
      };

       /**
        * @function
        * @memberOf app.map
        * @description small clickhandler for leafletclicks
        * @param  {event}  e Leaflet event object
        */
      var _clicked = function (e) {
        State.spatial.here = e.latlng;
      };

      /**
       * @function
       * @memberOf app.map
       */
      var _moveStarted = function (e) {
        State.spatial.mapMoving = true;
      };

      /**
       * @function
       * @memberOf app.map
       */
      var _mouseMove = function (e) {
        if (State.box.type === 'line') {
          State.spatial.userHere = e.latlng;
        }
      };

      /**
       * @function
       * @memberOf app.map
       */
      var _moveEnded = function (e, map) {
        State.spatial.mapMoving = false;
        // Moveended is fired on teardown of map and map.getBounds() returns a
        // bounds object of size zero. We want to keep the bounds.
        if (State.context === 'map') {
          mapSetsBounds = true;
          mapSetsView = true;
          State.spatial.bounds = map.getBounds();
          State.spatial.view = MapService.getView();
        }
      };

      MapService.initializeMap(element[0], {
          attributionControl: false,
          minZoom: 2,
          zoomControl: false,
          addZoomTitles: true,
        }, {
          onClick: _clicked,
          onMoveStart: _moveStarted,
          onMoveEnd: _moveEnded,
          onMouseMove: _mouseMove
        }
      );

      /**
       * Watch state spatial view and update the whole shebang.
       */
      scope.$watch(State.toString('spatial.view'), function (n, o) {
        if (n !== o && !mapSetsBounds) {
          MapService.setView(State.spatial.view);
          State.spatial.bounds = MapService.getBounds();
        } else {
          mapSetsView = false;
        }
      });

      /**
       * Watch bounds of state and update map bounds when state is changed.
       */
      scope.$watch(State.toString('spatial.bounds'), function (n, o) {
        if (n !== o && !mapSetsBounds) {
          MapService.fitBounds(State.spatial.bounds);
          State.spatial.view = MapService.getView();
        } else {
          mapSetsBounds = false;
        }
      });

      /**
       * Watch temporal.at of app and update maplayers accordingly.
       *
       * Used for animation and clicks on timeline or changes from url-ctrl.
       */
      scope.$watch(State.toString('temporal.at'), function (n, o) {
        if (n === o) { return; }
        MapService.syncTime(State.temporal);
      });

      /**
       * Watch timelineMoving to update maplayers to new time domain when.
       *
       * Used for drag of timeline or changes from url-ctrl.
       */
      scope.$watch(State.toString('temporal.timelineMoving'), function (n, o) {
        if (n === o) { return; }
        MapService.syncTime(State.temporal);
      });

      /**
       * Watch timelineMoving to maplayers to time domain.
       *
       * Used to turn maplayers to a none animating state. When animation stops.
       */
      scope.$watch(function () { return State.temporal.playing; }, function (newValue) {
        if (newValue) { return; }
        MapService.syncTime(State.temporal);
      });

      scope.$watch(State.toString('box.type'), function (n, o) {
        if (n === o) { return true; }
        var selector;
        switch (n) {
        case "point":
          selector = "";
          break;
        case "line":
          selector = "#map * {cursor: crosshair;}";
          break;
        case "region":
          selector = "";
          break;
        case "area":
          selector = "#map * {cursor: -webkit-grab; cursor: -moz-grab; cursor: grab; cursor: hand;}";
          break;
        default:
          return;
        }
        UtilService.addNewStyle(selector);

      });

      init();

    };

    return {
      restrict: 'E',
      replace: true,
      template: '<div id="map" class="map"></div>',
      link: link
    };
  }
]);

angular.module('timeseries', [
]);

/**
 * Service to handle timeseries retrieval.
 */
angular.module('timeseries')
  .service("TimeseriesService", ['CabinetService', '$q',
    function (CabinetService, $q) {

    var localPromises = {};

    this._getTimeseries = function (id, timeState, minPoints) {
      // Cancel consecutive calls for the same ts.
      if (localPromises[id]) {
        localPromises[id].resolve();
      }
      localPromises[id] = $q.defer();
      return CabinetService
      .timeseries
      .withHttpConfig({timeout: localPromises[id].promise})
      .get({
        object: id,
        min_points: minPoints,
        start: parseInt(timeState.start, 10),
        end: parseInt(timeState.end, 10)
      });
    };

    /**
     * @function
     * @memberOf timeseries.TimeseriesService
     * @description gets timeseries from service
     */
    this.getTimeSeriesForObject = function (
        objectId,
        start,
        end,
        minPoints,
        defer
      ) {

      // maximum number of timeseries events, more probably results in a
      // memory error.
      var MAX_NR_TIMESERIES_EVENTS = 25000;
      var promise = this._getTimeseries(
        objectId,
        {
          start: start,
          end: end
        },
        minPoints
      ).then(function (response) {

         // Filter out the timeseries with too little measurements. And ts
         // without parameter unit info.
        var filteredResult = [];
        angular.forEach(response.results, function (ts) {
          var msg = '';
          if (ts.events.length > 1 &&
              ts.events.length < MAX_NR_TIMESERIES_EVENTS &&
              ts.parameter_referenced_unit) {
            filteredResult.push(ts);

          // Else: output a message to the console and an error to sentry.
          } else if (ts.events.length > MAX_NR_TIMESERIES_EVENTS) {
            msg = 'Timeseries: '
              + ts.uuid
              + ' has: '
              + ts.events.length
              + ' events, while '
              + MAX_NR_TIMESERIES_EVENTS
              + ' is the maximum supported amount';
            window.Raven.captureException(new Error(msg));
            console.info(msg);
          } else if (!ts.parameter_referenced_unit) {
            msg = 'Timeseries: '
              + ts.uuid
              + ' has no valid parameter_referenced_unit';
            window.Raven.captureException(new Error(msg));
            console.info(msg);
          }
        });

        // Legacy dataservice calls this function with a defer which is not used
        // by the timeseries directive.
        if (defer) {
          defer.notify({
            data: filteredResult,
            layerGroupSlug: 'timeseries',
            layerSlug: 'timeseries',
          });
        }
        return response; // accomadate chaining.
      });

      return promise;
    };

  }

]);


'use strict';
/**
 * Timeseries directive.
 */
angular.module('timeseries')
  .directive('timeseries', ['TimeseriesService', '$filter', function (TimeseriesService, $filter) {
  return {
      link: function (scope) {

        var GRAPH_WIDTH = 320; // Width of drawing area of box graphs.

        scope.timeseries = {};
        scope.fetching = false;

        /**
         * Return the currently selected timeseries if it is one of the
         * available timeseries.
         * @param  {array} timeseries list of available timeseries.
         * @param  {object} current   currently selected ts.
         * @return {object} selected timeseries.
         */
        var getSelectedTS = function (timeseries, current) {
          var selected = {};
          if (current) {
            selected = timeseries.filter(function (ts) {
              return ts.uuid === current.uuid;
            });
          }
          return selected.length > 0 ? selected[0] : timeseries[0];
        };

        /**
         * Fetch timeseries for asset. Remove zero datapoints from response and
         * update the selected ts.
         * @param  {object} asset utfgrid asset with entity_name and id.
         */
        var fetchTS = function(asset) {
          scope.fetching = true;

          var assetId = asset.entity_name + '$' + asset.id;

          TimeseriesService.getTimeSeriesForObject(
            assetId,
            scope.timeState.start,
            scope.timeState.end,
            GRAPH_WIDTH
          ).then(function (response) {
            scope.timeseries.data = $filter('rmZeroDatumTimeseries')(response.results);

            scope.timeseries.selectedTimeseries = getSelectedTS(
              scope.timeseries.data,
              scope.timeseries.selectedTimeseries
            );
            scope.fetching = false;

          });
        };

        /**
         * Get new ts when asset changes
         */
        scope.$watch('asset', function () {
          fetchTS(scope.asset);
        });


        /**
         * Get new ts when time changes
         */
        scope.$watch('timeState.timelineMoving', function (off) {
          if (!off) {
            fetchTS(scope.asset);
          }
        });

      },
      restrict: 'E',
      scope: {
        asset: '=',
        fullDetails: '=',
        timeState: '='
      },
      // replace: true,
      templateUrl: 'timeseries/timeseries.html'
    };
}]);

angular.module('omnibox', [
  'templates-main',
  'global-state',
  'data-menu',
  'map',
  'timeseries'
]);

angular.module('omnibox')
  .controller("OmniboxCtrl", [
  "$scope",
  "UtilService",
  "ClickFeedbackService",
  "State",
  "DataService",
  "MapService",

  function (
    $scope,
    UtilService,
    ClickFeedbackService,
    State,
    DataService,
    MapService) {

    this.state = { temporal: State.temporal };

    $scope.box = {
      content: {}
    };

    $scope.zoomIn = MapService.zoomIn;
    $scope.zoomOut = MapService.zoomOut;

    /**
     * @function
     * @memberOf app.omnibox
     * @description Fills box by requesting data from DataService
     *              When finished $scope.box.content contains an
     *              object for every active layergroup and an item
     *              in box.content.<layergroup>.layer for every
     *              piece of data.The promises are returned to
     *              add specific logic in the child controllers.
     * @param  {L.LatLng} here | L.Bounds | [L.LatLng]
     */
    $scope.fillBox = function (options) {
      // if geocode query has been used it needs to be destroyed now
      if ($scope.box.content.hasOwnProperty('searchResults')) {
        delete $scope.box.content.searchResults;
      }

      var doneFn = function () {
        // This function deletes scope.box.content for specific layergroups; this implies
        // skippingthe key 'timeseries' since this doesn't denote a layergroup!
        angular.forEach($scope.box.content, function (value, key) {
          if (key === 'waterchain') {
            var newkey = _.find(State.layerGroups.active, function (val) {return val.indexOf('waterchain') !== -1; });
            if (newkey !== undefined) {
              key = newkey;
            }
          }
          if (State.layerGroups.active.indexOf(key) === -1) {
            delete $scope.box.content[key];
          }
        });
      };

      /**
       * Error callback
       *
       * Many omnibox calls are rejected when making multiple calls in a row.
       * By explicitly passing the reason it is possible to throw an error and
       * give user feedback further downstream.
       *
       * @param  {string} reason why getData was rejected.
       * @return {string} reason
       */
      var errorFn = function (reason) {
        if (reason !== DataService.REJECTION_REASONS.OVERRIDDEN) {
          throw new Error(
            'Getting omnibox data rejected: '
            + JSON.stringify({'reason': reason})
          );
        }
        return reason;
      };

      var putDataOnScope = function (response) {
        var lGContent = $scope.box.content[response.layerGroupSlug] || {layers: {}};
        lGContent.layers[response.layerSlug] = lGContent.layers[response.layerSlug] || {};

        var lg = DataService.layerGroups[response.layerGroupSlug];
        if (lg) {
          lGContent.layerGroupName = lg.name;
          lGContent.order = lg.order;
          lGContent.temporal = lg.temporal;
        }

        if (UtilService.isSufficientlyRichData(
          (response.data && response.data.data) || response.data
          )) {

          var sharedKeys = ['aggType', 'format', 'data', 'summary', 'scale',
            'quantity', 'unit', 'color', 'type'];

          angular.forEach(sharedKeys, function (key) {
            lGContent.layers[response.layerSlug][key] = response[key];
          });

          /**
           * lGContent now looks like: {
           *   layerGroup: <slug>,
           *   layerGroupName: <name>,
           *   order: <order>,
           *   layers: {
           *     <layerSlug>: {
           *       data: <layer.data>,
           *       format: <layer.format>
           *     },
           *
           *     ...,
           *
           *   }
           * }
           */

          $scope.box.content[response.layerGroupSlug] = lGContent;
          // hack to allow for different asset layers as long as their name
          // contains 'waterchain'
          // do the same trick for waterchain_grid utfgrid layer
          // the grid layer should have to same slug as the groupLayer + '_grid'
          if (response.layerGroupSlug.indexOf('waterchain') !== -1) {
            $scope.box.content['waterchain'] = lGContent;
            var gridKey = response.layerGroupSlug + '_grid';
            $scope.box.content.waterchain.layers['waterchain_grid'] = lGContent.layers[gridKey];
          }

        } else {

          if ($scope.box.content[response.layerGroupSlug]) {

            if (response.layerGroupSlug.indexOf('waterchain') !== -1) {
              delete $scope.box.content[response.layerGroupSlug];
              delete $scope.box.content.waterchain;

            } else {
              delete $scope.box.content[response.layerGroupSlug].layers[response.layerSlug];
            }
          }
        }
        // Accomodate chaining in child controllers
        return response;
      };
      var promise = DataService.getData('omnibox', options).then(doneFn, errorFn, putDataOnScope);
      return promise;
    };

    // Make UtilSvc.getIconClass available in Angular templates
    $scope.getIconClass = UtilService.getIconClass;
  }
]);

'use strict;'

angular.module('omnibox')
.service("WantedAttributes", ["gettext", function (gettext) {

  this.pump = {
    rows: [
      {
        keyName: gettext("Capacity"),
        attrName: "capacity",
        ngBindValue:
          "asset.selectedAsset.capacity * 3.6 | niceNumberOrEllipsis: 2",
        valueSuffix: "  (m<sup>3</sup> / uur)",
        defaultValue: "12"
      },
      {
        /// Aanslagpeil
        keyName: gettext("Start level"),
        attrName: "start_level",
        ngBindValue:
          "asset.selectedAsset.start_level | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "-2.2"
      },
      {
        /// Afslagpeil
        keyName: gettext("Stop level"),
        attrName: "stop_level",
        ngBindValue:
          "asset.selectedAsset.stop_level | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "-2.8"
      }
    ]
  };

  this.bridge = {
    rows: [
      {
        keyName: gettext("Type"),
        attrName: "type",
        ngBindValue: "waterchain.layers.waterchain_grid.data.type",
        valueSuffix: "",
        defaultValue: "Liggerbrug"
      },
      {
        keyName: gettext("Width"),
        attrName: "width",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.width | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: 8
      },
      {
        keyName: gettext("Length"),
        attrName: "length",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.length | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: 17
      },
      {
        keyName: gettext("Height"),
        attrName: "height",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.height | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: 2
      }
    ]
  };

  this.channel_Boezem = {
    rows: [
      {
        keyName: gettext("Name"),
        attrName: "name",
        ngBindValue: "waterchain.layers.waterchain_grid.data.name",
        valueSuffix: "",
        defaultValue: "Watergang"
      },
      {
        keyName: gettext("Type"),
        attrName: "type",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.type",
        valueSuffix: "",
        defaultValue: "Boezem"
      }
    ]
  };

  this.crossprofile = {
    rows: [
      {
        keyName: gettext("Type"),
        attrName: "type",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.type | niceNumberOrEllipsis: 2",
        valueSuffix: "",
        defaultValue: "Dwarsdoorsnede"
      }
    ]
  };

  this.culvert = {
    rows: [
      {
        keyName: gettext("Width"),
        attrName: "width",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.width | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: "2"
      },
      {
        keyName: gettext("Length"),
        attrName: "length",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.length | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: "8"
      },
      {
        keyName: gettext("Height"),
        attrName: "height",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.height | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: "1.5"
      },
      {
        keyName: gettext("Material"),
        attrName: "material",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.material | lookupCulvertMaterial",
        valueSuffix: "",
        defaultValue: "beton"
      },
      {
        keyName: gettext("Shape"),
        attrName: "shape",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.shape | lookupCulvertShape",
        valueSuffix: "",
        defaultValue: "rechthoekig"
      }
    ]
  };

  this.filter = {
    rows: [
      {
        /// Bovenkant filter
        keyName: gettext("Filter top level"),
        attrName: "filter_top_level",
        ngBindValue: "waterchain.layers.waterchain_grid.data.filter_top_level",
        valueSuffix: " (m)",
        defaultValue: ""
      },
      {
        /// Onderkant filter
        keyName: gettext("Filter bottom level"),
        attrName: "filter_bottom_level",
        ngBindValue: "waterchain.layers.waterchain_grid.data.filter_bottom_level",
        valueSuffix: " (m)",
        defaultValue: ""
      },
      {
        keyName: gettext("Aquifer confinement"),
        attrName: "aquifer_confiment",
        ngBindValue: "waterchain.layers.waterchain_grid.data.aquifer_confiment",
        valueSuffix: " (m)",
        defaultValue: ""
      },
      {
        /// bodemsoort
        keyName: gettext("Litology"),
        attrName: "litology",
        ngBindValue: "waterchain.layers.waterchain_grid.data.litology",
        valueSuffix: " (m)",
        defaultValue: ""
      },

    ]
  };

  this.groundwaterstation = {
    rows: [
      {
        keyName: gettext("Name"),
        attrName: "name",
        ngBindValue: "waterchain.layers.waterchain_grid.data.name",
        valueSuffix: "",
        defaultValue: ""
      },
      {
        keyName: gettext("Code"),
        attrName: "code",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.code",
        valueSuffix: "",
        defaultValue: ""
      },
      {
        keyName: gettext("Surface level"),
        attrName: "surface_level",
        ngBindValue: "waterchain.layers.waterchain_grid.data.surface_level",
        valueSuffix: " (m)",
        defaultValue: ""
      },
      {
        /// Bovenkant buis
        keyName: gettext("Top level"),
        attrName: "top_level",
        ngBindValue: "waterchain.layers.waterchain_grid.data.top_level",
        valueSuffix: " (m)",
        defaultValue: ""
      },
      {
        /// Onderkan buis
        keyName: gettext("Bottom level"),
        attrName: "bottom_level",
        ngBindValue: "waterchain.layers.waterchain_grid.data.bottom_level",
        valueSuffix: " (m)",
        defaultValue: ""
      }
    ]
  };

  this.levee = {
    rows: [
      {
        /// Kruinhoogte
        keyName: gettext("Crest height"),
        attrName: "crest_height",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.crest_height | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "2"
      },
      {
        /// Bekleding
        keyName: gettext("Coating"),
        attrName: "coating",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.coating",
        valueSuffix: "",
        defaultValue: "gras"
      },
      {
        keyName: gettext("Material"),
        attrName: "material",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.material",
        valueSuffix: "",
        defaultValue: "zand"
      }
    ]
  };

  this.leveereferencepoint = {
    rows: [
      {
        keyName: gettext("Type"),
        attrName: "type",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.type",
        valueSuffix: "",
        defaultValue: "Referentiemeetpunt"
      }
    ]
  };

  this.manhole = {
    rows: [
      {
        keyName: gettext("Code"),
        attrName: "code",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.code",
        valueSuffix: "",
        defaultValue: "0-7361"
      },
      {
        keyName: gettext("Surface level"),
        attrName: "surface_level",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.surface_level | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "0.42"
      },
      {
        keyName: gettext("Material"),
        attrName: "material",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.material",
        valueSuffix: "",
        defaultValue: "beton"
      },
      {
        keyName: gettext("Widht"),
        attrName: "width",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.width | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: "0.8"
      },
      {
        keyName: gettext("Shape"),
        attrName: "shape",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.shape | lookupManholeShape",
        valueSuffix: "",
        defaultValue: "vierkant"
      },
      {
        /// Putbodem
        keyName: gettext("Bottom level manhole"),
        attrName: "bottom_level",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.bottom_level | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "-1.6"
      }
    ],
  };

  this.measuringstation = {
    rows: [
      {
        keyName: gettext("Name"),
        attrName: "name",
        ngBindValue: "waterchain.layers.waterchain_grid.data.name",
        valueSuffix: "",
        defaultValue: "KNMI"
      },
      {
        keyName: gettext("Category"),
        attrName: "category",
        ngBindValue: "waterchain.layers.waterchain_grid.data.category",
        valueSuffix: "",
        defaultValue: "KNMI-AWS"
      },
      {
        keyName: gettext("Frequency"),
        attrName: "frequency",
        ngBindValue: "waterchain.layers.waterchain_grid.data.frequency",
        valueSuffix: "",
        defaultValue: "1x per uur"
      },
      {
        keyName: gettext("Code"),
        attrName: "code",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.code",
        valueSuffix: "",
        defaultValue: "6278"
      }
    ]
  };

  this.orifice = {
    rows: [
      {
        keyName: gettext("Code"),
        attrName: "code",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.code",
        valueSuffix: "",
        defaultValue: "3105"
      },
      {
        /// Overstortbreedte
        keyName: gettext("Crest width"),
        attrName: "crest_width",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.crest_width | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: "1"
      },
      {
        /// Overstorthoogte
        keyName: gettext("Crest level"),
        attrName: "crest_level",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.crest_level | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "0.2"
      },
      {
        keyName: gettext("Shape"),
        attrName: "shape",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.shape | truncate: 20",
        valueSuffix: "",
        defaultValue: "rechthoekig"
      }
    ]
  };

  this.outlet = {
    rows: [
      {
        keyName: gettext("Manhole id"),
        attrName: "manhole_id",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.manhole_id | niceNumberOrEllipsis: 2",
        valueSuffix: "",
        defaultValue: "6-549"
      },
      {
        /// Buitenwaterstand (gemiddeld)
        keyName: gettext("Open water level (average)"),
        attrName: "open_water_level_average",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.open_water_level_average | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "-0.1"
      }
    ]
  };

  this.overflow = {
    rows: [
      {
        keyName: gettext("Code"),
        attrName: "code",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.code",
        valueSuffix: "",
        defaultValue: "12-72297"
      },
      {
        /// Overstortbreedte
        keyName: gettext("Crest width"),
        attrName: "crest_width",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.crest_width",
        valueSuffix: " (m)",
        defaultValue: "1"
      },
      {
        /// Overstorthoogte
        keyName: gettext("Crest level"),
        attrName: "crest_level",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.crest_level",
        valueSuffix: " (mNAP)",
        defaultValue: "0.2"
      }
    ]
  };

  this.pipe = {
    rows: [
      {
        keyName: gettext("Type"),
        attrName: "type",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.type | lookupPipeType",
        valueSuffix: "",
        defaultValue: "gemengd stelsel"
      },
      {
        /// BOB beginpunt
        keyName: gettext("Invert level start point"),
        attrName: "invert_level_start_point",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.invert_level_start_point | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "-3.1"
      },
      {
        /// BOB eindpunt
        keyName: gettext("Invert level end point"),
        attrName: "invert_level_end_point",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.invert_level_end_point | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "-3.12"
      },
      {
        keyName: gettext("Length"),
        attrName: "length",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.length | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: "28"
      },
      {
        keyName: gettext("Material"),
        attrName: "material",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.material | pipeMaterialOrEllipsis",
        valueSuffix: "",
        defaultValue: "beton"
      },
      {
        keyName: gettext("Width"),
        attrName: "width",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.width | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: "0.8"
      },
      {
        keyName: gettext("Shape"),
        attrName: "shape",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.shape | lookupPipeShape",
        valueSuffix: "",
        defaultValue: "rond"
      },
      {
        keyName: gettext("Code"),
        attrName: "code",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.code",
        valueSuffix: "",
        defaultValue: "0-985-0-986"
      }
    ]
  };

  this.pressurepipe = {
    rows: [
      {
        keyName: gettext("Name"),
        attrName: "name",
        ngBindValue: "waterchain.layers.waterchain_grid.data.name",
        valueSuffix: "",
        defaultValue: "onbekend"
      },
      {
        keyName: gettext("Type"),
        attrName: "type",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.type | lookupPressurePipeType",
        valueSuffix: "",
        defaultValue: "transportleiding"
      },
      {
        keyName: gettext("Construction year"),
        attrName: "year_of_construction",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.year_of_construction",
        valueSuffix: "",
        defaultValue: "2006"
      },
      {
        keyName: gettext("Code"),
        attrName: "code",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.code",
        valueSuffix: "",
        defaultValue: "776"
      },
      {
        keyName: gettext("Diameter"),
        attrName: "diameter",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.diameter | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: "1.6"
      },
      {
        keyName: gettext("Shape"),
        attrName: "shape",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.shape",
        valueSuffix: "",
        defaultValue: "rond"
      },
      {
        keyName: gettext("Length"),
        attrName: "length",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.length",
        valueSuffix: " (m)",
        defaultValue: "154"
      },
      {
        keyName: gettext("Material"),
        attrName: "material",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.material | pipeMaterialOrEllipsis",
        valueSuffix: "",
        defaultValue: "HDPE"
      }
    ]
  };

  this.pumpstation = {
    rows: [
      {
        keyName: gettext("Type"),
        attrName: "type",
        ngBindValue: "waterchain.layers.waterchain_grid.data.type",
        valueSuffix: "",
        defaultValue: "gemaal"
      },
      {
        keyName: gettext("Capacity"),
        attrName: "capacity",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.capacity * 3.6 | niceNumberOrEllipsis: 2",
        valueSuffix: "  (m<sup>3</sup> / uur)",
        defaultValue: "54"
      },
      {
        keyName: gettext("Name"),
        attrName: "name",
        ngBindValue: "waterchain.layers.waterchain_grid.data.name",
        valueSuffix: "",
        defaultValue: "onbekend"
      },
      {
        keyName: gettext("Code"),
        attrName: "code",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.code",
        valueSuffix: "",
        defaultValue: "127"
      },
      {
        /// Aanslagpeil
        keyName: gettext("Start level"),
        attrName: "start_level",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.start_level | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "-2.2"
      },
      {
        /// Afslagpeil
        keyName: gettext("Stop level"),
        attrName: "stop_level",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.stop_level | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "-2.8"
      }
    ]
  };

  this.pumped_drainage_area = {
    rows: [
    ]
  };

  this.sluice = {
    rows: [
      {
        keyName: gettext("Name"),
        attrName: "name",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.name",
        valueSuffix: "",
        defaultValue: 'onbekend'
      }
    ]
  };

  this.wastewatertreatmentplant = {
    rows: [ //Afvalwaterzuiveringsinstallatie
      {
        keyName: gettext("Name"),
        attrName: "name",
        ngBindValue: "waterchain.layers.waterchain_grid.data.name",
        valueSuffix: "",
        defaultValue: "onbekend"
      },
    ]
  };

  this.weir = {
    rows: [
      {
        keyName: gettext("Code"),
        attrName: "code",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.code",
        valueSuffix: "",
        defaultValue: "473"
      },
      {
        keyName: gettext("Width"),
        attrName: "crest_width",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.crest_width | niceNumberOrEllipsis: 2",
        valueSuffix: " (m)",
        defaultValue: "1.6"
      },
      {
        /// Niveau
        keyName: gettext("Crest Level"),
        attrName: "crest_level",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.crest_level | niceNumberOrEllipsis: 2",
        valueSuffix: " (mNAP)",
        defaultValue: "-0.3"
      },
      {
        /// Bediening
        keyName: gettext("Control"),
        attrName: "controlled",
        ngBindValue:
          "waterchain.layers.waterchain_grid.data.controlled | lookupWeirControl",
        valueSuffix: "",
        defaultValue: "RTC"
      },
    ]
  };

}]);

angular.module('omnibox')
  .service('DateParser', [function DateParser () {

    var moment = window.moment;

    moment().locale('nl');

    var HOUR = moment.duration(1, 'hour');
    var DAY = moment.duration(1, 'day');
    var MONTH = moment.duration(1, 'month');
    var YEAR = moment.duration(1, 'year');

    /**
     * Ordered object of date formats, with zoom intervals. First match is
     * preferred. Non specified values default to the current date, also when
     * in the future. 03-10 results in 3rd of november while 03-13 results in
     * the 13th of march.
     */
    var FORMATS_INTERVALS = {
      'DD': DAY, // 21
      // 'DD MM': DAY,  // 21-04 (Clashes with YYYY for 2000 - 2012)
      'DD MM YYYY': DAY, // 21-04-2013
      'DD MM YYYY HH': HOUR, // 21-04-2013 11
      'DD MMM': DAY, // 21 april
      'DD MMM YYYY': DAY, // 21 april 2013
      'DD MMM YYYY HH': HOUR, // 21 april 2013 11
      'MM DD': DAY, // 04-21
      'MMM': MONTH, // april 21
      'MMM DD': DAY, // april 21
      'MM YYYY': MONTH, // 04-2013
      'MMM YYYY': MONTH, // april 2013
      'YYYY': YEAR, // 2013
      'YYYY MM': MONTH, // 2013-04
      'YYYY MMM': MONTH, // 2013 april
      'YYYY MM DD': DAY, // 2013-04-21
      'YYYY MM DD HH': HOUR, // 2013-04-21 11
      'YYYY MMM DD': DAY, // 2013 april 21
      'YYYY MMM DD HH': HOUR, // 2013 april 21 11
    };

    /**
     * Lookup for display formats from ISO duration representations to display
     * format strings.
     */
    var FORMAT_STRINGS = {
      'PT1H': 'DD MMMM YYYY, HH uur',
      'P1D': 'DD MMMM YYYY',
      'P1M': 'MMMM YYYY',
      'P1Y': 'YYYY'
    };

    // add ISO date support http://en.wikipedia.org/wiki/ISO_8601
    var formatters = Object.keys(FORMATS_INTERVALS);
    formatters.push(moment.ISO_8601);

    /**
     * Takes a string and attempts to parse it using a list of formatter
     * strings. Return a moment.js moment and adds a nxt specific nxtInterval
     * containing the interval beloning to the matched format as a moment.js
     * duration and a nxtFormatString containing the format stirng that should
     * be used for display.
     *
     * Example: dString 'maa 2015' gets a moment.js duration of 1 month. And
     * a format string of 'MMMM YYYY' which will parse the moment as
     * 'Maart 2015'.
     *
     * @param  {string} dString string to match a date to.
     * @return {moment} moment with a moment duration under nxtInterval and a
     *                         display format under nxtFormatString.
     */
    var parser = function (dString) {
      var m = moment(dString, formatters);
      m.nxtInterval = FORMATS_INTERVALS[m._f] || HOUR;
      m.nxtFormatString = FORMAT_STRINGS[m.nxtInterval.toString()];
      return m;
    };

    return parser;

  }
]);

'use strict';

/**
 * @ngdoc service
 * @name lizardClientApp.SearchService
 * @description
 * # SearchService
 * Service in the lizardClientApp.
 */
angular.module('omnibox')
  .service('SearchService',
    ['LeafletService', 'CabinetService', 'DateParser',
    function SearchService (LeafletService, CabinetService, dateParser) {

    this.responseStatus = {
        OK: 'OK',
        ZERO_RESULTS: 'ZERO_RESULTS',
        OVER_QUERY_LIMIT: 'OVER_QUERY_LIMIT',
        REQUEST_DENIED: 'REQUEST_DENIED',
        INVALID_REQUEST: 'INVALID_REQUEST',
        UNKNOWN_ERROR: 'UNKNOWN_ERROR'
    };

    /**
     * Sends searchstring to date parser and geocoder resource.
     *
     * @param  {str} searchString used to query geocoder and parse date.
     * @param  {object} spatialState to use in biasing geocoder to current view.
     * @return {object.promise and object.moment} moment is a moment.js object
     *                                            promise resolves with response
     *                                            from geocoder.
     */
    this.search = function (searchString, state) {
      // TODO: request results in portals language and restrict results based
      // on portal by adding: components: 'country:NL'.
      var prom = CabinetService.geocode.get({
        address: searchString,
        language: state.language, // Preferred language of search results.
        bounds: // Prefer results from the current viewport
          state.spatial.bounds.getSouth() + ',' +
          state.spatial.bounds.getWest() + '|' +
          state.spatial.bounds.getNorth() + ',' +
          state.spatial.bounds.getEast()
      });
      var moment = dateParser(searchString);
      return {
        spatial: prom,
        temporal: moment
      };
    };

    /**
     * Zooms to result of geocoder. If result is precise it also simulates a
     * click on the result.
     * @param  {object} result google geocoder result.
     */
    this.zoomToGoogleGeocoderResult = function (result, state) {
      state.spatial.bounds = LeafletService.latLngBounds(
        LeafletService.latLng(result.geometry.viewport.southwest),
        LeafletService.latLng(result.geometry.viewport.northeast)
      );
      if (result.geometry.location_type === 'ROOFTOP') { // Precise location
        state.spatial.here = LeafletService.latLng(result.geometry.location);
      }
      return state;
    };

  }
]);

'use strict';

/**
 * @ngdoc
 * @memberOf app
 * @class pointCtrl
 * @name pointCtrl
 * @description point is the controller of the point template.
 * It gathers all data belonging to a location in space. It becomes active
 * by setting box.type to 'point' and is updated by when State.spatila.here
 * changes
 */

angular.module('omnibox')
.controller('PointCtrl', [

  '$scope',
  '$q',
  'LeafletService',
  'ClickFeedbackService',
  'UtilService',
  'MapService',
  'DataService',
  'State',

  function (
    $scope,
    $q,
    LeafletService,
    ClickFeedbackService,
    UtilService,
    MapService,
    DataService,
    State
  ) {

    var GRAPH_WIDTH = 600;
    $scope.box.content = {};

    /**
     * @function
     * @memberOf app.pointCtrl
     * @param  {L.LatLng} here
     */
    var fillpoint = function (here) {
      ClickFeedbackService.drawCircle(MapService, here);
      ClickFeedbackService.startVibration(MapService);
      var aggWindow = State.temporal.aggWindow;
      var promise = $scope.fillBox({
        geom: here,
        start: State.temporal.start,
        end: State.temporal.end,
        aggWindow: aggWindow
      });

      // Draw feedback when all promises resolved
      promise.then(drawFeedback, null, function (response) {
        if (response && response.data) {
          // If we deal with raster data....
          if (response.layerSlug === 'rain' &&
              response.data && response.data.data !== null) {
            if ($scope.box.content[
                  response.layerGroupSlug] === undefined) { return; }
            if (!$scope.box.content[response.layerGroupSlug].layers.hasOwnProperty(response.layerSlug)) { return; }

            // This could probably be different..
            $scope.box.content[response.layerGroupSlug].layers[response.layerSlug].changed =
              !$scope.box.content[response.layerGroupSlug].layers[response.layerSlug].changed;
            $scope.box.content[response.layerGroupSlug].layers[response.layerSlug].aggWindow = aggWindow;
          }
        }
      });
    };

    /**
     * @function
     * @memberOf app.pointCtrl
     * @description Wrapper to improve readability
     */
    var fillPointHere = function () {
      if (State.spatial.here) {
        fillpoint(State.spatial.here);
      }
    };

    /**
     * @function
     * @memberOf app.pointCtrl
     * @description Draw visual feedback after client clicked on the map
     */
    var drawFeedback = function (reason) {
      if (reason === 'overridden') { return; } // keep vibrating, other calls
                                               // will finish.
      var feedbackDrawn = false;
      var drawVectorFeedback = function (content) {
        angular.forEach(content, function (lg) {
          if (lg && lg.layers) {
            angular.forEach(lg.layers, function (layer) {
              if (layer.format === 'Vector' && layer.data.length > 0) {
                ClickFeedbackService.drawGeometry(
                  MapService,
                  layer.data
                );
                ClickFeedbackService.vibrateOnce();
                feedbackDrawn = true;
              }
            });
          }
        });
      };

      var drawUTFGridFeedback = function (content) {
        if (content.waterchain && content.waterchain.layers.waterchain_grid) {
          var feature = {
            type: 'Feature',
            geometry: angular.fromJson(content.waterchain.layers.waterchain_grid.data.geom),
            properties: {
              entity_name: content.waterchain.layers.waterchain_grid.data.entity_name,
              type: content.waterchain.layers.waterchain_grid.data.type || ''
            }
          };
          ClickFeedbackService.drawGeometry(
            MapService,
            feature
          );
          ClickFeedbackService.vibrateOnce();
          feedbackDrawn = true;
        }
      };

      var drawStoreFeedback = function (content) {
        if (!feedbackDrawn) {
          angular.forEach(content, function (lg) {
            if (lg && lg.layers) {
              angular.forEach(lg.layers, function (layer) {
                if (layer.format === 'Store' && layer.data.length > 0) {
                  ClickFeedbackService.drawArrow(MapService, State.spatial.here);
                  feedbackDrawn = true;
                }
              });
            }
          });
        }
      };

      ClickFeedbackService.emptyClickLayer(MapService);
      drawVectorFeedback($scope.box.content);
      drawUTFGridFeedback($scope.box.content);
      drawStoreFeedback($scope.box.content);
      if (!feedbackDrawn) {
        ClickFeedbackService.vibrateOnce({
          type: 'Point',
          coordinates: [State.spatial.here.lng, State.spatial.here.lat]
        });
      }
    };

    $scope.isUrl = UtilService.isUrl;

    // CSV formatter
    $scope.formatCSVColumns = function (data) {
      return UtilService.formatCSVColumns(data, State.spatial.here);
    };

    // Update when user clicked again
    $scope.$watch(State.toString('spatial.here'), function (n, o) {
      if (n === o) { return; }
      fillPointHere();
    });

    // Update when layergroups have changed
    $scope.$watch(State.toString('layerGroups.active'), function (n, o) {
      if (n === o) { return; }
      if (State.spatial.here
        && State.spatial.here.lat
        && State.spatial.here.lng) {
        fillPointHere();
      }
    });

    $scope.$watch(State.toString('temporal.timelineMoving'), function (n, o) {
      if (!State.temporal.timelineMoving) {
        if (State.spatial.here
          && State.spatial.here.lat
          && State.spatial.here.lng) {
          fillPointHere();
        }
      }
    });

    // Clean up stuff when controller is destroyed
    $scope.$on('$destroy', function () {
      DataService.reject('omnibox');
      $scope.box.content = {};
      State.spatial.points = [];
      ClickFeedbackService.emptyClickLayer(MapService);
    });
  }
]);

angular.module('omnibox')
.controller("rain", [
  'RasterService',
  'UtilService',
  'State',
  '$scope',

  function (

    RasterService,
    UtilService,
    State,
    $scope

  ) {

      /*
       * @description
       * angular isolate scope is messed with
       * when you using ng-if. This looks to parent
       * model and sets the local fullDetails.
       */
      $scope.$watch('box.fullDetails.rain', function (n) {
        $scope.fullDetails = n;
      });


      $scope.rrc = {
        active: false
      };

      $scope.recurrenceTimeToggle = function () {
        if (!$scope.$$phase) {
          $scope.$apply(function () {
            $scope.rrc.active = !$scope.rrc.active;
            $scope.lg.layers['rain'].changed =
             !$scope.lg.layers['rain'].changed;
          });
        } else {
          $scope.rrc.active = !$scope.rrc.active;
          $scope.lg.layers['rain'].changed = !$scope.lg.layers['rain'].changed;
        }
      };


      $scope.$watch("lg.layers['rain'].changed", function (n, o) {
        if (n === o || !$scope.rrc.active) { return; }
        getRecurrenceTime();
      });

      var getRecurrenceTime = function () {
        $scope.rrc.data = null;

        // TODO: refactor this shit
        RasterService.getData(
          'RainController',
          {slug: 'rain'},
          {
            agg: 'rrc',
            geom: State.spatial.here,
            start: State.temporal.start,
            end: State.temporal.end
          }
        ).then(function (response) {
          $scope.rrc.data = response;
        });
      };
    }
]);

angular.module('omnibox')
  .controller('LineCtrl', [

  '$scope',
  'RasterService',
  'ClickFeedbackService',
  'UtilService',
  '$q',
  'MapService',
  'DataService',
  'CSVService',
  'State',

  function (

    $scope,
    RasterService,
    ClickFeedbackService,
    UtilService,
    $q,
    MapService,
    DataService,
    CSVService,
    State) {

    $scope.box.content = {};

    /**
     * @function
     * @memberOf app.lineCtrl
     * @description Gets data from DataService
     * @param  array of L.LatLng objects describing the line.
     */
    var fillLine = function (line) {
      ClickFeedbackService.startVibration(MapService);
      //TODO draw feedback when loading data
      var promise = $scope.fillBox({
        geom: line,
        start: State.temporal.start,
        end: State.temporal.end,
        aggWindow: State.temporal.aggWindow
      });
      // Draw feedback when all promises are resolved
      promise.then(drawFeedback, drawFeedback, function (response) {
        if (response && response.data
           && response.layerSlug === 'dem/nl'
           // Prevent trying to fill $scope.box.content[response.layerGroupSlug]
           // when retrieved data wasn't rich enough for it's initialization:
           && $scope.box.content[response.layerGroupSlug]
        ) {
          // NB! In the backend, this data is already converted from degrees
          // to meters.
          $scope.box.content[response.layerGroupSlug]
            .layers[response.layerSlug]
            .data = response.data;
        } else if (response.layerSlug === 'rain') {
          // We dont wanna show intersect for rain (d.d. 20-01-2015)
          if ($scope.box.content[response.layerGroupSlug]
            && $scope.box.content[response.layerGroupSlug].layers.rain) {
            delete $scope.box.content[response.layerGroupSlug].layers.rain;
          }
        } else if (response.data && response.data !== 'null'
          && response.format === 'Store'
          && (response.scale === 'ratio' || response.scale === 'interval')
          && DataService.layerGroups[response.layerGroupSlug].temporal) {

          $scope.box.content[response.layerGroupSlug]
            .layers[response.layerSlug]
            .temporalData = response.data;

          $scope.box.content[response.layerGroupSlug]
            .layers[response.layerSlug]
            .data = UtilService.createDataForTimeState(
              $scope.box.content[response.layerGroupSlug]
                .layers[response.layerSlug]
                .temporalData,
              State.temporal
            );
        }
      });
    };

    /**
     * @function
     * @memberOf app.LineCtrl
     * @Description Looks a $scope.box.content to draw feedback
     *              for Store layers with data or provides feedback
     *              for not recieving any data.
     */
    var drawFeedback = function () {
      var feedbackDrawn = false;
      angular.forEach($scope.box.content, function (lg) {
        if (lg && lg.layers) {
          angular.forEach(lg.layers, function (layer) {
            if (layer && layer.data && layer.data.length > 0) {
              ClickFeedbackService.emptyClickLayer(MapService);
              ClickFeedbackService.drawLine(State.spatial.points[0], State.spatial.points[1], false);
              ClickFeedbackService.vibrateOnce();
              feedbackDrawn = true;
            }
          });
        }
      });
      if (!feedbackDrawn) {
        ClickFeedbackService.emptyClickLayer(MapService);
        ClickFeedbackService.vibrateOnce({
          type: 'LineString',
          coordinates: [
            [State.spatial.points[0].lng, State.spatial.points[0].lat],
            [State.spatial.points[1].lng, State.spatial.points[1].lat]
          ]
        });
      }
    };

    /**
     * Updates firsClick and or secondClick and draws
     * appropriate feedback
     *
     * It either:
     *   1. Removes the current line
     *   2. Sets firstClick and draws a tiny line from the first
     *      click to the current pos of mouse.
     *   3. Sets the second click and draws the lne from
     *      the first to the second.
     */
    $scope.$watch(State.toString('spatial.here'), function (n, o) {
      if (n === o) { return true; }
      ClickFeedbackService.emptyClickLayer(MapService);
      if (State.spatial.points.length === 2) {
        State.spatial.points = [];
        // Empty data element since the line is gone
        $scope.box.content = {};
      } else {
        if (State.spatial.points.length === 1) {
          State.spatial.points[1] = State.spatial.here;
          ClickFeedbackService.drawLine(State.spatial.points[0], State.spatial.points[1], false);
          fillLine(State.spatial.points);
        } else {
          State.spatial.points[0] = State.spatial.here;
          ClickFeedbackService.drawLine(State.spatial.points[0], State.spatial.userHere, true);
        }
      }
    });

    var watchIfUrlCtrlSetsPoints = $scope.$watch(State.toString('spatial.points'), function (n, o) {
      if (State.spatial.points.length === 2) {
        ClickFeedbackService.emptyClickLayer(MapService);
        ClickFeedbackService.drawLine(State.spatial.points[0], State.spatial.points[1], false);
        fillLine(State.spatial.points);
        // Delete this watch
        watchIfUrlCtrlSetsPoints();
      }
    });

    /**
     * Updates line according to geo-pos of mouse
     */
    $scope.$watch(State.toString('spatial.userHere'), function (n, o) {
      if (n === o) { return true; }
      if (State.spatial.points[0] && !State.spatial.points[1]) {
        ClickFeedbackService.emptyClickLayer(MapService);
        ClickFeedbackService.drawLine(State.spatial.points[0], State.spatial.userHere, true);
      }
    });

    /**
     * Updates line data when users changes layers.
     */
    $scope.$watch(State.toString('layerGroups.active'), function (n, o) {
      if (n === o) { return true; }
      if (State.spatial.points.length === 2) {
        ClickFeedbackService.emptyClickLayer(MapService);
        ClickFeedbackService.drawLine(State.spatial.points[0], State.spatial.points[1], false);
        fillLine(State.spatial.points);
      }
    });

    /**
     * Updates line of temporal layers when timeState.at changes.
     */
    $scope.$watch(State.toString('temporal.at'), function (n, o) {
      angular.forEach($scope.box.content, function (lg, slug) {
        if (DataService.layerGroups[slug].temporal) {
          angular.forEach(lg.layers, function (layer) {
            if (layer.format === 'Store'
              && (layer.scale === 'ratio' || layer.scale === 'interval')) {
              layer.data = UtilService.createDataForTimeState(layer.temporalData, State.temporal);
            }
          });
        }
      });
    });

    /**
     * Reload data from temporal rasters when temporal zoomended.
     */
    $scope.$watch(State.toString('temporal.timelineMoving'), function (n, o) {
      if (n === o) { return true; }
      if (!State.temporal.timelineMoving
        && State.spatial.points.length === 2) {
        fillLine(State.spatial.points);
      }
    });

    /**
     * Legacy function to draw 'bolletje'
     *
     * TODO
     */
    var circle;
    // Callback for mousemoved over graphs.
    this.mouseLocFn = function (position) {
      if (State.spatial.points[0] === undefined ||
          State.spatial.points[1] === undefined) {
        return;
      }

      if (position !== undefined) {

        // local vars declaration.
        var lat1, lat2, lon1, lon2, maxD, d, r, dLat, dLon, posLat, posLon;

        lat1 = State.spatial.points[0].lat;
        lat2 = State.spatial.points[1].lat;
        lon1 = State.spatial.points[0].lng;
        lon2 = State.spatial.points[1].lng;
        maxD = Math.sqrt(Math.pow((lat2 - lat1), 2) +
                         Math.pow((lon2 - lon1), 2));
        d = UtilService.metersToDegs(position);
        r = d / maxD;
        dLat = (lat2 - lat1) * r;
        dLon = (lon2 - lon1) * r;
        posLat = dLat + lat1;
        posLon = dLon + lon1;
        if (circle === undefined) {
          circle = L.circleMarker([posLat, posLon], {
              color: '#c0392b',
              opacity: 1,
              fillOpacity: 1,
              radius: 5
            });
          MapService.addLeafletLayer(circle);
        } else {
          circle.setLatLng([posLat, posLon]);
        }

      }

      else {
        if (circle !== undefined) {
          MapService.removeLeafletLayer(circle);
          circle = undefined;
        }
      }

    };

    /**
     * Clean up all drawings on box change and reject data.
     */
    $scope.$on('$destroy', function () {
      DataService.reject('omnibox');
      $scope.box.content = {};
      State.spatial.points = [];
      ClickFeedbackService.emptyClickLayer(MapService);
    });

    $scope.formatLineCSV = CSVService.formatLineCSV;
    $scope.getLineCSVHeaders = CSVService.getLineCSVHeaders;
  }
]);

/**
 * @ngdoc
 * @class regionCtrl
 * @memberOf omnibox
 * @name RegionCtrl
 * @description
 *
 * Reguests data for the active region When box.type is region. Regions are
 * spatial areas such as administrative boundaries or watersheds.
 *
 * Contains data of all active raster layers with an aggregation_type
 *
 */
angular.module('omnibox')
.controller('RegionCtrl', [

  '$scope',
  'CabinetService',
  'NxtRegionsLayer',
  'DataService',
  'State',

  function (

    $scope,
    CabinetService,
    NxtRegionsLayer,
    DataService,
    State

  ) {

    /**
     * Removes data from scope, cancels requests and removes active region from
     * State.
     */
    var rmDataAndRequest = function () {
      DataService.reject('omnibox');
      $scope.box.content = {};
      State.spatial.region = {};
    };


    /**
     * Callback for clicks on regions. Calls fillRegion.
     *
     * @param  {leaflet ILayer} layer that recieved the click.
     */
    var clickCb = function (layer) {
      State.spatial.region = layer.feature;
      fillRegion(State.spatial.region);
    };

    /**
     * Calls fillbox of omnibox scope and sets the name of the region on thes
     * scope.
     *
     * @param  {geojson feature object} feature describing the region.
     */
    var fillRegion = function (feature) {
      var HECTARE_IN_M2 = 10000,
      KM2_IN_HECTARE = 100;

      $scope.activeName = feature.properties.name;
      $scope.regionArea = Math.round(feature.properties.area /
                                     HECTARE_IN_M2);

      $scope.fillBox({
        geom_id: feature.id,
        boundary_type: feature.properties.type,
        // apparantly this cannnot be left out because of some type check.
        geom: feature.geometry,
        start: State.temporal.start,
        end: State.temporal.end,
        aggWindow: State.temporal.aggWindow
      })
      // Rain sums are returned as the sum of all pixels. Its is assumed here
      // that pixels are 1 km^2. So we normalize the data to get one dimensional
      // values, rain in mm.
      .then(null, null, function (response) {
        var rain = response.layerSlug === 'rain'
          && $scope.box.content.rain
          && $scope.box.content.rain.layers.rain;
        if (rain) {
          angular.forEach(rain.data, function (value) {
            value[1] = value[1] / $scope.regionArea * KM2_IN_HECTARE;
          });
        }
      });
    };

    /**
     * Makes call to api for regions of the given bounds and zoom and calls
     * NxtRegionsLayer.add function with  response.
     */
    var getRegions = function () {
      CabinetService.regions.get({
        z: State.spatial.view.zoom,
        in_bbox: State.spatial.bounds.getWest()
          + ','
          + State.spatial.bounds.getNorth()
          + ','
          + State.spatial.bounds.getEast()
          + ','
          + State.spatial.bounds.getSouth()
      })
      .then(function (regions) {
        NxtRegionsLayer.add(regions.results, clickCb);

        // If the new regions do not contain the current active region, rm the
        // data  and the references to it.
        if (NxtRegionsLayer.getActiveRegion() !== $scope.activeName) {
          rmDataAndRequest();
        }
      });
    };

    // init
    getRegions();

    /**
     * Updates regions when user moves map.
     */
    $scope.$watch(State.toString('spatial.bounds'), function (n, o) {
      if (n === o) { return true; }
      getRegions();
    });

    /**
     * Updates region data when users changes layers.
     */
    $scope.$watch(State.toString('layerGroups.active'), function (n, o) {
      if (n === o) { return true; }
      getRegions();
    });

    /**
     * Update box.content when time changed.
     */
    $scope.$watch(State.toString('temporal.timelineMoving'), function (n, o) {
      if (!State.temporal.timelineMoving) {
        region = State.spatial.region;
        if (region && region.properties && region.properties.name) {
          fillRegion(State.spatial.region);
        }
      }
    });



    // Clean up stuff when controller is destroyed
    $scope.$on('$destroy', function () {
      rmDataAndRequest();
      NxtRegionsLayer.remove();
    });

  }]);

/**
 * @ngdoc
 * @class areaCtrl
 * @memberOf app
 * @name areaCtrl
 * @description
 * area is the object which collects different
 * sets of aggregation data. If there is no activeObject,
 * this is the default collection of data to be shown in the
 * client.
 *
 * Contains data of all active layers with an aggregation_type
 *
 */
angular.module('omnibox')
.controller('AreaCtrl', [

  '$scope',
  'RasterService',
  'UtilService',
  '$q',
  'DataService',
  'State',

  function (

    $scope,
    RasterService,
    UtilService,
    $q,
    DataService,
    State

  ) {

    $scope.box.content = {};

    /**
     * @function
     * @memberOf app.areaCtrl
     * @description
     * Gets data from DataService.
     * @param  {object} bounds   mapState.bounds, containing
     *                                  leaflet bounds.
     */
    var fillArea = function (bounds) {
      $scope.fillBox({
        geom: bounds,
        start: State.temporal.start,
        end: State.temporal.end,
        aggWindow: State.temporal.aggWindow
      });
    };

    /**
     * Updates area when user moves map.
     */
    $scope.$watch(State.toString('spatial.bounds'), function (n, o) {
      if (n === o) { return true; }
      fillArea(State.spatial.bounds);
    });

    /**
     * Updates area when users changes layers.
     */
    $scope.$watch(State.toString('layerGroups.active'), function (n, o) {
      if (n === o) { return true; }
      fillArea(State.spatial.bounds);
    });

    $scope.$watch(State.toString('temporal.timelineMoving'), function (n, o) {
      if (n === o) { return true; }
      fillArea(State.spatial.bounds);
    });

    $scope.$watch(State.toString('temporal.aggWindow'),
        function (n, o) {
      if (n === o) { return true; }
      fillArea(State.spatial.bounds);
    });

    // Load data at initialization.
    fillArea(State.spatial.bounds);

    // Make UtilSvc functions available in Angular templates
    $scope.countKeys = UtilService.countKeys;

    // Clean up stuff when controller is destroyed
    $scope.$on('$destroy', function () {
      DataService.reject('omnibox');
      $scope.box.content = {};
    });
  }
]);


/**
 * Template directives.
 *
 * * Timeseries
 * * Cardtitle
 * * Event aggregation
 * * Actions
 * * Cardattributes
 * * Detailswitch
 *
 */
angular.module('omnibox')
  .directive('cardattributes', ['WantedAttributes',
    function (WantedAttributes) {
  return {
    link: function (scope) { scope.wanted = WantedAttributes; },
    restrict: 'E',
    scope: {
      waterchain: '='
    },
    replace: true,
    templateUrl: 'omnibox/templates/cardattributes.html'
  };
}]);

angular.module('omnibox')
  .directive('nestedasset', ['WantedAttributes', 'DataService',
    function (WantedAttributes, DataService) {
  return {
    link: function (scope) {

      scope.wanted = WantedAttributes;

      /**
       * Watch asset unpack json string, add entity name and select first child
       * asset.
       */
      scope.$watch('asset', function () {
        scope.attr = scope.asset.pumps ? 'pump' : 'filter';
        scope.list = JSON.parse(scope.asset[scope.attr + 's']);
        angular.forEach(scope.list, function (asset) {
          asset.entity_name = scope.attr;
        });
        scope.asset.selectedAsset = scope.list[0];
      });

    },
    restrict: 'E',
    scope: {
      asset: '=',
    },
    replace: true,
    templateUrl: 'omnibox/templates/nestedasset.html'
  };
}]);

angular.module('omnibox')
  .directive('rain', [function () {
  return {
    restrict: 'E',
    replace: true,
    templateUrl: 'omnibox/templates/rain.html'
  };
}]);

angular.module('omnibox')
  .directive('defaultpoint', [function () {
  return {
    restrict: 'E',
    scope: {
      lg: '=',
      state: '=',
      isUrl: '='
    },
    replace: true,
    templateUrl: 'omnibox/templates/defaultpoint.html'
  };
}]);

angular.module('omnibox')
  .directive('detailswitch', [function () {
  return {
    restrict: 'E',
    templateUrl: 'omnibox/templates/detailswitch.html'
  };
}]);

angular.module('omnibox')
  .directive('searchResults', [function () {
  return {
    restrict: 'E',
    templateUrl: 'omnibox/templates/search-results.html'
  };
}]);


'use strict';

/**
 * @description directive that displays search
 * and makes sure the right services are called.
 */
angular.module('omnibox')
  .directive('search', [
    'SearchService',
    'ClickFeedbackService',
    'MapService',
    'State',
    'UtilService',
  function (SearchService, ClickFeedbackService, MapService, State, UtilService) {

  var link = function (scope, element, attrs) {

    // Set focus on search input field.
    element.children()[0].focus();

    /**
     * Uses scope.query to search for results through SearchService. Response
     * from SearchService.search is an object with various results and promises.
     *
     * Currently searches for time and addresses.
     *
     * scope.box.content.searchResults is used by search-results template.
     */
    scope.search = function () {
      scope.box.content.searchResults = {};
      if (scope.query.length > 0) {
        var results = SearchService.search(scope.query, State);
        setResultsOnBox(results);
      }
    };

    /**
     * @description resets input field
     * on scope, because also needs to trigger on reset button,
     * not just on succesful search/zoom.
     *
     * @description - This does the following:
     *
     * (1) - Reset box.type to it's default value, "point";
     * (2) - Reset the search query to the empty string;
     * (3) - Reset box.content to an empty object;
     * (4) - Clear mapState.points arr (used for updating the Url);
     * (5) - Clear the click feedback.
     */
    scope.cleanInput = function () {
      State.box.type = "point";
      scope.query = "";
      scope.box.content = {};
      State.spatial.points = [];
      State.spatial.here = undefined;
      ClickFeedbackService.emptyClickLayer(MapService);
    };

    /**
     * @description zooms to geocoder search result
     * @param {object} one search result.
     */
    scope.zoomToSpatialResult = function (location) {
      destroySearchResultsModel();
      scope.cleanInput();
      State = SearchService.zoomToGoogleGeocoderResult(location, State);
    };

    /**
     * Called by click on temporal result. Cleans results and search box and
     * Zooms to moment.js moment with nxtInterval.
     * @param  {moment} m moment.js moment with nxtInterval as a moment
     *                              duration.
     */
    scope.zoomToTemporalResult = function(m) {
      destroySearchResultsModel();
      scope.cleanInput();
      State.temporal.start = m.valueOf();
      State.temporal.end = m.valueOf() + m.nxtInterval.valueOf();
      UtilService.announceMovedTimeline(State);
    };

    /**
     * @description event handler for key presses.
     * checks if enter is pressed, does search.
     * @param {event} event that is fired.
     * 13 refers to the RETURN key.
     */
    scope.searchKeyPress = function ($event) {
      var KEYPRESS = {
        ENTER: 13,
        SPACE: 32,
        ESC: 27
      };

      if ($event.target.id === "searchboxinput") {
        // Intercept keyPresses *within* searchbox,do xor prevent animation
        // from happening when typing.
        if ($event.which === KEYPRESS.ENTER) {
          var loc = scope.box.content.searchResults;
          if (loc && loc.temporal) {
            scope.zoomToTemporalResult(
              scope.box.content.searchResults.temporal
            );
          }
          else if (loc && loc.spatial && loc.spatial[0]) {
            scope.zoomToSpatialResult(
              scope.box.content.searchResults.spatial[0]
            );
          }
          else {
            scope.search();
          }
        } else if ($event.which === KEYPRESS.SPACE) {
          // prevent anim. start/stop
          $event.originalEvent.stopPropagation();
        } else if ($event.which === KEYPRESS.ESC) { //esc
          scope.cleanInput();
        }
      }
    };

    /**
     * Contains the logic to go through search result and puts relevant parts on
     * box scope.
     *
     * When time is a valid moment it is synchronously put on
     * scope.box.content.searchResults.temporal. If time is not valid it waits
     * for spatial results and puts those result on
     * scope.box.content.searchResults.spatial. Prefers temporal results to
     * spatial results.
     *
     * @param {object.promise and object.moment} results
     * moment is a moment.js object
     * promise resolves with response from geocoder.
     */
    var setResultsOnBox = function (results) {
      if (
        results.temporal.isValid()
        && results.temporal.valueOf() > UtilService.MIN_TIME
        && results.temporal.valueOf() < UtilService.MAX_TIME
        ) {
        scope.box.content.searchResults.temporal = results.temporal;
        // moment object.
      }

      else {
        results.spatial
          .then(function (response) {
            // Asynchronous so check whether still relevant.
            if (scope.box.content.searchResults === undefined) { return; }

            // Either put results on scope or remove model.
            if (response.status === SearchService.responseStatus.OK) {
              scope.box.content.searchResults.spatial = response.results;
            }
            // Only destroy asynchronous when following searches did not find
            // a date either.
            else if (scope.box.content.searchResults.temporal === undefined) {
              destroySearchResultsModel();

              if (
                response.status !== SearchService.responseStatus.ZERO_RESULTS
              ) {
                // Throw error so we can find out about it through sentry.
                throw new Error(
                  'Geocoder returned with status: ' + response.status
                );
              }

            }
          }
        );
      }
    };

    /**
     * @description removes location model from box content
     */
    var destroySearchResultsModel = function () {
      delete scope.box.content.searchResults;
    };

  };

  return {
    link: link,
    restrict: 'E',
    replace: true,
    templateUrl: 'omnibox/templates/search.html'
  };

}]);


'use strict';

angular.module("omnibox")
  .directive("omnibox", ["$compile", "$templateCache", "UtilService", "State",
    function ($compile, $templateCache, UtilService, State) {

    var getTemplate = function (scope, contentType) {
      if (contentType === undefined) {
        contentType = 'area';
      }

      var templateUrl = 'omnibox/templates/' + contentType + '.html';
      return $templateCache.get(templateUrl);
    };

    var linker = function (scope, element, attrs) {

      var oldScope;

      var replaceTemplate = function () {
        var template = getTemplate(scope, State.box.type);
        // We need to manually destroy scopes here when switching templates.
        // It is necessary to do this *before* withching templates. Otherwise
        // the new scope is active while the previous on is to and they affect
        // each other.
        if (oldScope) { oldScope.$destroy(); }
        // we don't want the dynamic template to overwrite the search box.
        // NOTE: the reason for selecting the specific child is jqLite does
        // not support selectors. So an element is created of the second child
        // of the directive's element and the first child of that element is
        // transformed into an element and replaced by the point/line/area
        // template. Please replace if you know a nicer way..
        var boxTypeCards = angular.element(
          angular.element(element.children()[1]).children()[0]
        ).replaceWith(template);
        var newScope = scope.$new();
        $compile(element.contents())(newScope);

        oldScope = newScope;
      };

      var finalizeTemplateRendering = function () {
        replaceTemplate();
        scope.box.showCards = State.box.type !== 'empty';
      };

      scope.$watch(State.toString('box.type'), function (n, o) {
        if (n === o) { return true; }
        finalizeTemplateRendering();
      });

      finalizeTemplateRendering();

    };

    return {
      restrict: 'E',
      link: linker,
      templateUrl: 'omnibox/templates/omnibox-search.html'
    };
  }]);


/**
 *
 * Toggle directive for omnibox cards
 *
 * TODO: this directive or an attribute directive should be responsible for
 * making the card small when there is not enough space.
 *
 * TODO 2: use ng-click so we do not have to worry about running a digest cycle
 * manually.
 */
angular.module('lizard-nxt')
  .directive('fullDetails', [function () {

    var link = function (scope, element, attrs) {

      if (scope.fullDetails === undefined) {
        scope.fullDetails = true;
      }

      // does the actual toggling.
      var toggleDetails = function () {
        if (scope.$$phase) {
          scope.fullDetails = !scope.fullDetails;
        } else {
          scope.$apply(function () {
            scope.fullDetails = !scope.fullDetails;
          });
        }
      };

      element.bind('click', toggleDetails);


    };


    return {
      link: link,
      restrict: 'E',
      replace: true,
      scope: false,
      templateUrl: 'omnibox/templates/full-details.html'
    }
  }]);


/**
 * @name TimeLineService
 * @class angular.module('lizard-nxt')
  .TimeLineService
 * @memberOf app
 *
 * @summary Service to create and update a timeline. Used by timeline-directive.
 *
 * @description Inject "Timeline" and call new timeline(<args>) to create a
 * timeline. Currently the timeline supports circles (events) and vertical bars
 * (rain intensity). The user may interact with the timeline through click and
 * zoom functions.
 *
 * Everything in the timeline is animated for NxtD3.transTime milliseconds. To
 * add new elements to the timeline, make sure the elements are updated on zoom,
 * and resize. The timeline resizes *before* elements are added and *after*
 * elements are removed. Therefore resize transitions should be delayed with
 * NxtD3.transTime when the timeline is shrinking, as is happening in
 * resizeTimelineCanvas.
 */
angular.module('lizard-nxt')
  .factory("Timeline", ["NxtD3", "UtilService", function (NxtD3, UtilService) {

  // Timeline
  var initialHeight,

  // D3 components
  xScale, // The d3 scale for placement on the x axis within the whole
          // timeline. Is only updated when zoomTo is called, or the window
          // resizes.
  ordinalYScale, // Scale used to place events in circles for each type

  // Interaction functions
  clicked = null,
  zoomed = null,
  zoomend = null,

  // Timeline elements
  futureIndicator,
  aggWindow, // aggregation window
  circles, // events start - end
  bars, // rain intensity
  tickmarks,
  TICKMARK_HEIGHT = 5, // data availability indicators
  MAX_CIRCLE_SIZE = 16;

  /**
   * @constructor
   * @memberOf angular.module('lizard-nxt')
   * TimeLineService
   *
   * @param {object} element - svg element for the timeline.
   * @param {object} dimensions - object containing, width, height, height per
   *  line of events, height per line of bars and an object containing top,
   *  bottom, left and right padding. All values in px.
   * @param {integer} start - begin value in milliseconds from epoch.
   * @param {integer} end - end value in milliseconds from epoch.
   * @param {object} interaction  - optional object containing callback
   * functions for zoom, click and brush interaction with the rest of the
   *  angular.module('lizard-nxt')
   * @param {integer} nEvents - number of event types (event series).
   */
  function Timeline(element, dimensions, start, end, interaction) {
    NxtD3.call(this, element, dimensions);
    initialHeight = dimensions.height;
    this._svg = this._createDrawingArea();
    this._svg = addElementGroupsToCanvas(this._svg, this.dimensions);
    this._initDimensions = dimensions;
    xScale = this._makeScale(
      {min: start, max: end},
      {min: 0, max: this._getWidth(dimensions)},
      {scale: 'time' }
    );
    drawTimelineAxes(this._svg, xScale, dimensions);
    this.addFutureIndicator();
    this.addInteraction(interaction);
  }

  Timeline.prototype = Object.create(NxtD3.prototype, {

    constructor: Timeline,

    /**
     * @attribute
     * @type function to be used to format datetime.
     */
    format: {
      value: NxtD3
        .prototype._localeFormatter.nl_NL.timeFormat("%a %e %b %Y %H:%M")
    },
    format_aggwindow: {
      value: NxtD3.prototype._localeFormatter.nl_NL.timeFormat("%e %b %-H:%M")
    },

    /**
     * @function
     * @summary Adds a now indicator to timeline.
     * @description From 'now' the background of the timeline gets a different
     * style.
     */
    addFutureIndicator: {
      value: function () {
        var width = 20000,
            height = this._getHeight(this.dimensions);

        futureIndicator = this._svg.select("#feature-group").append("rect")
          .attr("height", height)
          .attr("width", width)
          .attr('title', 'Het gedeelte van de tijdlijn dat in de toekomst ligt')
          .attr("id", "nodata")
          .attr("x", xScale(Date.now()))
          .attr("opacity", 0.8)
          .style("fill", "#DDD");
      }
    },

    addClickListener: {
      value: function (clickFn) {
        if (clickFn) {
          clicked = setClickFunction(
            xScale,
            this.dimensions,
            clickFn,
            this.drawAggWindow
          );
        }
        this._svg.select('#listeners').on("click", clicked);
      }
    },

    removeClickListener: {
      value: function () {
        this._svg.select('#listeners').on("click", null);
      }
    },

    addInteraction: {
      value: function (interaction) {
        if (!interaction) { return; }
        this.addZoomListener(interaction.zoomFn, interaction.zoomEndFn);
        this.addClickListener(interaction.clickFn);
      }
    },

    /**
     * @function
     * @summary Draws an aggWindow at timestamp.
     * @description Left of aggWindow is timeState.at, size is dependent on
     * current aggWindow interval on timeState.
     *
     * TODO: Rasterstore's "day-level aggregated rain intensity data" has
     * discrete one-day/24h intervals (=good), however those intervals are
     * from 8:00 GMT (in the morning) to the next day's 8:00 GMT in the morning
     * (=bad).
     *
     * This doens't play nice with the aggWindow to be drawn, since (for 24h
     * aggregation) this preferably starts on 00:00, and ends 24h later, again
     * on 00:00.
     *
     */
    drawAggWindow: {
      value: function (timestamp, interval, oldDimensions) {
        var height;

        if (!aggWindow) {
          height = this._getHeight(this.dimensions);
          aggWindow = this._svg.select('#feature-group').append("g")
            .attr('class', 'agg-window-group');
          aggWindow
            .append("rect")
              .attr("class", "aggwindow-rect")
              .attr("height", height)
              .attr("x", 0)
              .attr("y", 0);
        }

        aggWindow.select('.aggwindow-rect')
          .attr("x", function () {
            return Math.round(xScale(new Date(timestamp)));
          });

        if (oldDimensions && this.dimensions.height < oldDimensions.height) {
          height = this._getHeight(this.dimensions);
          aggWindow.select('.aggwindow-rect')
            .transition()
            .delay(this.transTime)
            .duration(this.transTime)
            .attr("height", height);
        } else if (oldDimensions) {
          height = this._getHeight(this.dimensions);
          aggWindow.select('.aggwindow-rect')
            .transition()
            .duration(this.transTime)
            .attr("height", height);
        }

        if (interval) {
          var width = xScale(new Date(timestamp + (interval))) -
          xScale(new Date(timestamp));
          aggWindow.select('.aggwindow-rect').attr("width", width);
        }
      }
    },

    /**
     * @function
     * @summary Resizes the timeline.
     * @description Makes a deep copy of the old dimensions, updates canvas,
     * updates all elements, redraws axis.
     *
     * @param {object} dimensions object containing, width, height, height per
     *  line of events, height per line of bars and an object containing top,
     *  bottom, left and right padding. All values in px.
     * @param {int} timestamp - timestamp in milliseconds since epoch.
     * @param {interval} interval - aggregation interval in ms.
     * @param {object} features - geojson object with event features.
     * @param {int} nEvents - number of event types (event series).
     */
    resize: {
      value: function (newDimensions, timestamp, interval, nEvents) {
        var oldDimensions = angular.copy(this.dimensions);
        NxtD3.prototype.resize.call(this, newDimensions);
        this.updateElements(oldDimensions, timestamp, interval);
        this._svg = resizeTimelineCanvas(this._svg, oldDimensions, this.dimensions);

        ordinalYScale = makeEventsYscale(initialHeight, this.dimensions);
        xScale.range([0, newDimensions.width - newDimensions.padding.right]);
        drawTimelineAxes(this._svg, xScale, newDimensions);
      }
    },

    /**
     * @function
     * @summary Update all elements to accomadate new dimensions.
     *
     * @param {object} oldDimensions - copy of the old dimensions
     * @param {int} timestamp - timestamp in milliseconds since epoch.
     * @param {interval} interval - aggregation interval in ms.
     */
    updateElements: {
      value: function (oldDimensions, timestamp, interval) {

        if (bars && oldDimensions) {
          updateRectangleElements(bars, xScale, oldDimensions, this.dimensions);
        }

        if (futureIndicator) {
          updateFutureIndicator(
            futureIndicator,
            xScale,
            oldDimensions,
            this.dimensions
          );
        }

        if (aggWindow) {
          this.drawAggWindow(timestamp, interval, oldDimensions);
        }

        if (tickmarks) {
          updateTickmarks(tickmarks, this.dimensions, oldDimensions);
        }

      }
    },

    /**
     * @function
     * @summary Updates, adds or removes all circles in the data object.
     *
     * @param {array} data array of objects:
     *   [{properties.timestamp_end: timestamp,
     *     properties.timestamp_start: timestamp,
     *     properties.event_series_id: event_series id,
     *     geometry.coordinates: [lat, lon]}]
     * @param {integer} order - Order of events.
     * @param {string} slug - Slug of event layer.
     * @param {string} color - Hex color code.
     */
    drawCircles: {
      value: function (data, order, slug, color, aggWindow) {
        circles = drawCircleElements(
          this._svg,
          this.dimensions,
          xScale,
          ordinalYScale,
          data,
          order,
          slug,
          color,
          aggWindow
        );
      }
    },

    drawTickMarks: {
      value: function (data) {
        tickmarks = drawTickMarkElements(this._svg, this.dimensions, data);
      }
    },

    /**
     * @function
     * @summary Updates, adds or removes all bars in the data object.
     *
     * @param {array} data - array of arrays [[bar_timestamp, bar_height]]
     */
    drawBars: {
      value: function (data) {

        /**
         * candidate to replace with Dirk's null checker function.
         */
        if (data.data === 'null') {
          return false;
        }

        var height = this.dimensions.bars;

        var y = this._maxMin(data, '1');
        var options = {scale: 'linear'};
        var yScale = this._makeScale(
          y,
          {min: 0, max: height},
          options
        );
        bars = drawRectElements(
          this._svg, this.dimensions, data, xScale, yScale);
      }
    },

    /**
     * @function
     * @summary Remove bars from timeline.
     */
    removeBars: {
      value: function () {
        drawRectElements(this._svg, this.dimensions, []);
        bars = undefined;
      }
    },

    /**
     * @function
     * @summary Update domain of scale and call functions to update timeline to
     * new scale.
     *
     * @param {int} start - timestamp in ms since epoch.
     * @param {int} end - timestamp in ms since epoch.
     * @param {int} interval - aggregation window in ms.
     */
    zoomTo: {
      value: function (start, end, interval) {
        xScale.domain([new Date(start), new Date(end)]);
        this.addZoomListener();
        this.drawAggWindow(start, interval);
      }
    },

    addZoomListener: {
      value: function (zoomFn, zoomEndFn) {
        if (zoomFn) {
          zoomed = setZoomFunction(
            this._svg,
            this.dimensions,
            xScale,
            zoomFn
          );
        }
        if (zoomEndFn) {
          zoomend = setZoomEndFunction(zoomEndFn);
        }
        this._svg.select('#listeners').call(d3.behavior.zoom()
          .x(xScale)
          .on("zoom", zoomed)
          .on("zoomend", zoomend)
        );

        // Move listener rectangle to the front
        var el = this._svg.select('#listeners').node();
        el.parentNode.appendChild(el);
      }
    }
  });


  /**
   * @function
   * @summary Draw timeline axes.
   *
   * @param {object} svg - timeline svg elements.
   * @param {object} xAxis - D3 axis object.
   * @param {object} dimensions - dimensions object.
   * @param {int} duration - duration in ms.
   */
  var drawTimelineAxes = function (svg, xScale, dimensions, duration) {
    var width = Timeline.prototype._getWidth(dimensions);
    // The actual d3-axis is smaller than the timeline. The scale is copied
    // and transformed to an axis with a restricted range and domain.
    var xAxisScale = xScale.copy();

    var XAXIS_PADDING = 50;

    xAxisScale
      .domain([
        xScale.invert(XAXIS_PADDING),
        xScale.invert(width - XAXIS_PADDING)
      ])
      .range([XAXIS_PADDING, width - XAXIS_PADDING]);

    var xAxis = Timeline.prototype._makeAxis(
      xAxisScale,
      {orientation: "bottom", ticks: 7}
    );

    Timeline.prototype._drawAxes(svg, xAxis, dimensions, false, duration);
    var axisEl = svg.select('#xaxis')
        .attr("class", "x axis timeline-axis");

    addClickToAxisTicks(axisEl.selectAll('text'));
  };

  /**
   * Takes a d3 multiselection of text elements and add click interaction to
   * zoom to rounded dates.
   * @param {d3 selections} ticks text elements of tick marks.
   */
  var addClickToAxisTicks = function(ticks) {
    ticks
      .each(function (d) {
        if (d.getMinutes() === 0) {
          d3.select(this).attr('class', 'clickable');
        }
      })
      .on('click', zoomToHourDayMonthOrYear);
  };

  /**
   * Gets a date object, typically from a d3 tick mark. If it is a round
   * year|month|day|hour it zooms the timeline and calls zoom callbacks. It does
   * not zoom to minutes and seconds.
   * @param  {date} d
   */
  var zoomToHourDayMonthOrYear = function (d) {
    var end = new Date(d.getTime());
    if (d.getHours() === 0) {
      if (d.getDate() === 1) {
        if (d.getMonth() === 0) {
          xScale.domain([d, end.setYear(d.getFullYear() + 1)]);
        }
        else {
          xScale.domain([d, end.setMonth(d.getMonth() + 1)]);
        }
      }
      else {
        xScale.domain([d, end.setDate(d.getDate() + 1)]);
      }
    }
    else {
      xScale.domain([d, end.setHours(d.getHours() + 1)]);
    }
    zoomed();
    zoomend();
  };

  /**
   * Draw start stop draws the fixed text labels displaying start and stop of
   * the domain.
   *
   * @param  {svg}    svg
   * @param  {scale}  xScale
   * @param  {object} dimensions
   */
  var drawStartStop = function (svg, xScale, dimensions) {
    var format = Timeline.prototype.format,
        height = Timeline.prototype._getHeight(dimensions),
        width = Timeline.prototype._getWidth(dimensions),
        startEl = svg.select('.timeline-start-stop')
          .select('.tick-start').select('text'),
        stopEl = svg.select('.timeline-start-stop')
          .select('.tick-stop').select('text');

    if (!startEl[0][0]) {
      startEl = svg
        .append('g')
        .attr('class', 'timeline-start-stop timeline-axis')
        .attr("transform", "translate(0, " + height + ")")
          .append('g')
          .attr('class', 'tick tick-start')
          .append('text')
            .attr('y', 9)
            .attr('x', dimensions.padding.left)
            .attr('dy', '.71em');

      stopEl = svg.select('.timeline-start-stop')
        .append('g')
          .attr('class', 'tick tick-stop')
          .append('text')
            .attr('y', 9)
            .attr('dy', '.71em');
    }

    startEl
      .text(format(xScale.domain()[0]));
    stopEl
      .text(format(xScale.domain()[1]))
      .attr('x', dimensions.width - dimensions.padding.right
        - stopEl.node().getBBox().width);
  };

  /**
   * @function
   * @summary Creates groups according to dimensions to accomodate all timeline
   * elements
   *
   * @param  {object} svg element to create timeline.
   * @param  {object} dimensions object containing, width, height, height per
   *  line of events, height per line of bars and an object containing top,
   *  bottom, left and right padding. All values in px.
   * @returns {object} svg timeline svg.
   */
  var addElementGroupsToCanvas = function (svg, dimensions) {
    var width = Timeline.prototype._getWidth(dimensions),
    height = Timeline.prototype._getHeight(dimensions);
    // Create group for rain bars
    svg.select('#feature-group').append('g')
      .attr('height', height)
      .attr('width', width)
      .attr('id', 'rain-bar');
    // Create group for circles
    svg.select('#feature-group').append('g')
      .attr('height', height)
      .attr('width', width)
      .attr('id', 'circle-group');
    // Create group for tickmarks
    svg.select('#feature-group').append('g')
      .attr('height', height)
      .attr('width', width)
      .attr('id', 'tickmark-group');

    return svg;

  };

  /**
   * @function
   * @summary Updates the timeline svg. With a delay when getting smaller,
   * without delay when becoming larger.
   *
   * @param  {object} svg - element to create timeline.
   * @param  {object} oldDims - object containing, width, height, height per
   *  line of events, height per line of bars and an object containing top,
   *  bottom, left and right padding. All values in px.
   *  @param {object} newDims - new dimensions, same structure as oldDims.
   */
  var resizeTimelineCanvas = function (svg, oldDims, newDims) {
    var width = Timeline.prototype._getWidth(newDims),
    height = Timeline.prototype._getHeight(newDims);
    if (newDims.height < oldDims.height) {
      svg.transition()
        .delay(Timeline.prototype.transTime)
        .duration(Timeline.prototype.transTime)
        .select("g")
        .attr("transform", "translate(" + newDims.padding.left + ", 0)")
        .select('#xaxis')
        .attr("transform", "translate(0 ," + height + ")");
    } else {
      svg.transition()
        .duration(Timeline.prototype.transTime)
        .select("g")
        .attr("transform", "translate(" + newDims.padding.left + ", 0)")
        .select('#xaxis')
        .attr("transform", "translate(0 ," + height + ")");
    }
    svg.select("#feature-group").selectAll("g")
      .attr("height", height)
      .attr("width", width);
    return svg;
  };

  /**
   * @function
   * @summary Create function that updates all elements to zoom action and
   * calls zoomFn.
   * @description Put all scope specific in the zoom callback from the
   * directive, all the standard (re-)placement of elements in here.
   */
  var setZoomFunction = function (
    svg, dimensions, xScale, zoomFn) {
    var zoomed = function () {
      // might not exist when called programmatically
      if (d3.event.sourceEvent) {
        d3.event.sourceEvent.preventDefault();
      }

      var ONE_HOUR = 1000 * 60 * 60;

      var start = UtilService.getMinTime(xScale.domain()[0].getTime()),
          end = UtilService.getMaxTime(xScale.domain()[1].getTime());

      // Min domain when zooming is ONE_HOUR
      if (start === UtilService.MIN_TIME && end !== UtilService.MAX_TIME) {
        end = end >= start + ONE_HOUR  ? end : start + ONE_HOUR;
      }

      else if (end === UtilService.MAX_TIME && start !== UtilService.MIN_TIME) {
        start = start <= end - ONE_HOUR ? start : end - ONE_HOUR;
      }

      xScale.domain([start, end]);

      drawTimelineAxes(svg, xScale, dimensions);

      if (bars) {
        var barData = bars.data();
        // we need at least 2 elements to calc a new width
        if (barData[1] !== undefined) {
          var newWidth = xScale(barData[1][0]) - xScale(barData[0][0]);
          bars
            .attr("x", function (d) { return xScale(d[0]) - newWidth; })
            .attr('width', newWidth);
        }
      }

      if (futureIndicator) {
        var width = Timeline.prototype._getWidth(dimensions);
        futureIndicator
          .attr('x', xScale(Date.now()));
      }

      if (circles) {
        var xOneFunction = function (d) {
          var interval = 0;
          return xScale(parseFloat(d.timestamp) + (interval / 2));
        };

        d3.select("#circle-group").selectAll("circle")
          .attr("cx", xOneFunction);
      }

      if (tickmarks) {
        updateTickmarks(tickmarks, dimensions);
      }

      if (zoomFn) {
        zoomFn(xScale);
      }
    };

    return zoomed;
  };

  /**
   * @function
   * @summary Create zoomend.
   */
  var setZoomEndFunction = function (zoomEndFn) {
    var zoomend = function () {
      zoomEndFn();
    };
    return zoomend;
  };

  /**
   * @function
   * @summary Creates click function.
   * @description Creates click function. If default is prevented, the click
   * was a zoom.
   */
  var setClickFunction = function (xScale, dimensions, clickFn, drawAggWindow) {
    var clicked = function () {
      // Check whether user is dragging instead of clicking
      if (!d3.event.defaultPrevented) {
        var x = d3.event.clientX
          - UtilService.TIMELINE_LEFT_MARGIN
          - dimensions.padding.left;
        var ts = xScale.invert(x);
        clickFn(ts, dimensions);
      }
    };
    return clicked;
  };

  /**
   * @function
   * @summary Moves rectangle elements to right position relative to the
   * timeline svg and xaxis.
   * @description Everything to the svg is relative to the top left corner, if
   * the timeline grows, the bars need to move further down. The amount is
   * computed from the difference between the old and new dimensions and the
   * move is delayed depending on the growth or shrinkage of the timeline.
   */
  var updateRectangleElements = function (rectangles, xScale, oldDimensions,
                                          newDimensions) {
    // UPDATE
    // Update old elements as needed.
    if (rectangles[0].length > 0) {
      var barHeight = newDimensions.bars,
          y = Timeline.prototype._maxMin(rectangles.data(), '1'),
          options = {scale: 'linear'},
          newHeight = Timeline.prototype._getHeight(newDimensions),
          oldHeight = Timeline.prototype._getHeight(oldDimensions),
          heightDiff = newHeight - oldHeight,
          yScale = Timeline.prototype._makeScale(
            y,
            {min: 0, max: barHeight},
            options),
            barWidth = Number(rectangles.attr('width'));

      if (heightDiff < 0) {

        rectangles.transition()
          .duration(Timeline.prototype.transTime)
          .delay(Timeline.prototype.transTime)
          .attr("height", function (d) {return yScale(d[1]); })
          .attr("y", function (d) {
            return newHeight - yScale(d[1]);
          })
          .attr("x", function (d) {
            return xScale(d[0]) - barWidth;
          });

      } else {
        rectangles.transition()
          .duration(Timeline.prototype.transTime)
          .attr("height", function (d) {return yScale(d[1]); })
          .attr("y", function (d) {
            return newHeight - yScale(d[1]);
          })
          .attr("x", function (d) {
            return xScale(d[0]) - barWidth;
          });
      }
    }
  };

  /**
   * @function
   * @summary update future indicator.
   *
   * @param {object} futureIndicator - D3 selection.
   * @param {object} xScale - D3 scale.
   * @param {object} oldDimensions - previous timeline dimensions object.
   * @param {object} dimensions - timeline dimensions object.
   */
  var updateFutureIndicator = function (
    futureIndicator,
    xScale,
    oldDimensions,
    dimensions
    ) {

    var height = Timeline.prototype._getHeight(dimensions),
        width = Timeline.prototype._getWidth(dimensions);

    futureIndicator
      .attr('x', xScale(Date.now()));

    if (dimensions.height < oldDimensions.height) {
      futureIndicator
       .transition()
       .delay(Timeline.prototype.transTime)
       .duration(Timeline.prototype.transTime)
       .attr('height', height);
    } else {
      futureIndicator
       .transition()
       .duration(Timeline.prototype.transTime)
       .attr('height', height);
    }
  };
  var updateTickmarks = function (tickmarks, dimensions, oldDimensions) {
    var height = Timeline.prototype._getHeight(dimensions),
        TICKMARK_HEIGHT = 5;

    // update horizontal
    tickmarks.attr("x", function (d) { return xScale(d); });

    // update vertical
    if (oldDimensions && dimensions.height < oldDimensions.height) {
      tickmarks.transition()
        .delay(Timeline.prototype.transTime)
        .duration(Timeline.prototype.transTime)
        .attr("y", height - TICKMARK_HEIGHT);
    }

    else if (oldDimensions &&  dimensions.height > oldDimensions.height) {
      tickmarks.transition()
        .duration(Timeline.prototype.transTime)
        .attr("y", height - TICKMARK_HEIGHT);
    }
  };

  /**
   * @function
   * @summary Draws rectangular tickmarks for every timestamp in data array.
   *
   * @param {object} svg - timeline svg object.
   * @param {object} dimensions - timeline dimensions object.
   * @param {integer []} data - list of timestamps in ms.
   *
   * @returns {object} d3 selection object with tickmarks for each timestamp.
   */
  var drawTickMarkElements = function (svg, dimensions, data) {
    var height = Timeline.prototype._getHeight(dimensions),
        TICKMARK_HEIGHT = 5,
        TICKMARK_WIDTH = 2;

    var group = svg
      .select("g")
      .select("#tickmark-group");

    // DATA JOIN
    // Join new data with old elements, based on the timestamp.
    tickmarks = group.selectAll("rect")
      .data(data, function  (d) { return d; });

    // UPDATE
    tickmarks.transition()
      .delay(Timeline.prototype.transTime)
      .duration(Timeline.prototype.transTime)
      .attr("y", height - TICKMARK_HEIGHT)
      .attr("x", function (d) { return xScale(d); });

    // ENTER
    tickmarks.enter().append("rect")
      .attr("class", "tickmark")
      .attr("y", height)
      .attr("width", TICKMARK_WIDTH)
      .attr("height", 0)
    .transition()
      .delay(Timeline.prototype.transTime)
      .duration(Timeline.prototype.transTime)
      .attr("x", function (d) { return xScale(d); })
      .attr("y", height - TICKMARK_HEIGHT)
      .attr("height", TICKMARK_HEIGHT);

    // EXIT
    // Remove old elements as needed.
    tickmarks.exit()
      .transition()
      .delay(Timeline.prototype.transTime)
      .duration(Timeline.prototype.transTime)
      .attr("y", height)
      .attr("height", 0)
      .remove();

    return tickmarks;

  };

  /**
   * @function
   * @summary Draws horizontal line elements according to a d3 update pattern.
   *
   * @param {object} svg - timeline svg object.
   * @param {object} dimensions - timeline dimensions object.
   * @param {object} xScale - D3 scale object.
   * @param {object} yScale - D3 scale object.
   * @param {object} data - geojson data structure:
   *   [{properties.timestamp_end: timestamp,
   *     properties.timestamp_start: timestamp,
   *     properties.event_series_id: event_series id,
   *     geometry.coordinates: [lat, lon]}]
   * @param {int} order - Order of data (which level to draw in timeline).
   * @param {string} slug - slug of event series.
   * @param {string} color - Hex color code.
   */
  var drawCircleElements = function (
    svg, dimensions, xScale, yScale, data, order, slug, color, aggWindow) {

    var MIN_CIRCLE_SIZE = 3,
        MAX_COUNT = 100;

    var xOneFunction = function (d) {
      return xScale(parseFloat(d.timestamp) - (aggWindow / 2));
    };

    var yFunction = function (d) { return yScale(order); };

    var rFunction = function (d) {
      return UtilService.lin2log(
        d.count, MIN_CIRCLE_SIZE, MAX_CIRCLE_SIZE, 1, MAX_COUNT);
    };

    // if data exists, check if group is available for this series and create
    // if no data, remove circles
    if (data !== undefined) {
      var group = svg
                    .select("g")
                    .select("#circle-group")
                    .select("#" + slug);
      if (!group[0][0]) {
        group = svg.select("g").select("#circle-group").append("g")
          .attr("id", slug);
      }

      // DATA JOIN
      // Join new data with old elements, based on the id value.
      circles = group.selectAll("circle")
        .data(data, function  (d) { return d.timestamp; });
    } else if (data === undefined) {
      // if no data is defined, remove all groups
      var groups = svg.select("g").select("#circle-group").selectAll("g");
      groups.remove();

      return;
    }

    // UPDATE
    // Update old elements as needed.
    circles.transition()
      .delay(Timeline.prototype.transTime)
      .duration(Timeline.prototype.transTime)
      .attr("stroke", color)
      .attr("fill", color)
      .attr("cx", xOneFunction)
      .attr("cy", yFunction)
      .attr("r", rFunction);

    // ENTER
    // Create new elements as needed.
    circles.append("g");
    circles.enter().append("circle")
      .attr("class", "event")
      .attr("fill", color)
      .attr("stroke", color)
    .transition()
      .delay(Timeline.prototype.transTime)
      .duration(Timeline.prototype.transTime)
      .attr("cx", xOneFunction)
      .attr("cy", yFunction)
      .attr("r", rFunction);

    // EXIT
    // Remove old elements as needed.
    circles.exit()
      .transition()
      .delay(0)
      .duration(Timeline.prototype.transTime)
    .transition()
      .delay(Timeline.prototype.transTime)
      .duration(Timeline.prototype.transTime)
      .attr("stroke-width", 0)
      .style("fill-opacity", 0)
      .remove();

    return circles;
  };

  /**
   * @function
   * @summary Draws bar elements according to a d3 update pattern.
   */
  var drawRectElements = function (svg, dimensions, data, xScale, yScale) {

    var height = Timeline.prototype._getHeight(dimensions),
    // Join new data with old elements, based on the timestamp.
    bars = svg.select("g").select('#rain-bar').selectAll('.bar-timeline')
        .data(data, function  (d) { return d[0]; });

    var barWidth;
    if (data.length > 1) {
      barWidth = xScale(data[1][0]) - xScale(data[0][0]);
    } else {
      barWidth = 0;
    }

    // UPDATE
    // Update old elements as needed.
    bars.transition()
      .duration(Timeline.prototype.transTime)
      .attr("x", function (d) { return xScale(d[0]) - barWidth; })
      .attr('width', barWidth)
      .attr("height", function (d) { return yScale(d[1]); })
      .attr("y", function (d) { return height - yScale(d[1]); });

    // ENTER
    // Create new elements as needed.
    bars.enter().append("rect")
      .attr("class", "bar-timeline")
      .attr("x", function (d) {
        return xScale(d[0]) - barWidth;
      })
      .attr('width', barWidth)
      .attr("height", 0)
      .attr("y", height)
      .transition()
      .delay(Timeline.prototype.transTime)
      .duration(Timeline.prototype.transTime)
      .attr("height", function (d) { return yScale(d[1]); })
      .attr("y", function (d) { return height - yScale(d[1]); });

    // EXIT
    // Remove old elements as needed.
    bars.exit()
      .transition()
      .duration(Timeline.prototype.transTime)
      .attr("y", height)
      .attr("height", 0)
      .remove();

    var barsEl = svg.select("g").select('#rain-bar').node();
    barsEl.parentNode.insertBefore(barsEl, barsEl.parentNode.firstChild);

    return bars;
  };


  /**
   * @function
   * @summary Returns a d3 scale to place events vertically in circles above
   * each other.
   *
   * @param  {int} iniH initial height of the timeline in px.
   * @param  {object} dims current dimensions of the timeline.
   */
  var makeEventsYscale = function (iniH, dims) {
    return function (order) {
      return dims.events * order - MAX_CIRCLE_SIZE;
    };
  };

  return Timeline;

}]);

'use strict';

/**
 * TimeLineDirective
 * @memberOf app
 *
 * @summary Timeline directive.
 *
 * @description Timeline directive.
 */
angular.module('lizard-nxt')
  .directive('timeline',
             ["$q",
              "$timeout",
              "RasterService",
              "UtilService",
              "Timeline",
              "VectorService",
              "DataService",
              "EventAggregateService",
              "State",
              function ($q,
                        $timeout,
                        RasterService,
                        UtilService,
                        Timeline,
                        VectorService,
                        DataService,
                        EventAggregateService,
                        State) {

  var link = function (scope, element, attrs, timelineCtrl) {

    var timelineSetsTime = false,
        timelineSetsAt = false,

        showTimeline = true, // Is set by user clicking data label, when true
                              // timeline is shown.

        dimensions = {
          width: UtilService.getCurrentWidth(),
          height: 45,
          events: 35,
          bars: 35,
          padding: {
            top: 0,
            right: 0,
            bottom: 20,
            left: 0
          }
        },
        start = State.temporal.start,
        end = State.temporal.end,
        el = element.find('svg');

    var interaction = {

      /**
       * @function
       * @summary Update timeState on zoom.
       *
       * @param {object}  scale D3 xScale.
       */
      zoomFn: function (scale) {

        scope.$apply(function () {
          timelineSetsTime = true;
          State.temporal.timelineMoving = true;
          State.temporal.start = scale.domain()[0].getTime();
          State.temporal.end   = scale.domain()[1].getTime();

          State.temporal.aggWindow = UtilService.getAggWindow(
            State.temporal.start,
            State.temporal.end,
            UtilService.getCurrentWidth()
          );

          State.temporal.at = UtilService.roundTimestamp(
            State.temporal.at,
            State.temporal.aggWindow,
            false
          );
        });

        timeline.drawAggWindow(State.temporal.at, State.temporal.aggWindow);
      },

      /**
       * @function
       * @summary Update zoomEnded to trigger new call for new timeline data.
       */
      zoomEndFn: function () {
        scope.$apply(function () {
          getTimeLineData();
          State.temporal.timelineMoving = false;
        });
      },

      /**
       * @function
       * @description Update timeState.at to click location in timebar. Snaps
       * time to closest interval.
       *
       * @param {object} event - D3 event.
       * @param {object} scale - D3 scale.
       * @param {object} dimensions - object with timeline dimensions.
       */
      clickFn: function (timestamp, dimensions) {
        scope.$apply(function () {
          timelineSetsAt = true;
          State.temporal.at = UtilService.roundTimestamp(
            timestamp,
            State.temporal.aggWindow
          );
          timeline.drawAggWindow(State.temporal.at, State.temporal.aggWindow);
        });
      },
    };

    // shift timeline's SVG element using it's CSS - set here by JS too stop
    // stuff becoming unsyncable
    angular.element("#timeline-svg-wrapper svg")[0].style.left
      = UtilService.TIMELINE_LEFT_MARGIN + "px";

    // keep track of events in this scope
    scope.events = {nEvents: 0, slugs: []};

    // Initialise timeline
    var timeline = new Timeline(el[0], dimensions, start, end, interaction);

    setTimeout(interaction.zoomEndFn, 250);
    // HELPER FUNCTIONS

    /**
     * @function
     * @description Redetermines dimensions of timeline and calls resize.
     *
     * @param {object} newDim - object with new timeline dimensions.
     * @param {object} dim - object with old timeline dimensions.
     * @param {int} nEventTypes - number of event types (event series).
     */
    var updateTimelineHeight = function (nEventTypes) {
      var eventHeight,
          newDim = angular.copy(timeline.dimensions);

      newDim.height = dimensions.padding.bottom
        + dimensions.padding.top
        + nEventTypes * dimensions.events;

      if (getTimelineLayers(DataService.layerGroups).rain) {
        newDim.height += dimensions.bars;
      }

      newDim.height = Math.max(newDim.height, dimensions.height);

      if (showTimeline) {
        element[0].style.height = newDim.height + 5 + 'px'; // 5px margins
      }

      timeline.resize(
        newDim,
        State.temporal.at,
        State.temporal.aggWindow,
        nEventTypes
      );

      if (Timeline.onresize) {
        Timeline.onresize(newDim);
      }

    };

    /**
     * @function
     * @summary Temporary function to get relevant timeline layers from active
     *  layers.
     * @description Loops over layergroups and gets for each active layergroup
     * the vector and rain intensity layer. Those layers are used to draw data
     * in the timeline.
     *
     * TODO: refactor to query layerGroups by data type (event, raster, object)
     *
     * @param {object} layerGroups - NXT layerGroups object.
     * @returns {object} with: events (list of layers) and rain (nxtLayer).
     */
    var getTimelineLayers = function (layerGroups) {
      var timelineLayers = {events: {layers: [], slugs: []},
                            rasterStore: {layers: []},
                            rain: undefined};

      angular.forEach(layerGroups, function (layergroup) {
        if (layergroup.isActive()) {
          angular.forEach(layergroup._dataLayers, function (layer) {
            if (layer.format === "Vector") {
              timelineLayers.events.layers.push(layer);
              timelineLayers.events.slugs.push(layer.slug);
            } else if (layer.format === "Store" && State.context !== 'time') {
              if (layer.slug !== "rain") {
                timelineLayers.rasterStore.layers.push(layer);
              } else if (layer.slug === "rain") {
                timelineLayers.rain = layer;
              }
           }
          });
        }
      });

      return timelineLayers;
    };

    /**
     * @function
     * @summary Get data for events and rain.
     * @description Get data for events and rain. If data exists (relevant
     * layers are active), data is drawn in timeline. Timelineheight is updated
     * accordingly.
     *
     * TODO: Now data is fetched via layerGroup loop logic (getTimelineLayers).
     * That will change later when we set data.
     */
    var getTimeLineData = function () {
      // NOTE: remember which layers *were* active? So we can do stuff with
      // turning off data (eg tickmarks).
      var timelineLayers = getTimelineLayers(DataService.layerGroups),
          context = {eventOrder: 1,
                     nEvents: scope.events.nEvents};

      // vector data (for now only events)
      if (timelineLayers.events.layers.length > 0 &&
        State.spatial.bounds.isValid()) {
        scope.events.nEvents = timelineLayers.events.layers.length;

        // update inactive groups with nodata so update function is called
        // appropriately.
        angular.forEach(scope.events.slugs, function (slug) {
          if (timelineLayers.events.slugs.indexOf(slug) === -1) {
            timeline.drawCircles([], scope.events.nEvents, slug);
          }
        });

        // update slugs on scope for housekeeping
        scope.events.slugs = timelineLayers.events.slugs;
        getEventData();
      } else {
        scope.events.nEvents = 0;
        timeline.drawCircles(undefined, scope.events.nEvents);
      }

      if (State.spatial.bounds.isValid()) { // no business here when invalid
                                            // bounds.

        if (timelineLayers.rain !== undefined) {
          getTemporalRasterData(timelineLayers.rain,
                                timelineLayers.events.length);
        } else {
          timeline.removeBars();
        }
        if (timelineLayers.rasterStore.layers.length > 0) {
          angular.forEach(timelineLayers.rasterStore.layers, function (layer) {
            getTemporalRasterDates(layer);
          });
        } else {
          timeline.drawTickMarks([]);
        }

      }

      updateTimelineHeight(scope.events.nEvents);
    };

    /**
     * @function
     * @summary get data for event layers and update timeline.
     * @description get data for event layers and update timeline.
     */
    var getEventData = function () {
      // create context for callback function, reset eventOrder to 1.
      var context = {
        eventOrder: 1,
        nEvents: scope.events.nEvents,
        slugs: scope.events.slugs
      };

      var draw = function (response) {

        if (response && response.data) {
          // Add it to the timeline
          var data = EventAggregateService.aggregate(
            response.data,
            State.temporal.aggWindow
          );

          timeline.drawCircles(
            data,
            context.eventOrder,
            response.layerGroupSlug,
            response.color,
            State.temporal.aggWindow
          );
          context.eventOrder++;
        }
      };
      // Get data with type === 'Event'
      DataService.getData('timeline', {
        geom: State.spatial.bounds,
        start: State.temporal.start,
        end: State.temporal.end,
        type: 'Event'
      }).then(null, null, draw);
    };


    /**
     * @function
     * @summary get data for temporal raster layers.
     * @description  get data for temporal raster. If it gets a response updates
     * timeline height and draws bars in timeline.
     *
     * @param {object} rasterLayer - rasterLayer object.
     */
    var getTemporalRasterData = function (rasterLayer) {

      var start = State.temporal.start,
          stop = State.temporal.end,
          bounds = State.spatial.bounds;

      // Has it's own deferrer to not conflict with
      // other deferrers with the same layerSlug
      RasterService.getData(
        'timelineData',
        rasterLayer,
        {
          geom: bounds,
          start: start,
          end: stop,
          agg: rasterLayer.aggregationType,
          aggWindow: State.temporal.aggWindow,
          deferrer: {
            origin: 'timeline_' + rasterLayer.slug,
            deferred: $q.defer()
          }
        }
      )
      .then(
        function (response) {
          if (response && response !== 'null' && response.data !== null) {
            timeline.drawBars(response.data);
          }
        }
      );
    };

    /**
     * @function
     * @summary get date array for temporal raster layers.
     * @description  get date array for temporal raster. If it gets a response
     * plots a tickmark in the timeline for every date.
     *
     * NOTE: refactor this function with getTemporalRasterData to use
     * dataService.
     *
     * @param {object} rasterLayer - rasterLayer object.
     */
    var getTemporalRasterDates = function (rasterLayer) {

      var start = State.temporal.start,
          stop = State.temporal.end,
          bounds = State.spatial.bounds,
          dates = [];

      var draw = function () {
        timeline.drawTickMarks(dates);
      };

      DataService.getData('timelineDates', {
        start: State.temporal.start,
        end: State.temporal.end,
        geom: State.spatial.bounds.getCenter(),
        truncate: true,
        exclude: 'rain'
      }).then(draw, null, function (response) {
        if (response && response !== 'null') {
          dates = dates.concat(response.data);
        }
      });

    };

    // END HELPER FUNCTIONS

    scope.timeline.toggleTimelineVisiblity = function () {
      showTimeline = !showTimeline;
      if (!showTimeline && State.context !== 'time') {
        element[0].style.height = 0;
      } else {
        updateTimelineHeight(scope.events.nEvents);
      }
    };

    scope.timeline.toggleTimelineVisiblity();

    scope.timeline.toggleTimeCtx = function () {
      scope.timeline.toggleTimelineVisiblity();
      scope.transitionToContext(State.context === 'map' ? 'time' : 'map');
    };

    // WATCHES

    /**
     * Updates area when user moves map.
     */
    scope.$watch(State.toString('spatial.bounds'), function (n, o) {
      if (n === o) { return true; }
      getTimeLineData();
    });

    /**
     * Updates area when users changes layers.
     */
    scope.$watch(State.toString('layerGroups.active'), function (n, o) {
      if (n === o) { return true; }
      getTimeLineData();
    });

    /**
     * Timeline is updated when something other than the timeline
     * updates the temporal extent.
     */
    scope.$watch(State.toString('temporal.timelineMoving'), function (n, o) {
      if (n === o) { return true; }
      if (!timelineSetsTime) {

        State.temporal.aggWindow = UtilService.getAggWindow(
          State.temporal.start,
          State.temporal.end,
          UtilService.getCurrentWidth()
        );

        timeline.zoomTo(
          State.temporal.start,
          State.temporal.end,
          State.temporal.aggWindow
        );
        getTimeLineData();
      }
      timelineSetsTime = false;
    });

    /**
     * Update aggWindow element when timeState.at changes.
     */
    scope.$watch(State.toString('temporal.at'), function (n, o) {
      if (!timelineSetsAt) {
        // update timeline when time-controller changes temporal.at state
        timeline.drawAggWindow(State.temporal.at, State.temporal.aggWindow);
      }
      timelineSetsAt = false;
    });

    /**
     * Round timeState.at when animation stops.
     */
    scope.$watch(State.toString('temporal.playing'), function (n, o) {
      if (n === o || n) { return true; }
      State.temporal.at = UtilService.roundTimestamp(
        State.temporal.at + State.temporal.aggWindow / 2,
        State.temporal.aggWindow,
        false
      );
    });

    scope.$watch(State.toString('context'), function (n, o) {
      if (n === o) { return; }
      showTimeline = false; // It toggles
      scope.timeline.toggleTimelineVisiblity();
      getTimeLineData(); // It also removes data..
    });

    /**
     * The timeline can be too early on initialization.
     * The leaflet events are not even started loading,
     * so the call returns an empty array.
     *
     * If nobody touches nothing, that means the timeline
     * won't show events, whilst they are being drawn
     * on the map.
     *
     * This evenListener ensures a retrieval of data
     * after the browser is done doing requests.
     */
    window.addEventListener('load', getTimeLineData);

    var resize = function () {
      scope.$apply(function () {
        timeline.dimensions.width = UtilService.getCurrentWidth();
        timeline.resize(
          timeline.dimensions,
          State.temporal.at,
          State.temporal.aggWindow,
          scope.events.nEvents // TODO: get nEvents from somewhere
        );
      });
    };

    /**
     * Update timeline when browser window is resized.
     */
    window.addEventListener('resize', resize);

    /**
     * Remove listeners.
     */
    scope.$on('$destroy', function () {
      window.removeEventListener('resize', resize);
      window.removeEventListener('load', getTimeLineData);
      timeline.destroy();
    });

    // END WATCHES

  };

  return {
    replace: true,
    restrict: 'E',
    link: link,
    templateUrl: 'timeline/timeline.html'
  };
}]);


'use strict';

/**
 * @class angular.module('lizard-nxt')
  .TimeLineCtrl
 * @memberOf app
 *
 * @summary TimeLine controller.
 *
 * @TODO : Isolate scope. Use scope for data binding to DOM elements. No need to
 *         do this on master scope.
 *
 * @desc Manipulates timeState model, animation controls.
 *
 */
angular.module('lizard-nxt')
.controller('TimeCtrl', [

  "$rootScope",
  "$scope",
  "$q",
  'UtilService',
  'DataService',
  'State',

  function (

    $rootScope,
    $scope,
    $q,
    UtilService,
    DataService,
    State) {

    window.requestAnimationFrame = window.requestAnimationFrame ||
                                   window.mozRequestAnimationFrame ||
                                   window.webkitRequestAnimationFrame ||
                                   window.msRequestAnimationFrame;

    var DEFAULT_NUMBER_OF_STEPS = 2000, // Small for humans to perceive as smooth.
        currentInterval = State.temporal.end - State.temporal.start,
        timeStep = Infinity, // Will be overwritten to
                             // currentInterval / DEFAULT_NUMBER_OF_STEPS
                             // Or the smallest temporalResolution of an active
                             // temporal layer.
        minLag = 0, // Let the browser determine the max speed using
                    // requestAnimationFrame.
        promise, // Is created when syncing time and resolves when all datalayers
                 // finished buffering and redrawing;
        timeOut; // runs for minLag of milliseconds before waiting for the promise
                 // to resolve and re-syncing the data layers to the new time and
                 // making a new step when animation is playing.

    State.temporal.aggWindow = UtilService.getAggWindow(
      State.temporal.start,
      State.temporal.end,
      UtilService.getCurrentWidth()
    );

    this.state = State;

    Object.defineProperty(this, 'showContextSwitch', {
      get: function () {
        return State.layerGroups.active.some(function (slug) {
          return DataService.layerGroups[slug].temporal
            && DataService.layerGroups[slug].isActive();
        });
      }
    });

    /**
     * Keep an eye out for temporal layers that require the animation to go
     * with a lower speed so wms requests can keep up and run more smooth if the
     * temporalResolution equals or is a multiplication of  the stepSize.
     */
    $scope.$watch(State.toString('layerGroups.active'), angular.bind(this, function (n, o) {
      if (n === o) { return; }
      configAnimation.call(this);
    }));

    /**
     * sync data layers to new timestate and redo the animation configuration
     * since currentInterval has changed.
     */
    $scope.$watch(State.toString('temporal.timelineMoving'), angular.bind(this, function (n, o) {
      if (n === o) { return true; }
      if (!State.temporal.timelineMoving) {
        configAnimation.call(this);
      }
    }));

    /**
     * Sync to new time and trigger a new step when animation.playing is true.
     *
     * Layergroups need a time synced to them before being toggled. Therefore, no
     * n === o return here.
     */
    $scope.$watch(State.toString('temporal.at'), function (n, o) {
      if (n === o) { return true; }
      syncTimeWrapper(State.temporal);
    });

    /**
     * @description sets the timeStep and minLag on the basis of layergroups and
     *              their temporalResolution. The temporal layer with the smallest
     *              temporalResolution is leading.
     */
    var configAnimation = function () {
      currentInterval = State.temporal.end - State.temporal.start;
      timeStep = Infinity;
      minLag = 0;

      var activeTemporalLgs = false;

      angular.forEach(State.layerGroups.active, function (lgSlug) {
        var lg = DataService.layerGroups[lgSlug];

        if (lg.temporal) {
          // add some empty stuff to determine
          // whether animation is possible.
          activeTemporalLgs = true;
        }

        if (lg.temporal && lg.temporalResolution !== 0 && lg.temporalResolution < timeStep) {
          timeStep = lg.temporalResolution;
          // To accomadate dynamic temporal resolutions check all maplayers and
          // switch to coarser resolution if found. This is used by the rain.
          angular.forEach(lg.mapLayers, function (layer) {
            if (layer._temporalResolution > timeStep) {
              timeStep = layer._temporalResolution;
            }
          });
          // equals to 250 ms for 5 minutes, increases for larger timeSteps untill
          // it reaches 1 second between frames for timeSteps of > 20 minutes.
          minLag = timeStep / 1200 > 240 ? timeStep / 1200 : 250;
          minLag = minLag > 1000 ? 1000 : minLag;
        }
      });

      this.animatable = activeTemporalLgs;
      // Do not continue animating when there is nothing to animate.
      if (!this.animatable) {
        State.temporal.playing  = false;
      }

      // If no temporal layers were found, set to a default amount.
      if (timeStep === Infinity) {
        timeStep = currentInterval / DEFAULT_NUMBER_OF_STEPS;
      }
    };

    /**
     * @function
     * @summary Toggle animation playing.
     * @description Set State.temporal.animation.playing to true or false.
     *
     * @param {} toggle - .
     */
    this.playPauseAnimation = function (toggle) {
      if (State.temporal.playing || toggle === "off") {
        State.temporal.playing = false;
      } else {
        State.temporal.playing = true;
        window.requestAnimationFrame(step);
      }
    };

    /**
     * @function
     * @summary Push animation 1 step forward when Nxt is ready.
     * @description Set new timeState.at based on stepSize. If current
     * timeSate.at is outside current temporal extent, start animation at start
     * of temporal extent.
     */
    var step =  function () {
      // Make a new step.
      $scope.$apply(function () {
        State.temporal.at += timeStep;
      });

      // reset timeState.at if out of temporal bounds
      if (State.temporal.at >= State.temporal.end) {
        $scope.$apply(function () {
          State.temporal.at = UtilService.roundTimestamp(
            State.temporal.start,
            State.temporal.aggWindow,
            true // round up to prevent getting stuck at the start.
          );
        });
      }
    };

    /**
     * @description creates a promise by calling syncTime and toggles buffer state
     *              accordingly.
     * @param  {object} timeState nxt timeState object
     */
    var syncTimeWrapper = function (timeState) {
      var defer = $q.defer();

      if (timeState.playing) {
        progressAnimation(defer.promise);
      }
      if (State.layerGroups.timeIsSyncing) {
        var watch = $scope.$watch(
          function () { return State.layerGroups.timeIsSyncing; },
          function (loading) {
            if (loading === false) {
              defer.resolve();
              watch();
            }
          }
        );
      } else {
        defer.resolve();
      }
    };

    /**
     * @description progresses animation when provided promiss finishes and the
     *              minLag has passed. Sets buffering when he promise is not re-
     *              solved after minLag.
     * @param  {promise} finish
     */
    var progressAnimation = function (finish) {
      // Remove any old timeout
      clearTimeout(timeOut);
      // when the minLag has passed.
      timeOut = setTimeout(function () {
        // And the layergroups are all ready.
        finish.then(function () {
          // And we are still animating.
          if (State.temporal.playing) {
            // And the browser is ready. GO!
            window.requestAnimationFrame(step);
          }
        });
      }, minLag);
    };

    /**
     * @function
     * @summary Move timeState.end to now.
     */
    this.zoomToNow = function () {

      var now = Date.now(),
          fullInterval = State.temporal.end - State.temporal.start,
          oneFifthInterval = Math.round(fullInterval * 0.2),
          fourFifthInterval = Math.round(fullInterval * 0.8);

      State.temporal.start = now - fourFifthInterval;
      State.temporal.end = now + oneFifthInterval;
      State.temporal.at = UtilService.roundTimestamp(now,
                                                     State.temporal.aggWindow,
                                                     false);
      UtilService.announceMovedTimeline(State);
    };

    /**
     * @function
     * @summary Zooms time in or out.
     * @description multiplies or divides current time resolution by
     * ZOOMFACTOR depending on zooming in or out. Updates start and end
     * of timeState accordingly and sets new resolution on timeState.
     *
     * @param {string} action - 'in' or not 'in'.
     */
    this.zoom = function (action) {

      var ZOOMFACTOR = 2,
          diff = (State.temporal.end - State.temporal.start) / ZOOMFACTOR / 2,

          change = action === 'in' ? diff : - diff;

      State.temporal.start = UtilService.getMinTime(
        State.temporal.start + change
      );
      State.temporal.end = UtilService.getMaxTime(
        State.temporal.end - change
      );

      UtilService.announceMovedTimeline(State);

    };

    this.formatDatetime = function () {
      switch (State.temporal.aggWindow) {
      case 300000:
        return 'dd-MM-yyyy HH:mm';
      case 3600000:
        return 'dd-MM-yyyy HH:mm';
      case 86400000:
        return 'dd-MM-yyyy';
      case 2635200000:
        return 'MM-yyyy';
      default:
        throw new Error("Unknown aggWindow: " + this.state.aggWindow);
      }
    };
  }
]);

/**
 * @name Graph
 * @class angular.module('lizard-nxt')
  .Graph
 * @memberOf app
 *
 * @summary Service to create and update a graph
 *
 * @description Inject "Graph" and call new graph(<args>) to create a
 * graph. Currently the graph supports lines, bars, donut, and a flat
 * donut called horizontal stacked bar. The user may interact with
 * the graph through click and hover functions. Graph inherits from
 * NxtD3, a lower level d3 helper class.
 *
 * NOTE: The donut code is currently not used anywhere in lizard-client.
 *
 * Everything in the graphs is animated according to NxtD3.transTime.
 */
angular.module('lizard-nxt')
  .factory("Graph", ["$timeout", "NxtD3", function ($timeout, NxtD3) {

  var MIN_WIDTH_INTERACTIVE_GRAPHS = 400; // Only graphs bigger get mouseover
                                          // and click interaction.

  /**
   * @constructor
   * @memberOf angular.module('lizard-nxt')
  .Graph
   *
   * @param {object} element    svg element for the graph.
   * @param {object} dimensions object containing, width, height and
   *                            an object containing top,
   *                            bottom, left and right padding.
   *                            All values in px.
   * @param {object} xDomainInfo - override the domain for the graphs.
   */
  function Graph(element, dimensions, xDomainInfo) {
    if (xDomainInfo && xDomainInfo.start && xDomainInfo.end) {
      NxtD3.call(this, element, dimensions, xDomainInfo.start, xDomainInfo.end);
      this._xDomainInfo = xDomainInfo;
    } else {
      NxtD3.call(this, element, dimensions);
    }
    this._svg = this._createDrawingArea();
  }

  Graph.prototype = Object.create(NxtD3.prototype, {

    constructor: Graph,

    resize: {
      value: function (newDim) {
        NxtD3.prototype.resize.call(this, newDim);
        this._svg = this._createDrawingArea();
        this._svg.selectAll('.axis').remove();
        this._x = null;
        this._xy = null;
        // reposition labels
        drawLabel(this._svg, this.dimensions, undefined, true);
        drawLabel(this._svg, this.dimensions, undefined, false);
      }
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .Graph
     * @param {object}    data object. Currently supports the format:
     *                    [
     *                      {
     *                        "<key to color>": "<color str>",
     *                        "<value key": <value int>,
     *                        "<label key>": "<label>"
     *                      },
     *                      ...,
     *                    ]
     * @description       If necessary creates a d3 pie and arc and
     *                    draws the features in the data element.
     */
    drawDonut: {
      value: function (data) {
        if (!this.dimensions.r || this._arc || this._pie) {
          this._donut = createDonut(this.dimensions);
        }
        drawPie(this._svg, this.dimensions, this._donut, data);
      }
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt').Graph
     * @param {object} data   Currently supports the format:
     *                        [
     *                          [value, value],
     *                          ...,
     *                        ]
     * @param {object} keys   Mapping between x and y values of data object:
     *                        example: {x: 0, y: 1}
     * @param {object} labels Object {x: 'x label', y: 'y label'} will be
     *                        mapped to axis labels of the graph
     * @param {boolean} temporal to draw an time axis or not.
     * @param {boolean} transitioning to draw a subset of data now, and the full
     *                                set after a timeout if drawline is not
     *                                called again before the timeout finishes.
     *                                Use transitioning = true when callig this
     *                                function many times as a result of a user
     *                                induced action.
     * @description           Draws a line, if necessary sets up the graph,
     *                        if necessary modifies domain and redraws axis,
     *                        and draws the line according to the data object.
     *                        Currently only a linear scale on the x-axis is
     *                        supported.
     */
    drawLine: {
      value: function (data, keys, labels, temporal, transitioning) {
        if (!this._xy) {
          var options = {
            x: {
              scale: 'time',
              orientation: 'bottom'
            },
            y: {
              scale: 'linear',
              orientation: 'left'
            }
          };
          // pass options for time graph or use defaults
          this._xy = this._createXYGraph(
            data,
            keys,
            labels,
            temporal ? options : undefined,
            this._xDomainInfo
          );
        } else {
          this._xy = rescale(
            this._svg,
            this.dimensions,
            this._xy,
            data,
            keys,
            null,
            this._xDomainInfo
          );
          drawLabel(this._svg, this.dimensions, labels.y, true);
        }

        var lineAsArea = keys.y.hasOwnProperty('y0')
          && keys.y.hasOwnProperty('y1');

        var pathFn = lineAsArea
          ? this._createArea(this._xy, keys)
          : this._createLine(this._xy, keys);

        var MIN_POINTS_FOR_SUBSET = 15,
            DELAY = 10, // ms
            DATA_REDUCTION_FACTOR = 5;

        if (transitioning && data.length > MIN_POINTS_FOR_SUBSET) {
          this._registerTimeout(
            function () {
              this._path = drawPath(
                this._svg,
                pathFn,
                data,
                0, // transition 0 ms when drawing while zooming.
                this._path,
                lineAsArea ? null : 'none'
              );
            },
            DELAY // delay with 30 ms
          );

          data = getDataSubset(data, DATA_REDUCTION_FACTOR);
        }

        this._path = drawPath(
          this._svg,
          pathFn,
          data,
          temporal ? 0 : this.transTime, // Do not transition line graphs
                                         // when temporal.
          this._path,
          lineAsArea ? null : 'none' // Set fill to 'none' for normal
                                     // lines.
        );

        if (this.dimensions.width > MIN_WIDTH_INTERACTIVE_GRAPHS) {
          addInteractionToPath(
            this._svg,
            this.dimensions,
            data,
            keys,
            labels,
            this._path,
            this._xy,
            this.transTime
          );
        }

      }
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt').Graph
     * @param {object} data   Currently supports arrays of arrays or objects
     *                        with x value, y value, <optional> color and
     *                        <optional> category.
     * @param {object} keys   Mapping between x, y and optional color, and
     *                        category values of data object: example:
     *                        {x: 0, y: 1} or:
     *                        {x: 'xValue', y: 'yValue', color: 'eventColor',
     *                        categoy: 'cat'};
     * @param {object} labels Object {x: 'x label', y: 'y label'} will be
     *                        mapped to axis labels of the graph
     * @param {string} scale  Whether the graph has a scale other than temporal.
     *                        If it is of a temporal nature the x-axis will by
     *                        default be the temporal axis.
     * @description           Draws a barchart, if necessary sets up the graph,
     *                        if necessary modifies domain and redraws axis,
     *                        and draws the line according to the data object.
     *                        Currently only a time scale on the x-axis is
     *                        supported. It assumes that every segment has a
     *                        data element.
     */
    drawBars: {
      value: function (data, keys, labels, scale) {
        var originalKey = keys.y;
        if (keys.category) {
          // Create data for stacked bars.
          data = createYValuesForCumulativeData(data, keys);
          keys.y = 'y1';
        }
        if (!this._xy) {
          var options = {
            x: {
              scale: scale,
              orientation: 'bottom'
            },
            y: {
              scale: 'linear',
              orientation: 'left'
            }
          };
          this._xy = this._createXYGraph(data, keys, labels, options);
          this._xy.y.scale.domain([0, this._xy.y.maxMin.max]);
        }

        this._xy = rescale(
          this._svg,
          this.dimensions,
          this._xy,
          data,
          keys,
          {y: 0},
          this._xDomainInfo
        );

        drawLabel(this._svg, this.dimensions, labels.y, true);

        drawVerticalRects(
          this._svg,
          this.dimensions,
          this._xy,
          keys,
          data,
          this.transTime,
          this._xDomainInfo
        );

        if (this.dimensions.width > MIN_WIDTH_INTERACTIVE_GRAPHS) {
          addInteractionToRects(
            this._svg,
            this.dimensions,
            this._xy,
            keys,
            labels,
            this.transTime
          );
        }

        // Object reference, put it back.
        keys.y = originalKey;
      }
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt').Graph
     * @param {object}    data object. Currently supports the format:
     *                    [
     *                      {
     *                        "<key to color>": "<color str>",
     *                        "<value key": <value int>,
     *                        "<label key>": "<label>"
     *                      },
     *                      ...,
     *                    ]
     * @param {object} keys   Mapping between x values of data object:
     *                        example: {x: 'color'}
     * @param {object} labels Object {x: 'x label'} will be
     *                        mapped to axis labels of the graph
     * @description           If necessary an x-scale, axis, draws the
     *                        label and sets up a mousemove listener.
     *                        It draws the rectangles.
     */
    drawHorizontalStack: {
      value: function (data, keys, labels) {
        if (!this._x) {
          var options = {
            scale: 'linear',
            orientation: 'bottom',
            tickFormat: d3.format(".0%") // Custom tickFomat in percentages
          };
          this._x = createXGraph(this._svg, this.dimensions, labels, options);
        }
        // normalize data
        var total = d3.sum(data, function (d) {
          return Number(d[keys.x]);
        });
        angular.forEach(data, function (value, key) {
          value[keys.x] = value[keys.x] / total;
        });
        drawHorizontalRects(this._svg, this.dimensions, this.transTime, this._x.scale, data, keys, labels);
      }
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .Graph
     * @param {function} callback
     * @description      Sets a listener on the drawing rectangle
     *                   and on mousemove calls the callback with
     *                   the current position on the drawing area.
     */
    followMouse: {
      value: function (callback) {
         // Move listener rectangle to the front
        var el = this._svg.select('g').select('#listeners').node();
        el.parentNode.appendChild(el);
        var scale = this._xy.x.scale;
        this._svg.select('g').select('#listeners')
          .on('mousemove', function () {
            var pos = scale.invert(d3.mouse(this)[0]);
            callback(pos);
          });
      }
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .Graph
     * @param {function} callback
     * @description      Sets a listener on the drawing rectangle
     *                   and on mouseout calls the callback.
     */
    mouseExit: {
      value: function (callback) {
        this._svg.select('g').select('#listeners')
          .on('mouseout', function () {
            callback();
          });
      }
    },

    /**
     * @function
     * @memberOf angular.module('lizard-nxt')
  .Graph
     * @param {int}    draw   Timestamp in ms from epoch
     * @description           draws the now according the
     *                        current active scale.
     */
    drawNow: {
      value: function (now) {
        this._drawNow(now, this._xy.x.scale);
        // move to the front
        var el = this._svg.select('.now-indicator').node();
        el.parentNode.appendChild(el);
      }
    },

    _createXYGraph: {
      value: function (data, keys, labels, options) {
        if (!options) {
          options = {
            x: {
              scale: 'linear',
              orientation: 'bottom'
            },
            y: {
              scale: 'linear',
              orientation: 'left'
            }
          };
        }
        var xy = {x: {}, y: {}};

        angular.forEach(xy, function (value, key) {
          var y = key === 'y';
          xy[key] = this._createD3Objects(data, keys[key], options[key], y);
          drawAxes(this._svg, xy[key].axis, this.dimensions, y);
          drawLabel(this._svg, this.dimensions, labels[key], y);
        }, this);
        return xy;
      }
    },

    /**
     * Registers a timeout with a cb and a delay. Calls the cb on the instance
     * of Graph after delay.
     *
     * @param {function} cb function to call on graph instance when timeout
     *                      resolves.
     * @param {int} delay in ms of the cb execution.
     */
    _registerTimeout: {
      value: function(cb, delay) {
        if (this.timeout) {
          $timeout.cancel(this.timeout);
        }

        var graph = this;

        this.timeout = $timeout(
          function () {
            cb.call(graph); },
          delay,
          false // Do not trigger unnecessary digest loop
        );
      }
    }

  });

  var createPie, createArc, drawPie, drawAxes, drawLabel, needToRescale,
      drawPath, setupLineGraph, createDonut, addInteractionToPath, getBarWidth,
      drawVerticalRects, addInteractionToRects, drawHorizontalRects,
      createXGraph, rescale, createYValuesForCumulativeData, getDataSubset;

  /**
   * Creates y cumulatie y values for elements on the same x value.
   *
   * @param  {array} data array of objects.
   * @param  {object} keys mapping between x, y and keys in the data.
   * @return {array} with added y0 value and cumulative y value.
   */
  createYValuesForCumulativeData = function (data, keys) {
    var cumulativeData = [];
    // Group by x value
    d3.nest().key(function (d) {
      return d[keys.x];
    })
    .entries(data)
    // Compute y values for every group
    .forEach(function (group) {
      var y0 = 0;
      group.values = group.values.map(function (d) {
        d.y0 = y0;
        d.y1 = y0 + d[keys.y];
        y0 = d.y1;
        cumulativeData.push(d);
      });
    });

    return cumulativeData;
  };

  needToRescale = function (data, key, limit, old, xDomainInfo) {
    var newDomain;
    if (key === "y") {
      newDomain = Graph.prototype._maxMin(data, "y");
    } else {
      newDomain = xDomainInfo
        ? { min: xDomainInfo.start, max: xDomainInfo.end }
        : Graph.prototype._maxMin(data, key);
    }
    return (
      newDomain.max > old.max ||
      newDomain.max < (limit * old.max) ||
      newDomain.min !== old.min
    );
  };

  rescale = function (svg, dimensions, xy, data, keys, origin, xDomainInfo) {
    // Sensible limits to rescale. If the max
    // of the y values is smaller than 0.2 (or 20 %) of the max of the scale,
    // update domain of the scale and redraw the axis.
    var limits = {
      x: 1,
      y: 0.2
    };
    var orientation = {
      x: 'bottom',
      y: 'left'
    };
    origin = origin || {};
    // Decide to rescale for each axis.
    angular.forEach(xy, function (value, key) {
      if (needToRescale(data, keys[key], limits[key], value.maxMin, xDomainInfo)) {
        value.maxMin = key === "x" && xDomainInfo
          ? { min: xDomainInfo.start, max: xDomainInfo.end }
          : Graph.prototype._maxMin(data, keys[key]);
        if (origin[key] === undefined) {
          origin[key] = value.maxMin.min;
        }
        value.scale.domain([origin[key], value.maxMin.max]);
        value.axis = Graph.prototype._makeAxis(value.scale, {orientation: orientation[key]});
        drawAxes(svg, value.axis, dimensions, key === 'y' ? true : false, Graph.prototype.transTime);
      }
    });
    return xy;
  };

  drawHorizontalRects = function (svg, dimensions, duration, scale, data, keys, labels) {
    var width = Graph.prototype._getWidth(dimensions),
        height = Graph.prototype._getHeight(dimensions),
        DEFAULT_BAR_COLOR = "#7f8c8d", // $asbestos is the default color for bars
        previousCumu = 0;

    // Create a start and end for each rectangle.
    angular.forEach(data, function (value) {
      value.start = previousCumu;
      previousCumu += value[keys.x];
    });
    // Data should be normalized between 0 and 1.
    var total = 1;

    // Join new data with old elements, based on the y key.
    var rects = svg.select('g').select('#feature-group').selectAll(".horizontal-rect")
      .data(data, function (d) { return d[keys.y]; });

    // UPDATE
    // Update elements start and width as needed.
    rects.transition()
      .duration(duration)
      .attr("x", function (d) { return scale(d.start); })
      .attr('width', function (d) { return scale(d[keys.x]); });
    // ENTER
    // Create new elements as needed.
    rects.enter().append("rect")
      .style("fill", function (d) { return d.color || DEFAULT_BAR_COLOR; })
      .attr("x", function (d) { return scale(d.start); })
      .attr("y", 0)
      .attr('class', 'horizontal-rect')
      .attr("height", height)
      .transition()
      .duration(duration)
      .attr('width', function (d) { return scale(d[keys.x]); });
    // EXIT
    // Remove old elements as needed. First transition to width = 0
    // and then remove.
    rects.exit()
      .transition()
      .duration(duration)
      .attr('width', 0)
      .remove();

    // Rects set their value on the label axis when hoovered
    rects.on('mousemove', function (d) {
      var label;
      if (d.label === -1) {
        label = Math.round(d[keys.x] * 100) + "% overig";
      } else {
        var labelstr = d.label.split('-');
        label = Math.round(d[keys.x] * 100) + '% ' + labelstr[labelstr.length - 1];
      }

      svg.select('#xlabel')
        .text(label)
        .attr("class", "selected");
    });

    // When the user moves the mouse away from the graph, put the original
    // label back in place.
    rects.on('mouseout', function (d) {
      svg.select('#xlabel')
        .text(labels.x)
        .classed({"selected": false});
    });
  };

  drawVerticalRects = function (svg, dimensions, xy, keys, data, duration, xDomainInfo) {
    // We update the domain for X, if xDomainInfo was set...
    if (xDomainInfo && xDomainInfo.start && xDomainInfo.end) {
      xy.x.scale.domain([xDomainInfo.start, xDomainInfo.end]);
    }

    var width = Graph.prototype._getWidth(dimensions),
        height = Graph.prototype._getHeight(dimensions),
        x = xy.x,
        y = xy.y,
        MIN_BAR_WIDTH = 2,
        barWidth = Math.max(
          MIN_BAR_WIDTH,
          Math.floor(
            getBarWidth(xy.x.scale, data, keys, dimensions, xDomainInfo)
          )
        ),
        strokeWidth = barWidth === MIN_BAR_WIDTH ? 0 : 1,

        // Join new data with old elements, based on the x key.
        bar = svg.select('#feature-group').selectAll(".bar")
          .data(
            data,
            function (d) {
              if (d[keys.category]) {
                return d[keys.x] + d[keys.category];
              } else {
                return d[keys.x];
              }
            }
          );

    // UPDATE
    bar
      .transition()
      .duration(duration)
        // change x when bar is invisible:
        .attr("x", function (d) { return x.scale(d[keys.x]) - barWidth; })
        // change width when bar is invisible:
        .attr('width', function (d) { return barWidth; })
        .style("fill", function (d) { return d[keys.color] || ''; })
          .transition()
          .duration(duration)
          .delay(duration * 4)
            .attr("height", function (d) {
              return y.scale(d.y0) - y.scale(d[keys.y]) || height - y.scale(d[keys.y]);
            })
            .attr("y", function (d) { return y.scale(d[keys.y]); })
    ;

    // ENTER
    // Create new elements as needed.
    bar.enter().append("rect")
      .attr("class", "bar")
      .attr("x", function (d) { return x.scale(d[keys.x]) - barWidth; })
      .attr('width', function (d) { return barWidth; })
      .attr("y", function (d) { return y.scale(0); })
      .attr("height", 0)
      .style("fill", function (d) { return d[keys.color] || ''; })
      .transition()
      .duration(duration)
        // Bring bars in one by one
        // .delay(function (d, i) { return i * 0.1 * duration * 2; })
        .attr("height", function (d) {
          return y.scale(d.y0) - y.scale(d[keys.y]) || height - y.scale(d[keys.y]);
        })
        .attr("y", function (d) { return y.scale(d[keys.y]); })
        .attr("stroke-width", strokeWidth);

    // EXIT
    // Remove old elements as needed.
    bar.exit()
      .transition()
      .duration(duration)
      .attr("y", height)
      .attr("height", 0)
      .remove();
  };

  getBarWidth = function (scale, data, keys, dimensions, xDomainInfo) {

    // If aggWindow is passed, use it
    if (xDomainInfo && xDomainInfo.aggWindow) {
      return scale(xDomainInfo.aggWindow) - scale(0);
    }

    else if (data.length === 0) {
      // Apparently, no data is present: return a dummy value since nothing
      // is to be drawn.
      return 0;
    }

    else {
      var firstDatum = data[0],
          lastDatum = data[data.length - 1];

      return  Math.floor(
        (scale(lastDatum[keys.x]) - scale(firstDatum[keys.x])) / (data.length - 1)
      );
    }

  };


  addInteractionToRects = function (svg, dimensions, xy, keys, labels, duration) {
    var height = Graph.prototype._getHeight(dimensions),
      width = Graph.prototype._getWidth(dimensions),
        fg = svg.select('#feature-group');

    var cb = function (d) {
      removeAllSelection();
      d3.select(this).attr('class', 'selected bar');
      var g = fg.append('g').attr('class', 'interaction-group');


      var text = Math.round(d[keys.y] * 100) / 100 + ' ' + labels.y;
      text = keys.category !== undefined
        ? text + ' ' + d[keys.category]
        : text;

      var t  = g.append('text').text(text);

      var tHeight = t.node().getBBox().height,
          tWidth = t.node().getBBox().width;

      var BOX_PADDING_WIDTH = 10,
          BOX_PADDING_HEIGHT = TEXY_PADDING_WIDTH = 5;

      var bgY = Math.min(
        height - tHeight - BOX_PADDING_HEIGHT,
        xy.y.scale(d.y1 || d[keys.y])
      );

      var textY = Math.min(
        height - 0.5 * tHeight,
        xy.y.scale(d.y1 || d[keys.y]) + tHeight
      );

      var bgX = Math.min(
        width - tWidth - BOX_PADDING_WIDTH,
        xy.x.scale(d[keys.x])
      );

      var textX = Math.min(
        width - tWidth,
        xy.x.scale(d[keys.x]) + TEXY_PADDING_WIDTH
      );

      g.append('rect')
        .attr('class', 'tooltip-background')
        .attr('x', bgX)
        .attr('y', bgY)
        .attr('width', tWidth + BOX_PADDING_WIDTH)
        .attr('height', tHeight + BOX_PADDING_HEIGHT);

      t.attr('x', textX)
        .attr('y', textY);

      t.node().parentNode.appendChild(t.node());
    };

    var removeAllSelection = function () {
      fg.selectAll('.bar').attr('class', 'bar');
      fg.select('.interaction-group').remove();
    };

    fg.selectAll('.bar').on('click', cb);
    fg.selectAll('.bar').on('mousemove', cb);
    fg.selectAll('.bar').on('mouseout', function () {
      removeAllSelection();
    });
  };

  createXGraph = function (svg, dimensions, labels, options) {
    var x = {};
    if (!options) {
      options = {
        scale: 'linear',
        orientation: 'bottom'
      };
    }
    var width = Graph.prototype._getWidth(dimensions),
    range = {min: 0, max: width},
    // Axis should run from zero to 100%
    domain = {min: 0, max: 1};
    x.scale = Graph.prototype._makeScale(domain, range, {scale: options.scale});
    x.axis = Graph.prototype._makeAxis(x.scale, options);
    drawAxes(svg, x.axis, dimensions, false);
    drawLabel(svg, dimensions, labels.x, false);
    return x;
  };

  drawPath = function (svg, pathFn, data, duration, path, fill) {
    if (!path) {
      var fg = svg.select('g').select('#feature-group');
      // bring to front
      fg.node().parentNode.appendChild(fg.node());
      path = fg.append("svg:path")
        .attr("class", "line");
    }
    path.datum(data)
      .transition()
      .duration(duration)
      .attr("d", function (d) {
        // Prevent returning invalid values for d
        var p = pathFn(d) || "M0, 0";
        return p;
      })
      .style('fill', fill);
    return path;
  };

  addInteractionToPath = function (svg, dimensions, data, keys, labels, path, xy, duration) {
    var bisect = d3.bisector(function (d) { return d[keys.x]; }).right,
        height = Graph.prototype._getHeight(dimensions),
        fg = svg.select('#feature-group'),
        MIN_LABEL_Y = 50,
        LABEL_PADDING_X = 10,
        LABEL_PADDING_Y = 5;

    // Move listener rectangle to the front
    var el = svg.select('#listeners').node();
    el.parentNode.appendChild(el);

    var cb = function () {
      fg.select('.interaction-group').remove();

      var i = bisect(data, xy.x.scale.invert(d3.mouse(this)[0]));
      i = i === data.length ? data.length - 1 : i;
      var d = data[i];
      var value = keys.y.hasOwnProperty('y1') ? d[keys.y.y1] : d[keys.y];

      if (d[keys.x] === null || d[keys.y] === null) { return; }

      var y2 = xy.y.scale(value),
          x2 = xy.x.scale(d[keys.x]),
          xText = new Date(data[i][keys.x]).toLocaleString();

      var g = fg.append('g').attr('class', 'interaction-group');

      g.append('circle')
        .attr('r', 0)
        .attr('cx', x2)
        .attr('cy', y2)
        .transition()
        .ease('easeInOut')
        .duration(duration)
        .attr('r', 5);
      g.append('line')
        .attr('y1', y2)
        .attr('y2', y2)
        .attr('x1', 0)
        .attr('x2', x2);
      g.append('line')
        .attr('y1', height)
        .attr('y2', y2)
        .attr('x1', x2)
        .attr('x2', x2);

      var texty2 = Math.max(y2 - LABEL_PADDING_Y, MIN_LABEL_Y);

      g.append('text')
        .text(Math.round(value * 100) / 100 + ' ' + labels.y)
        .attr('class', 'graph-tooltip-y')
        .attr('x', LABEL_PADDING_X)
        .attr('y', texty2 - LABEL_PADDING_Y);
      g.append('text')
        .text(xText + ' ' + labels.x)
        .attr('class', 'graph-tooltip-x')
        .attr('x', x2 + LABEL_PADDING_X)
        .attr('y', height - LABEL_PADDING_Y);
    };

    svg.select('#listeners').on('click', cb);
    svg.select('#listeners').on('mousemove', cb);
    svg.select('#listeners').on('mouseout', function () {
      fg.select('.interaction-group').remove();
    });

  };

  /**
   * Draws or updates graph axis labels.
   * @param  {d3 selection} svg
   * @param  {object}       dimensions
   * @param  {string}       (optional) label, if undefined uupdates current.
   * @param  {boolean}      draw on y axis, else x-axis.
   */
  drawLabel = function (svg, dimensions, label, y) {
    var width = Graph.prototype._getWidth(dimensions),
        height = Graph.prototype._getHeight(dimensions),
        mv,
        // For some reason the x label needs to move a little bit more than
        // expected and the y label a little bit less.
        PIXEL_CORRECTION = 2,
        el = svg.select(y ? '#ylabel': '#xlabel');
    if (!el.empty()) {
      if (label) {
        el.text(label);
      }
      mv = y
        ? 0.5 * el.node().getBBox().height + PIXEL_CORRECTION
        : - 0.5 * el.node().getBBox().height + PIXEL_CORRECTION;
      el.attr('dy', mv);
   }
    else {
      el = svg.append("text")
        .attr('class', 'graph-text graph-label')
        .style("text-anchor", "middle")
        .text(label);
      mv = y
        ? 0.5 * el.node().getBBox().height + PIXEL_CORRECTION
        : - 0.5 * el.node().getBBox().height + PIXEL_CORRECTION;
      el.attr('dy', mv);
      if (y) {
        el.attr('id', 'ylabel')
          .attr('transform', 'rotate(-90)')
          .attr('y', 0)
          .attr('x', 0 - height / 2);
      } else {
        el.attr('id', 'xlabel')
          .attr('x', dimensions.padding.left + width / 2)
          .attr('y', dimensions.height);
      }
    }
  };

  drawAxes = function (svg, axis, dimensions, y, duration) {
    // Create elements and draw axis using nxtD3 method
    Graph.prototype._drawAxes(svg, axis, dimensions, y, duration);
    var axisEl;
    // Make graph specific changes to the x and y axis
    if (y) {
      axisEl = svg.select('#yaxis')
        .attr("class", "y-axis y axis")
        .selectAll("text")
          .style("text-anchor", "end")
          .attr('class', 'graph-text');
    } else {
      axisEl = svg.select('#xaxis')
        .attr("class", "x-axis x axis")
        .selectAll("text")
          .attr("dx", "-.8em")
          .attr("dy", ".15em")
          .style("text-anchor", "end")
          .attr('class', 'graph-text')
          .attr("transform", "rotate(-25)");
    }
  };

  createDonut = function (dimensions) {
    var donutHeight = Graph.prototype._getHeight(dimensions);
    dimensions.r = donutHeight / 2;
    var pie = createPie(dimensions),
    arc = createArc(dimensions);
    return {
      dimensions: dimensions,
      arc: arc,
      pie: pie
    };
  };

  createPie = function (dimensions) {
    return d3.layout.pie()
      .value(function (d) {
          return d.data;
        })
      // Sorting messes with the transition
      .sort(null);
  };

  createArc = function (dimensions) {
    var ARC_INNER_RADIUS = 0.7;
    return d3.svg.arc()
      .innerRadius(dimensions.r * ARC_INNER_RADIUS)
      .outerRadius(dimensions.r);
  };

  drawPie = function (svg, dimensions, donut, data) {
    var width = Graph.prototype._getWidth(dimensions),
    donutHeight = Graph.prototype._getHeight(dimensions),
    pie = donut.pie,
    arc = donut.arc;

    // Store the displayed angles in _current.
    // Then, interpolate from _current to the new angles.
    // During the transition, _current is updated in-place by d3.interpolate.
    function arcTween(a) {
      var i = d3.interpolate(this._current, a);
      this._current = i(0);
      return function (t) {
        return arc(i(t));
      };
    }

    var donutArcs = svg.datum(data).selectAll("path").data(pie);

    donutArcs
      .transition()
      .duration(Graph.prototype.transTime)
      .attrTween("d", arcTween); // redraw the arcs

    donutArcs.enter().append("path")
      .attr("fill", function (d) {return d.data.color; })
      .attr("d", arc)
      .each(function (d) { this._current = d; }) // store the initial angles
      .attr("transform", "translate(" +
        donutHeight / 2 + ", " + donutHeight / 2 + ")");
  };

  /**
   * Takes a data array and returns an array with length one/subsetFactor of the
   * input.
   *
   * It uses modulo to remove but every subsetFactor item in the array. As such
   * the result depends on the order of the input and it does not attempt to
   * simplify in a least intrusive way as e.g. douglas-peucker would. This is
   * probably faster though, which is the whole point.
   *
   * @param  {array}  data         array of data points to subset.
   * @param  {int}    subsetFactor describing how much smaller the subset should
   *                               be.
   * @return {array}               subset of data with lenght data.length /
   *                               subsetFactor.
   */
  getDataSubset = function (data, subsetFactor) {
    return data.filter(function (item, index) {
      return index % subsetFactor === 0; // returns true for every subsetFactor
                                         // th item;
    });
  };

  return Graph;

}]);

'use strict';


/**
 * @ngdoc directive
 * @class graph
 * @memberof app
 * @name graph
 * @requires Graph
 * @summary Creates a Graph, adds it to the graphCtrl and watches data to
 *          call graphCtrl.updateGraph.
 * @description  Usage: <graph <type> <attrs></graph>
 *               Angular runs graph.graphCtrl, graph.compile.preCompile,
 *               <type directive>.link, graph.link. It sets up a graph
 *               object and puts it on the graphCtrl for further
 *               modifications by the subdirectives.
 */
angular.module('lizard-nxt')
  .directive('graph', ["Graph", function (Graph) {

  var graphCtrl, preCompile, link;

  /**
   * @function
   * @memberOf angular.module('lizard-nxt')
  .graph
   * @param {scope}     scope     local scope
   * @param {object}    element
   * @param {object}    attrs     data, keys, labels and now
   * @param {object}    graphCtrl controller
   * @description       sets up a graph on the controller after
   *                    the controller's instantiation, but before
   *                    the link. Dimensions have sensible defaults
   *                    that may be partially overwritten by setting
   *                    the dimensions attribute of the graph.
   */
  preCompile = function (scope, element, attrs, graphCtrl) {
    /*
                       dimensions.width
                               |
                     |         ^             |
                      ______________________  _
                     |   |                  |
                     | y |   Chart area     |
                     |___|__________________|  }- Dimensions.height
                     |   |     x axis       |
    padding.bottom-- |___|_____x label______| _
                       |
                  padding.left

    Labels are placed next to the edge of the svg, remaining padding
    space is available for the axis tick marks.
    */

    var dimensions, el;

    dimensions = {
      width: 375,
      height: 160,
      padding: {
        top: 5,
        right: 5,
        bottom: 50,
        left: 50
      }
    };
    // Overwrite anything provided by dimensions attr on element
    angular.extend(dimensions, scope.dimensions);

    el = element.find('svg')[0];

    graphCtrl.yfilter = attrs.yfilter;
    graphCtrl.type = attrs.type;

    // Create the graph and put it on the controller
    graphCtrl.graph = new Graph(
      el,
      dimensions,
      scope.temporal
    );
  };

  /**
   * @function
   * @memberOf angular.module('lizard-nxt')
  .graph
   * @param {scope}     scope     local scope
   * @param {object}    element
   * @param {object}    attrs     data, keys, labels and now
   * @param {object}    graphCtrl controller
   * @description       Contains listeners to values on the element
   *                    and calls the updateFunctions of the graphCtrls
   *                    on the graphs. Suddirectives only have to implement
   *                    an update function on their controller.
   */
  link = function (scope, element, attrs, graphCtrl) {

    var graphUpdateHelper = function () {
      graphCtrl.setData(scope);

      // UpdateData is called with temporal.timelineMoving to draw subset for
      // performance reasons.
      graphCtrl.updateData.call(
        graphCtrl.graph,
        graphCtrl.data,
        graphCtrl.keys,
        graphCtrl.labels,
        graphCtrl.temporal,
        scope.temporal && scope.temporal.timelineMoving
      );

      // Call the graph with the now
      if (scope.temporal && scope.temporal.at) {
        graphCtrl.updateNow.call(graphCtrl.graph, scope.temporal.at);
      }
    };

    var dimsChangedCb = function () {
      if (!scope.dimensions
        || (scope.dimensions.width === graphCtrl.graph.dimensions.width
          && scope.dimensions.height === graphCtrl.graph.dimensions.height)) {
        return;
      }
      graphCtrl.graph.resize(scope.dimensions);
      graphUpdateHelper();
    };

    /**
     * Calls updateGraph when data is different than controller.data.
     * NOTE: Controller data is set on precompile.
     */
    scope.$watch('data', function (n, o) {
      if (n === graphCtrl.data) { return true; }
      graphUpdateHelper();
    });

    /**
     * Calls updateGraph when keys changes.
     */
    scope.$watch('keys', function (n, o) {
      if (n === o) { return true; }
      graphUpdateHelper();
    });

    scope.$watch('temporal.at', function (n, o) {
      if (n === o) { return true; }
      if (scope.temporal && scope.temporal.at) {
        graphCtrl.updateNow.call(graphCtrl.graph, scope.temporal.at);
      }
    });

    scope.$watch('temporal.start', function (n, o) {
      if (n === o) { return true; }
      graphUpdateHelper();
    });

    scope.$watch('temporal.end', function (n, o) {
      if (n === o) { return true; }
      graphUpdateHelper();
    });

    scope.$watch('dimensions.height', dimsChangedCb);

    scope.$watch('dimensions.width', dimsChangedCb);

    /**
     * Destroy graph to remove listeners when scope is erased.
     */
    scope.$on('$destroy' , function () { graphCtrl.graph.destroy(); });

    scope.title = attrs.name;

  };

  /**
   * @function
   * @memberOf angular.module('lizard-nxt')
  .graph
   * @param {scope}     $scope    local scope
   * @param {Graph}     Graph     graph service
   * @description       Stores the graph directives data and update functions
   */
  graphCtrl = function ($scope, Graph) {

    this.setData = function (scope) {

      // Provide defaults for backwards compatability
      this.data = scope.data || [];
      this.temporal = scope.temporal;
      this.keys = scope.keys || { x: 0, y: 1 };
      this.labels = {
        x: scope.xlabel || '',
        y: scope.ylabel || ''
      };
    };

    this.setData($scope);

    this.graph = {};
    this.yfilter = '';
    this.now = $scope.temporal ? $scope.temporal.at : undefined;
    this.type = '';
    this.quantity = $scope.quantity || 'time';

    // Define data update function in attribute directives
    this.updateData = function () {};
    // Define timeState.now update function in attribute directives
    this.updateNow = function () {};
  };


  return {
    controller: graphCtrl,
    compile: function (scope, element, attrs, graphCtrl) {
      return {
        pre: preCompile,
        post: link
      };
    },
    scope: {
      data: '=',
      xlabel: '=',
      ylabel: '=',
      keys: '=',
      mouseLoc: '=',
      yfilter: '=',
      dimensions: '=',
      temporal: '=',
      quantity: '='
    },
    restrict: 'E',
    replace: true,
    templateUrl: 'graph/graph.html'
  };

}]);


/**
 * @ngdoc directive
 * @class graph
 * @memberof angular.module('lizard-nxt')
  .graph
 * @name donut
 * @requires graph
 * @description       Draws a donut graph. Currently not in use by nxt.
 */
angular.module('lizard-nxt')
  .directive('donut', [function () {

  var link = function (scope, element, attrs, graphCtrl) {

    var graph = graphCtrl.graph;

    graph.drawDonut(graphCtrl.data);
    // Function to call when data changes
    graphCtrl.updateData = graph.drawDonut;

  };

  return {
    require: 'graph',
    link: link,
    restrict: 'A',
  };

}]);

/**
 * @ngdoc directive
 * @class graph
 * @memberof angular.module('lizard-nxt')
  .graph
 * @name line
 * @requires graph
 * @description       Draws a line. Additionally it sets the
 *                    location of the users mouse on the parent
 *                    scope. It was initially written for the
 *                    interction and maaiveldcurve.
 * @TODO: enhance its functionality to draw timeseries.
 */
angular.module('lizard-nxt')
  .directive('line', [function () {

  var link = function (scope, element, attrs, graphCtrl) {
    var data = graphCtrl.data,
        graph = graphCtrl.graph,
        keys = graphCtrl.keys,
        temporal = graphCtrl.type === 'temporal',
        drawSubset = false;

    graph.drawLine(data, keys, graphCtrl.labels, temporal, drawSubset);

    // scope.line is the scope defined by the line controller. Preferably it is
    // passed around more explicitly through the graph directive, but angular is
    // being bitchy.
    if (scope.line && scope.line.mouseLocFn) {
      graph.followMouse(scope.line.mouseLocFn);
      graph.mouseExit(scope.line.mouseLocFn);
    }

    if (temporal) {
      graph.drawNow(graphCtrl.now);
      // Function to call when timeState.at changes
      graphCtrl.updateNow = graph.drawNow;
    }

    // Function to call when data changes
    graphCtrl.updateData = graph.drawLine;

  };

  return {
    require: 'graph',
    link: link,
    restrict: 'A'
  };
}]);


/**
 * @ngdoc directive
 * @class graph
 * @memberof angular.module('lizard-nxt')
  .graph
 * @name barChart
 * @requires graph
 * @description       Draws a barchart. With dynamic axis label.
 *                    Initially written for the rain graph.
 */
angular.module('lizard-nxt')
  .directive('barChart', ['$filter', function ($filter) {

  var link = function (scope, element, attrs, graphCtrl) {

    var data = graphCtrl.data,
        labels = graphCtrl.labels,
        filter = graphCtrl.yfilter,
        graph = graphCtrl.graph,
        keys = graphCtrl.keys,
        quantity = graphCtrl.quantity;

    // Apply the filter on the ylabel to go from aggWindow
    // in ms to a nice 'mm/dag' label. This could be migrated
    // to the html, but filtering from the DOM is expensive
    // in angular.
    if (filter) {
      labels.y = $filter(filter)(labels.y);
    }

    graph.drawBars(data, keys, labels, quantity);
    graph.drawNow(graphCtrl.now);

    // Function to call when data changes
    graphCtrl.updateData = function (data, keys, labels) {
      if (filter) {
        labels.y = $filter(filter)(labels.y);
      }
      this.drawBars(data, keys, labels, quantity);
    };

    // Function to call when timeState.at changes
    graphCtrl.updateNow = graph.drawNow;

  };

  return {
    require: 'graph',
    link: link,
    restrict: 'A'
  };

}]);


/**
 * @ngdoc directive
 * @class graph
 * @memberof angular.module('lizard-nxt')
  .graph
 * @name horizontal stack
 * @requires graph
 * @description       Draws a barchart. With dynamic axis label.
 *                    Initially written to substitute the landuse donut.
 */
angular.module('lizard-nxt')
  .directive('horizontalStack', [function () {

  var link = function (scope, element, attrs, graphCtrl) {

    var graph = graphCtrl.graph;

    graph.drawHorizontalStack(graphCtrl.data, graphCtrl.keys, graphCtrl.labels);

    // Function to call when data changes
    graphCtrl.updateData = graph.drawHorizontalStack;

  };

  return {
    require: 'graph',
    link: link,
    restrict: 'A'
  };

}]);

/**
 *
 * Initialize dashboard module
 *
 */
angular.module('dashboard', [
    'map',
    'lizard-nxt-filters',
    ]);

/**
 *
 * Directive for dashboard component.
 *
 */
angular.module('dashboard')
  .controller('DashboardCtrl', [
      'DashboardService',
      function (DashboardService) {

    var that = this;
 
    DashboardService.getDashboard()
      .then(function (dashboard) {
        angular.extend(that, dashboard[0]);
          DashboardService.getData(that.dashboardelements);
        });
    
}]);

/**
 *
 * Service for dashboard.
 *
 * This is responsible for:
 * * retrieving dashboard belonging to user (?)
 * * retrieving data for dashboardelements
 * *
 *
 */
angular.module('dashboard')
.service('DashboardService', [
    'Restangular',
    'RasterService',
    'MapService',
    'State',
    'TimeseriesService',
    function (
      Restangular,
      RasterService,
      MapService,
      State,
      TimeseriesService
    ) {


      /**
       * @function
       * @description fetches dashboard definitions from REST api.
       * A dashboard is fetched based on the user name.
       * A dashboard consists of "dashboardelements". These define
       * what every seperate slot should show to the user.
       *
       */
      var getDashboard = function (id) {
        return Restangular.one('api/v2/dashboards/').getList()
          .then(function (response) {
            return response;
          });
      };

      /**
       * @function
       * @description Every dashboardelement has data to show
       * not every dashboardelement shows the same kind of data.
       * So perhaps in the future this should use the data-service
       * that is also being used for layergroup-service. At the moment
       * those two things are still very much dependent on each other.
       *
       */
      var getData = function (elements) {

        elements.forEach(function (el, i) {
          if (el.element_type === 'graph') {
            el.selectedTimeseries = { unit: 'unit'};
            TimeseriesService.getTimeseries(el.data.timeseries,
              el.temporal_bounds)
             .then(function (response) {
                el.dashboardData = response;
                if (response.length > 0) {
                  el.selectedTimeseries = el.dashboardData[0];
                }
              });
          } else if (el.element_type === 'rain') {
            var options = angular.extend({
              geom: L.latLng(el.latitude, el.longitude),
              agg: 'none'
            }, el.temporal_bounds);
            RasterService.getData({slug: 'rain'}, options)
              .then(function (response) {
                el.temporal_bounds.aggWindow = 300000;
                el.selectedTimeseries = response.data;
              });
          } else if (el.element_type === 'map') {
            State.layerGroups.active = el.data.map;
            State.spatial.view = {
              lat: el.latitude,
              lng: el.longitude,
              zoom: el.spatial_zoom
            };
          }

        });
      };

      return {
        getDashboard: getDashboard,
        getData: getData
      };

    }
  ]
);

/**
 *
 * Directive for dashboard component.
 */
angular.module('dashboard')
  .directive('dashboard', function () {

  var link = function (scope, element, attr) {

    var resizePane = function () {
      var PADDINGTOP = 70,
          SELECTORHEIGHT = 50,
          ROWMARGIN = 10,
          TITLEHEIGHT = 35;

      var height = angular.element('body').height();
      // if smaller screen below each other in stead of next to
      var width = (element.width() < 960) ? element.width() :
        element.width() / 3;

      var rowHeight = (height - PADDINGTOP) / 2 - ROWMARGIN;
      angular.element('.dashboard-row').height(rowHeight);
      scope.dashboard.dimensions = {
        height: rowHeight - SELECTORHEIGHT - TITLEHEIGHT,
        width: width - 120,
        padding: {
          top: 25,
          bottom: 60,
          left: 50,
          right: 10
        }
      };
    };

    scope.$on('$destroy', function () {
      window.removeEventListener('resize', resizePane);
    });

    window.addEventListener('resize', resizePane);
    resizePane();

  };


  return {
    link: link,
    replace: true,
    restrict: 'E',
    templateUrl: 'dashboard/dashboard.html'
  };
});


/**
 * Initialise angular.module('time-ctx')
 *
 */
angular.module('time-ctx', []);

angular.module('time-ctx')
  .controller("TimeCtxCtrl", ["$scope", "State", function ($scope, State) {

  this.state = State;

  // dimensions are dependent on screen size.
  // this is calculated in directive.
  this.dims = {};

  this.content = {};

  // statistics (maybe get dynamically from event aggregation service?)
  this.stats = ['max', 'min', 'mean', 'sum', 'median', 'count'];

  this.eventAggs = undefined;

  // default selection
  this.selectedStat = this.selectedStat || this.stats[2];

}]);


angular.module('time-ctx')
  .directive('timeCtx',
             [
              "EventAggregateService",
              "State",
              "DataService",
              "UtilService",
              "Timeline",
              function (EventAggregateService, State, DataService, UtilService, Timeline) {

  var link = function (scope, element, attrs) {

    var TL_TOP_MARGIN = 25, // margin plus the temporal.at label
        GRAPH_PADDING = 5,
        GRAPH_5_6th_PADDING_RATIO = 0.83, // The other 6th is used in the css.
        TOP_ROW_MIN_HEIGHT = 50,
        tlDims = {},
        nGraphs = 1;


    var getWidth = function () {
      return element.find('.dashboard-inner').width();
    };


    var getHeight = function () {
      return element.height() - TOP_ROW_MIN_HEIGHT;
                                    // min-height from top row, we need to make
                                    // this dynamic or bigger when we are going
                                    // to use the top row for maps etc.
    };

    var resize = function (tlDimensions) {
      tlDims = tlDimensions;
      nGraphs = Object.keys(scope.tctx.content).length;
      scope.tctx.dims.height =
        (getHeight() - tlDimensions.height - TL_TOP_MARGIN) / nGraphs - GRAPH_PADDING;
      scope.tctx.dims.width = UtilService.getCurrentWidth()
        + GRAPH_5_6th_PADDING_RATIO * UtilService.TIMELINE_LEFT_MARGIN;
    };

    scope.tctx.dims = {
      width: UtilService.getCurrentWidth()
        + GRAPH_5_6th_PADDING_RATIO * UtilService.TIMELINE_LEFT_MARGIN,
      height: getHeight() / nGraphs,
      padding: {
        top: GRAPH_PADDING,
        right: 0,
        bottom: 2 * GRAPH_PADDING, // Enough for the line of the axis.
        left: GRAPH_5_6th_PADDING_RATIO * UtilService.TIMELINE_LEFT_MARGIN
      }
    };


    var putDataOnScope = function (response) {

      var item = {};

      item = response;

      item.data = response.data || response.events;

      item.aggWindow = State.temporal.aggWindow;
      scope.tctx.content[response.layerSlug] = item;
    };

    var putEventDataOnScope = function (response) {

      if (response.data) {
        var lg = DataService.layerGroups[response.layerGroupSlug];
        // aggregate response
        var eventAgg = {
          data: EventAggregateService.aggregate(
            response.data,
            State.temporal.aggWindow,
            lg.mapLayers[0].color
          ),
          unit: lg.name,
        };

        // TODO: remove this ifje and do something with the graph to accomadate
        // datasets smaller than 2.
        if (eventAgg.data.length > 1) {
          putDataOnScope(angular.extend(response, eventAgg));
        }

      }

    };


    var geom = State.box.type === 'area'
      ? State.spatial.bounds
      : State.box.type === 'line'
        ? State.spatial.points
        : State.spatial.here;

    var getTimeData = function () {
      var graphWidth = scope.tctx.dims.width -
        scope.tctx.dims.padding.left -
        scope.tctx.dims.padding.right;

      DataService.getData('time', {
        geom: geom,
        start: State.temporal.start,
        end: State.temporal.end,
        minPoints: graphWidth,
        temporalOnly: true // TODO: actually implement this in data-service.
      }).then(null, null, function (response) {

        // TODO 1: prune this tree.. We need to request waterchain in order
        // to get timeseries from dataservice. This needs to change.
        //
        // TODO 2: We want to be able to use a filter to request only the
        // temporal data.
        //
        // TODO 3: Remove box filtering, always show all the data
        //
        if (response.layerSlug === 'waterchain_grid') {
          return;

        // Currently events for point and area and timeseries for point are
        // supported.
        } else if (response.layerSlug === 'timeseries') {
          angular.forEach(response.data, function (ts) {
            ts.layerSlug = ts.name;
            ts.name = ts.location.name
              + ', '
              + ts.parameter_referenced_unit.parameter_short_display_name;
            ts.type = response.layerSlug;
            ts.unit = ts
              .parameter_referenced_unit
              .referenced_unit_short_display_name;
            putDataOnScope(ts);
          });
        } else {
          if (response.type === 'Event') {
            putEventDataOnScope(response);
          } else if (
              State.box.type === 'point' &&
              response.type !== 'Event' &&
              response.data.length > 1) {
            putDataOnScope(response);
          }
        }

        if (tlDims) {
          resize(tlDims);
        }

      });
    };

    getTimeData();

    /**
     * Updates time-ctx when time zoom changes.
     */
    scope.$watch(State.toString('temporal.timelineMoving'), function (n, o) {
      if (n === o || State.temporal.timelineMoving) { return true; }
      getTimeData();
    });

    var applyResize = function () {
      scope.$apply(resize(tlDims));
      getTimeData();
    };

    Timeline.onresize = resize;

    window.addEventListener('resize', applyResize);

    scope.$on('$destroy', function () {
      window.removeEventListener('resize', applyResize);
    });

  };

  return {
    link: link,
    templateUrl: 'time-ctx/time-ctx.html',
    replace: true,
    restrict: 'E'
  };

}]);

/**
 * Initialise angular.module('scenarios')
 *
 */
angular.module('scenarios', []);
'use strict';

angular.module('scenarios')
  .directive('scenarios', function () {
    var link =  function (scope) {
    };

  return {
    link: link,
    templateUrl: 'scenarios/scenarios.html',
    replace: false,
    restrict: 'E'
  };

});

'use strict';

angular.module('scenarios')
.controller("ScenariosCtrl", [
  "$scope",
  "Restangular",
  "MapService",
  "DataService",
  "State", function ($scope, Restangular, MapService, DataService, State) {

    var PAGE_SIZE = 10.0,
        TABLE_MARGIN = 150;

    $scope.scenarios = [];
    $scope.selectedScenario = null;

    // It is pretty imposible to make the table the right length without js.
    $scope.tableHeight = window.innerHeight - TABLE_MARGIN + 'px';

    $scope.page = 1;

    $scope.getPage = function (page) {
      if (!page) {
        page = $scope.page;
      }
      $scope.loading = true;
      Restangular.one('api/v2/scenarios/?page=' + page).get()
        .then(function (response) {
          $scope.loading = false;
          // get the amount of pages for the ng-repeater
          var pages = Math.ceil(response.count / PAGE_SIZE);
          $scope.pages = _.range(1, pages + 1);
          $scope.scenarios = response.results;
        });
    };

    $scope.getPage();

    /**
     * @description Selects or deselects scenario.
     *
     */
    $scope.select = function (scenario) {
      if ($scope.selectedScenario === null) {
        $scope.selectedScenario = scenario;
        Restangular.one('api/v2/scenarios/' + scenario.id + '/').get()
          .then(function (response) {
            angular.extend(scenario, response);
          });
      } else if (scenario.id === $scope.selectedScenario.id) {
        $scope.selectedScenario = null;
      } else {
        $scope.selectedScenario = scenario;
      }
    };

    $scope.preview = function (result) {
      if (result.layer_group && !result.lg) {
        result.lg = DataService.createLayerGroup(result.layer_group);
        MapService.fitBounds(result.lg.spatialBounds);
      }
      if (result.lg) {
        DataService.toggleLayerGroup(result.lg);
      }
    };

  }
]);

/**
 *
 * Initialize user-menu module
 *
 */
angular.module('user-menu', []);

/**
 *
 * Shows user-menu and has logout login buttons
 */
angular.module('user-menu')
  .directive('userMenu', function () {
   
  var link = function () {};

  return {
    restrict: 'E',
    replace: true,
    link: link,
    templateUrl: 'user-menu/user-menu.html'
  };
  });

angular.module('data-menu')
  .directive('singleClick', ['$parse', function ($parse) {
    return {
      restrict: 'A',
      link: function (scope, element, attr) {
        var fn = $parse(attr.singleClick);
        var delay = 300,
            clicks = 0,
            timer = null;

        element.on('click', function (event) {
          clicks++;  //count clicks
          if (clicks === 1) {
            timer = setTimeout(function () {
              scope.$apply(function () {
                fn(scope, { $event: event });
              });
              clicks = 0;             //after action performed, reset counter
            }, delay);
          } else {
            clearTimeout(timer);    //prevent single-click action
            clicks = 0;             //after action performed, reset counter
          }
        });
      }
    };
  }
]);
/**
 * Opacity slider for layer-chooser.
 */
angular.module('data-menu')
  .directive('opacitySlider', function () {

  var link = function (scope, element, attrs) {
    var opacity = scope.layergroup.getOpacity();
    scope.percOpacity = opacity * 100 + '%';
    var layerChooserWidth = 170; // chrome is the new IE
    var localClick;

    /**
     * @description captures the location of click
     * and calculates the percentage of the width.
     * @params {event} jQuery event.
     */
    var adjustOpacity = function (e) {
      e.preventDefault();
      localClick = (e.originalEvent.layerX < 0) ? e.offsetX : e.originalEvent.layerX;
      if (localClick === undefined) {
        localClick = e.originalEvent.changedTouches[0].offsetX;
      }
      var newOpacity = localClick / layerChooserWidth;
      scope.$apply(function () {
        scope.percOpacity = newOpacity * 100 + '%';
      });

      scope.layergroup.setOpacity(newOpacity);

    };

    element.bind('click', adjustOpacity);
    element.bind('touch', adjustOpacity);
  };

  return {
    link: link,
    templateUrl: 'opacity/opacity.html',
    restrict: 'E',
    replace: true
  };
});

//layer-directive.js

angular.module('data-menu')
.directive("baselayerChooser", ['DataService', function (DataService)
{
  var link = function (scope) {

    var _allBLGs = DataService.baselayerGroups,
        _allBLGSlugs = _.pluck(_allBLGs, "slug"),
        _getActiveBLG = function () {
          return _.filter(_allBLGs, function (blg) {
            return blg.isActive();
          })[0];
        };

    scope.getNextInactiveBLG = function () {
      var activeBLGIndex = 0;
      if (_getActiveBLG()) {
        activeBLGIndex = _allBLGSlugs.indexOf(_getActiveBLG().slug);
      }
      return _allBLGs[(activeBLGIndex + 1) % _allBLGs.length];
    };
  };

  return {
    link: link,
    templateUrl: 'layer-chooser/baselayer-chooser.html',
    restrict: 'E',
  };

}]);

//layer-directive.js

angular.module('data-menu')
  .directive("eventlayerChooser", [function () {

  var link = function (scope, element) {
    scope.showOpacitySlider = false;
    element.find('.layer-img')[0].style.backgroundColor = scope.layergroup.mapLayers[0].color;
  };

  return {
    link: link,
    templateUrl: 'layer-chooser/eventlayer-chooser.html',
    restrict: 'E',
  };
}]);

angular.module('templates-main', ['dashboard/dashboard.html', 'data-menu/data-menu.html', 'graph/graph.html', 'layer-chooser/baselayer-chooser.html', 'layer-chooser/eventlayer-chooser.html', 'layer-chooser/layer-chooser.html', 'omnibox/templates/area.html', 'omnibox/templates/cardattributes.html', 'omnibox/templates/defaultpoint.html', 'omnibox/templates/empty.html', 'omnibox/templates/full-details.html', 'omnibox/templates/line.html', 'omnibox/templates/nestedasset.html', 'omnibox/templates/omnibox-search.html', 'omnibox/templates/point.html', 'omnibox/templates/rain.html', 'omnibox/templates/region.html', 'omnibox/templates/search-results.html', 'omnibox/templates/search.html', 'opacity/opacity.html', 'scenarios/scenarios.html', 'time-ctx/time-ctx.html', 'timeline/timeline.html', 'timeseries/timeseries.html', 'user-menu/user-menu.html']);

angular.module("dashboard/dashboard.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("dashboard/dashboard.html",
    "<div class=\"dashboard-wrapper container-fluid\" ng-controller=\"DashboardCtrl as dashboard\">\n" +
    "  <div class=\"row\">\n" +
    "    <h2 translate>Welcome <% user.firstName %> - <% dashboard.name %></h2>\n" +
    "  </div>\n" +
    "  <div class=\"row dashboard-row\">\n" +
    "    <div class=\"col-md-4\" ng-repeat=\"element in dashboard.dashboardelements | orderBy: dashboard_slot\">\n" +
    "      <h5 class=\"widget-title\" ng-if=\"element.element_type !== 'graph'\">\n" +
    "        <% element.display_name  %></h5>\n" +
    "\n" +
    "      <div ng-if=\"element.element_type === 'map'\" class=\"dashboard-widget\">\n" +
    "        <map></map>\n" +
    "      </div>\n" +
    "\n" +
    "\n" +
    "      <div\n" +
    "        ng-if=\"element.element_type === 'graph'\"\n" +
    "        class=\"dashboard-widget\">\n" +
    "        <h5 class=\"timeseries-header-container widget-title`\">\n" +
    "           <i class=\"fa fa-clock-o\"></i>\n" +
    "           <select class=\"timeseries\"\n" +
    "                  ng-if=\"element.dashboardData.length > 1\"\n" +
    "                  ng-model=\"element.selectedTimeseries\"\n" +
    "                  ng-options=\"series.name for series in element.dashboardData | rmZeroDatumTimeseries\">\n" +
    "           </select>\n" +
    "           <span class=\"card-title-text placeholder\"\n" +
    "                 ng-if=\"element.dashboardData.length === 1\">\n" +
    "                 <% element.selectedTimeseries.name %>\n" +
    "           </span>\n" +
    "\n" +
    "        </h5>\n" +
    "\n" +
    "        <graph\n" +
    "          line\n" +
    "          class=\"xyGraph\"\n" +
    "          type=\"temporal\"\n" +
    "          temporal=\"element.timestamp_bounds\"\n" +
    "          data=\"element.selectedTimeseries.events\"\n" +
    "          ylabel=\"element.selectedTimeseries.unit\"\n" +
    "          xlabel=\"\"\n" +
    "          dimensions=\"dashboard.dimensions\"\n" +
    "          mouseLoc=\"false\"\n" +
    "          keys=\"{x: 0, y: 1}\"\n" +
    "          now=\"element.temporal_bounds.start\">\n" +
    "        </graph>\n" +
    "      </div>\n" +
    "\n" +
    "      <div\n" +
    "        class=\"dashboard-widget\"\n" +
    "        ng-if=\"element.element_type === 'rain'\">\n" +
    "        <graph\n" +
    "          bar-chart\n" +
    "          class=\"xyGraph\"\n" +
    "          type=\"temporal\"\n" +
    "          temporal=\"element.temporal_bounds\"\n" +
    "          data=\"element.selectedTimeseries\"\n" +
    "          ylabel=\"300000\"\n" +
    "          yfilter=\"aggWinToYLabel\"\n" +
    "          dimensions=\"dashboard.dimensions\"\n" +
    "          mouseLoc=\"false\"\n" +
    "          keys=\"{x: 0, y: 1}\"\n" +
    "          now=\"element.temporal_bounds.start\">\n" +
    "        </graph>\n" +
    "\n" +
    "\n" +
    "      </div>\n" +
    "\n" +
    "    </div>\n" +
    "  </div>\n" +
    "\n" +
    "\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("data-menu/data-menu.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("data-menu/data-menu.html",
    "<div ng-controller=\"DatamenuController as menu\">\n" +
    "  <div class=\"layer-menu-container\">\n" +
    "    <div class=\"layer-switcher-wrapper\"\n" +
    "      ng-class=\"{'slide-left': menu.enabled}\">\n" +
    "\n" +
    "\n" +
    "      <div class=\"breakout-menu\"></div>\n" +
    "\n" +
    "      <div class=\"layer-switcher\">\n" +
    "\n" +
    "        <ul class=\"nav\">\n" +
    "\n" +
    "          <li class=\"nav-header\">\n" +
    "            <ul class=\"list-group\">\n" +
    "              <li>\n" +
    "                <baselayer-chooser></baselayer-chooser>\n" +
    "              </li>\n" +
    "              <li ng-repeat=\"layergroup in menu.layerGroups | orderObjectBy: 'order': false\"\n" +
    "                  ng-if=\"!(layergroup.isEventLayerGroup() || layergroup.baselayer)\">\n" +
    "                <layer-chooser layergroup=\"layergroup\">\n" +
    "                </layer-chooser>\n" +
    "              </li>\n" +
    "\n" +
    "              <li ng-repeat=\"layergroup in menu.layerGroups | orderObjectBy: 'order': false\"\n" +
    "                  ng-if=\"layergroup.isEventLayerGroup() && !layergroup.baselayer\">\n" +
    "                <eventlayer-chooser layergroup=\"layergroup\">\n" +
    "                </eventlayer-chooser>\n" +
    "              </li>\n" +
    "            </ul>\n" +
    "          </li>\n" +
    "        </ul>\n" +
    "      </div>\n" +
    "\n" +
    "      <div id=\"ribbon\"\n" +
    "           class=\"ribbon\"\n" +
    "           title=\"<% menu.enabled ? tooltips.closeMenu : tooltips.openMenu %>\">\n" +
    "        <div class=\"arrow arrow-up\" ng-click=\"menu.enabled = !menu.enabled\">\n" +
    "        </div>\n" +
    "        <div class=\"arrow arrow-down\" ng-click=\"menu.enabled = !menu.enabled\">\n" +
    "        </div>\n" +
    "      </div>\n" +
    "\n" +
    "      <span class=\"fa ribbon-icon clickable\" ng-class=\"{\n" +
    "              'fa-spinner fa-spin': menu.state.gettingData,\n" +
    "              'fa-compass': !menu.state.gettingData\n" +
    "            }\"\n" +
    "            ng-click=\"menu.enabled = !menu.enabled\"\n" +
    "            title=\"<% menu.enabled ? tooltips.closeMenu : tooltips.openMenu %>\">\n" +
    "      </span>\n" +
    "\n" +
    "      <div class=\"button-list-container\" id=\"\">\n" +
    "\n" +
    "        <div ng-if=\"context === 'map' || context === 'scenarios'\">\n" +
    "\n" +
    "          <div class=\"button-list-item\"\n" +
    "               style=\"cursor: pointer\">\n" +
    "            <a ng-click=\"menu.box.type = 'point'\"\n" +
    "               class=\"button-list-link\"\n" +
    "               title=\"<% 'Point selection' | translate %>\"\n" +
    "               ng-class=\"{'active': menu.box.type === 'point'}\">\n" +
    "               <i class=\"fa fa-map-marker\"></i>\n" +
    "            </a>\n" +
    "          </div>\n" +
    "\n" +
    "          <div class=\"button-list-item\"\n" +
    "               style=\"cursor: pointer\">\n" +
    "            <a ng-click=\"menu.box.type = 'line'\"\n" +
    "               class=\"button-list-link\"\n" +
    "               title=\"<% 'Line selection' | translate %>\"\n" +
    "               ng-class=\"{'active': menu.box.type === 'line'}\">\n" +
    "               <i class=\"fa fa-expand\"></i>\n" +
    "            </a>\n" +
    "          </div>\n" +
    "\n" +
    "          <div class=\"button-list-item\"\n" +
    "               style=\"cursor: pointer\">\n" +
    "            <a ng-click=\"menu.box.type = 'region'\"\n" +
    "               class=\"button-list-link\"\n" +
    "               title=\"<% 'Region selection' | translate %>\"\n" +
    "               ng-class=\"{'active': menu.box.type === 'region'}\">\n" +
    "               <i class=\"fa fa-lemon-o\"></i>\n" +
    "            </a>\n" +
    "          </div>\n" +
    "\n" +
    "          <div class=\"button-list-item\"\n" +
    "               style=\"cursor: pointer\">\n" +
    "            <a ng-click=\"menu.box.type = 'area'\"\n" +
    "               class=\"button-list-link\"\n" +
    "               title=\"<% 'View selection' | translate %>\"\n" +
    "               ng-class=\"{'active': menu.box.type === 'area'}\">\n" +
    "               <i class=\"fa fa-square-o\"></i>\n" +
    "            </a>\n" +
    "          </div>\n" +
    "\n" +
    "        </div>\n" +
    "\n" +
    "        <div class=\"button-list-item\"\n" +
    "             style=\"cursor: pointer\"\n" +
    "             ng-if=\"context === 'db'\">\n" +
    "\n" +
    "          <a ng-click=\"switchContext('map')\"\n" +
    "             class=\"button-list-link\"\n" +
    "             title=\"<% 'Show map' | translate %>\">\n" +
    "             <i class=\"fa fa-close\"></i>\n" +
    "          </a>\n" +
    "        </div>\n" +
    "\n" +
    "      </div>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("graph/graph.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("graph/graph.html",
    "<div class=\"graph-svg-wrapper\">\n" +
    "  <span ng-bind=\"title\" ng-style=\"{'left': 10 + dimensions.padding.left + 'px'}\"></span>\n" +
    "  <svg></svg>\n" +
    "</div>\n" +
    "");
}]);

angular.module("layer-chooser/baselayer-chooser.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("layer-chooser/baselayer-chooser.html",
    "<li class=\"noselect need-bottom-margin\">\n" +
    "    <!-- style=\"margin-bottom: 10px;\"> -->\n" +
    "\n" +
    "  <!-- special, \"baselayer\" menu-item (singular): -->\n" +
    "  <label class=\"layer-chooser\"\n" +
    "         ng-click=\"menu.toggleLayerGroup(getNextInactiveBLG())\"\n" +
    "         title=\"<% 'Baselayer' | translate %>\">\n" +
    "    <span class=\"layer-text\"\n" +
    "          style=\"color: #7f8c8d; width: 100%;\">\n" +
    "      <% getNextInactiveBLG().name %>\n" +
    "    </span>\n" +
    "  </label>\n" +
    "\n" +
    "</li>\n" +
    "");
}]);

angular.module("layer-chooser/eventlayer-chooser.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("layer-chooser/eventlayer-chooser.html",
    "<li class=\"noselect need-bottom-margin\">\n" +
    "  <label\n" +
    "    class=\"ng-class: {active: layergroup.isActive()}; layer-chooser\"\n" +
    "    for=\"<% layergroup.id %>-layer\"\n" +
    "    title=\"<% layergroup.name %>\">\n" +
    "    <div class=\"layer-img\" class=\"layer-chooser\" ng-style=\"layergroup.imageStyle\"></div>\n" +
    "    <span \n" +
    "      single-click=\"menu.toggleLayerGroup(layergroup)\"\n" +
    "      class=\"layer-text\" ng-bind=\"layergroup.name\">\n" +
    "    </span>\n" +
    "    <span\n" +
    "      ng-if=\"((layergroup.spatialBounds.north - layergroup.spatialBounds.east) !== 0)\n" +
    "             && layergroup.isActive()\"\n" +
    "      class=\"layer-icon\"\n" +
    "      single-click=\"menu.zoomToBounds(layergroup.spatialBounds, layergroup.temporalBounds)\">\n" +
    "        <i class=\"fa fa-crosshairs\"></i>\n" +
    "    </span>\n" +
    "  </label>\n" +
    "</li>\n" +
    "");
}]);

angular.module("layer-chooser/layer-chooser.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("layer-chooser/layer-chooser.html",
    "<li class=\"noselect\">\n" +
    "  <label\n" +
    "    class=\"ng-class: {active: layergroup.isActive()}; layer-chooser\"\n" +
    "    for=\"<% layergroup.id %>-layer\"\n" +
    "    title=\"<% layergroup.name %>\">\n" +
    "      <div class=\"layer-img\" class=\"layer-chooser\" ng-style=\"layergroup.imageStyle\"></div>\n" +
    "      <span\n" +
    "        single-click=\"menu.toggleLayerGroup(layergroup)\"\n" +
    "        ng-dblclick=\"layergroup.dblClick()\"\n" +
    "        class=\"layer-text\" ng-bind=\"layergroup.name\">\n" +
    "      </span>\n" +
    "      <span\n" +
    "        ng-if=\"((layergroup.spatialBounds.north - layergroup.spatialBounds.east) !== 0)\n" +
    "               && layergroup.isActive()\"\n" +
    "        class=\"layer-icon\"\n" +
    "        single-click=\"menu.zoomToBounds(layergroup.spatialBounds, layergroup.temporalBounds)\">\n" +
    "          <i class=\"fa fa-crosshairs\"></i>\n" +
    "      </span>\n" +
    "  </label>\n" +
    "</li>\n" +
    "\n" +
    "<opacity-slider title=\"<% tooltips.transparency %>\"></opacity-slider>\n" +
    "");
}]);

angular.module("omnibox/templates/area.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/area.html",
    "<div ng-controller=\"AreaCtrl\">\n" +
    "  <!-- area card for: layerGroup=waterchain; layer=waterchain_grid -->\n" +
    "  <div ng-if=\"countKeys(box.content.waterchain.layers.waterchain_grid.data) > 0\"\n" +
    "       class=\"card active\"\n" +
    "       id=\"card-waterchain\">\n" +
    "    <div class=\"card-content\">\n" +
    "      <div class=\"row\"\n" +
    "          ng-repeat=\"(entityName, entityData) in box.content.waterchain.layers.waterchain_grid.data\">\n" +
    "        <div class=\"col-xs-1\">\n" +
    "        </div>\n" +
    "        <div class=\"col-xs-9\">\n" +
    "          <% entityName | objectTitle %>\n" +
    "        </div>\n" +
    "        <div class=\"col-xs-1\">\n" +
    "          <strong>\n" +
    "            <% countKeys(entityData) %>\n" +
    "          </strong>\n" +
    "        </div>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "\n" +
    "  <div ng-repeat=\"(slug, lg) in box.content\"\n" +
    "       ng-if=\"slug !== 'rain' && slug !== 'waterchain'\"\n" +
    "       class=\"card active\" id=\"card-<% slug %>\">\n" +
    "\n" +
    "    <div\n" +
    "      ng-repeat=\"(lslug, l) in lg.layers\"\n" +
    "      ng-if=\"!!l && l.data\"\n" +
    "      ng-switch=\"l.aggType\"\n" +
    "      class=\"card-content\"\n" +
    "      id=\"card-content-<% l.name %>\">\n" +
    "\n" +
    "      <graph\n" +
    "        ng-switch-when=\"curve\"\n" +
    "        line xlabel=\"'[%]'\"\n" +
    "        ylabel=\"l.unit\"\n" +
    "        data=\"l.data\"\n" +
    "        keys=\"{x: 0, y: 1}\">\n" +
    "      </graph>\n" +
    "\n" +
    "      <graph\n" +
    "        ng-switch-when=\"histogram\"\n" +
    "        bar-chart\n" +
    "        quantity=\"'linear'\"\n" +
    "        ylabel=\"'[%]'\"\n" +
    "        xlabel=\"l.unit\"\n" +
    "        data=\"l.data\"\n" +
    "        keys=\"{x: 0, y: 1}\">\n" +
    "      </graph>\n" +
    "\n" +
    "      <graph\n" +
    "        ng-switch-when=\"counts\"\n" +
    "        horizontal-stack\n" +
    "        data=\"l.data\"\n" +
    "        keys=\"{x: 'data', y: 'label'}\"\n" +
    "        xlabel=\"'[%]'\"\n" +
    "        dimensions=\"{height: 80, padding: {left: 0, right: 0, top: 5, bottom: 50}}\">\n" +
    "      </graph>\n" +
    "\n" +
    "      <div ng-switch-default ng-switch=\"l.format\">\n" +
    "\n" +
    "        <graph\n" +
    "          ng-switch-when=\"Store\"\n" +
    "          line\n" +
    "          data=\"l.data\">\n" +
    "        </graph>\n" +
    "\n" +
    "        <div class=\"event-container row\"\n" +
    "          ng-switch-when=\"Vector\">\n" +
    "          <div class=\"col-xs-1\">\n" +
    "            <i class=\"fa fa-circle\" ng-style=\"{'color': l.color }\"></i>\n" +
    "          </div>\n" +
    "          <div class=\"col-xs-9\">\n" +
    "            <% lg.layerGroupName %>\n" +
    "          </div>\n" +
    "          <div class=\"col-xs-1\">\n" +
    "            <strong>\n" +
    "              <% l.data.length %>\n" +
    "            </strong>\n" +
    "          </div>\n" +
    "        </div>\n" +
    "\n" +
    "      </div>\n" +
    "\n" +
    "    </div>\n" +
    "  </div>\n" +
    "\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("omnibox/templates/cardattributes.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/cardattributes.html",
    "<div class=\"card-content\">\n" +
    "\n" +
    "  <span class=\"kunstwerk-title\" ng-class=\"{'sm-icon': !fullDetails};\">\n" +
    "\n" +
    "    <i id=\"icon-holder\"\n" +
    "      ng-class=\"$parent.getIconClass(waterchain.layers.waterchain_grid.data.entity_name)\">\n" +
    "    </i>\n" +
    "\n" +
    "    <span id=\"title-holder\"\n" +
    "          class=\"card-title-text kunstwerk-title-text\">\n" +
    "      <% waterchain.layers.waterchain_grid.data.entity_name | objectTitle %>\n" +
    "    </span>\n" +
    "    <full-details></full-details>\n" +
    "  </span>\n" +
    "\n" +
    "\n" +
    "  <table ng-if=\"fullDetails\" id=\"kunstwerk-table\" class=\"table table-condensed table-hover\">\n" +
    "\n" +
    "    <tr class=\"attr-row\"\n" +
    "        ng-repeat=\"obj in wanted[waterchain.layers.waterchain_grid.data.entity_name].rows\"\n" +
    "        >\n" +
    "\n" +
    "      <td class=\"fixed-width-card-table\">\n" +
    "        <div class=\"attr-row-content\">\n" +
    "          <% obj.keyName | translate %>\n" +
    "        </div>\n" +
    "      </td>\n" +
    "\n" +
    "      <td class=\"lineout\"\n" +
    "          ng-if=\"waterchain.layers.waterchain_grid.data[obj.attrName] !== undefined\n" +
    "            && waterchain.layers.waterchain_grid.data[obj.attrName] !== null\n" +
    "            && waterchain.layers.waterchain_grid.data[obj.attrName] !== ''\n" +
    "            && waterchain.layers.waterchain_grid.data[obj.attrName] !== 'pumps'\n" +
    "            && waterchain.layers.waterchain_grid.data[obj.attrName] !== 'filters'\">\n" +
    "        <div class=\"attr-row-content\" ng-bind-html=\"$eval(obj.ngBindValue) + obj.valueSuffix\">\n" +
    "        </div>\n" +
    "      </td>\n" +
    "\n" +
    "      <td class=\"lineout\"\n" +
    "          ng-if=\"waterchain.layers.waterchain_grid.data[obj.attrName] === undefined\n" +
    "            || waterchain.layers.waterchain_grid.data[obj.attrName] === null\n" +
    "            || waterchain.layers.waterchain_grid.data[obj.attrName] === ''\"\n" +
    "          rel=\"tooltip\"\n" +
    "          data-toggle=\"tooltip\"\n" +
    "          title=\"<% 'Example value' | translate %>\">\n" +
    "        <div class=\"attr-row-content dummy-attr-value\" ng-bind-html=\"obj.defaultValue + obj.valueSuffix\">\n" +
    "        </div>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </table>\n" +
    "\n" +
    "  <div class=\"structure-image-wrapper text-center\"\n" +
    "       ng-if=\"!!waterchain.layers.waterchain_grid.data.image_url && fullDetails\">\n" +
    "\n" +
    "      <img class=\"structure-image\"\n" +
    "           ng-src=\"{{waterchain.layers.waterchain_grid.data.image_url}}\" />\n" +
    "\n" +
    "  </div>\n" +
    "</div>\n" +
    "\n" +
    "");
}]);

angular.module("omnibox/templates/defaultpoint.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/defaultpoint.html",
    "<div>\n" +
    "  <div ng-repeat=\"l in lg.layers track by $index\">\n" +
    "    <div ng-switch=\"l.format\">\n" +
    "\n" +
    "      <div ng-switch-when=\"Store\">\n" +
    "        <div ng-if=\"!lg.temporal\">\n" +
    "          <table ng-if=\"l.scale === 'interval' || l.scale === 'ratio' \"\n" +
    "            class=\"table table-condensed table-hover single-row-table\">\n" +
    "            <thead>\n" +
    "              <td class=\"col-md-4\"><% l.quantity %> </td>\n" +
    "              <td class=\"col-md-4\"><% l.data[0] | number : 2 %> <% l.unit %></td>\n" +
    "              <td class=\"col-md-4\"></td>\n" +
    "            </thead>\n" +
    "          </table>\n" +
    "\n" +
    "          <table ng-if=\"l.scale === 'nominal' || l.scale === 'ordinal'\"\n" +
    "                 class=\"table table-condensed table-hover single-row-table\">\n" +
    "            <thead>\n" +
    "              <td class=\"col-md-2\">\n" +
    "                <div class=\"discrete-raster-color-indicator\"\n" +
    "                     ng-style=\"{'background-color': l.data[0].color}\">\n" +
    "                </div>\n" +
    "              </td>\n" +
    "              <td class=\"col-md-11\">\n" +
    "                <% lg.layerGroupName %>:&nbsp;<% l.data[0].label | discreteRasterType %>\n" +
    "              </td>\n" +
    "              <td class=\"col-md-2\"><% l.data[0].label | discreteRasterSource %></td>\n" +
    "            </thead>\n" +
    "          </table>\n" +
    "        </div>\n" +
    "        <graph ng-if=\"lg.temporal\"\n" +
    "          class=\"card-content\"\n" +
    "          line\n" +
    "          type=\"temporal\"\n" +
    "          temporal=\"state.temporal\"\n" +
    "          data=\"l.data\"\n" +
    "          ylabel=\"l.unit\"\n" +
    "          keys=\"{x: 0, y: 1}\">\n" +
    "        </graph>\n" +
    "      </div>\n" +
    "\n" +
    "      <div ng-switch-when=\"Vector\">\n" +
    "        <full-details class=\"table-details-toggler\"></full-details>\n" +
    "        <table class=\"table table-hover table-condensed\" >\n" +
    "          <thead>\n" +
    "              <th><i class=\"fa fa-circle\" ng-style=\"{'color': l.color }\"></i></th>\n" +
    "              <th><% lg.layerGroupName %></th>\n" +
    "              <th><% l.data.length %></th>\n" +
    "          </thead>\n" +
    "          <tbody ng-if=\"fullDetails\">\n" +
    "            <tr ng-repeat=\"event in l.data\">\n" +
    "                <td rel=\"tooltip\"\n" +
    "                    data-placement=\"left\"\n" +
    "                    title=\"<% event.properties.category %>\">\n" +
    "                    <i class=\"fa fa-circle\" ng-style=\"{'color': l.color }\">\n" +
    "                  </i>\n" +
    "                </td>\n" +
    "                <td rel=\"tooltip\"\n" +
    "                    data-placement=\"left\"\n" +
    "                    title=\"<% 'Start' | translate %>: <% event.properties.timestamp_start | date:'dd/MM/yyyy' %>\n" +
    "                           <% 'End' | translate %>: <% event.properties.timestamp_end | date:'dd/MM/yyyy' %>\">\n" +
    "                    <% event.properties.timestamp_start | date:'dd/MM/yyyy' %>\n" +
    "                </td>\n" +
    "                <td rel=\"tooltip\"\n" +
    "                    data-placement=\"left\"\n" +
    "                    title=\"<% event.properties.value %>\">\n" +
    "                  <% event.properties.value | truncate:17 %>\n" +
    "                </td>\n" +
    "              </tr>\n" +
    "          </tbody>\n" +
    "        </table>\n" +
    "      </div>\n" +
    "\n" +
    "      <div ng-switch-when=\"WMS\" ng-if=\"l.data.features\">\n" +
    "        <div class=\"card-content\">\n" +
    "\n" +
    "          <span id=\"title-holder\"\n" +
    "                class=\"card-title-text kunstwerk-title-text\">\n" +
    "            <% lg.layerGroupName %>\n" +
    "          </span>\n" +
    "          <full-details></full-details>\n" +
    "        </div>\n" +
    "\n" +
    "        <table ng-if=\"fullDetails\" class=\"table table-condensed table-hover\">\n" +
    "\n" +
    "          <tr class=\"attr-row\"\n" +
    "              ng-repeat=\"(key, val) in l.data.features[0].properties\">\n" +
    "\n" +
    "            <td class=\"fixed-width-card-table\">\n" +
    "              <div class=\"attr-row-content\">\n" +
    "                <% key %>\n" +
    "              </div>\n" +
    "            </td>\n" +
    "\n" +
    "            <td class=\"lineout\">\n" +
    "              <div ng-if=\"isUrl(val)\" class=\"attr-row-content\">\n" +
    "                <a href=\"<% val %>\" target=\"_blank\"><% val %></a>\n" +
    "              </div>\n" +
    "              <div ng-if=\"!isUrl(val)\" class=\"attr-row-content\">\n" +
    "                <% val %>\n" +
    "              </div>\n" +
    "            </td>\n" +
    "\n" +
    "          </tr>\n" +
    "        </table>\n" +
    "      </div>\n" +
    "\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("omnibox/templates/empty.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/empty.html",
    "");
}]);

angular.module("omnibox/templates/full-details.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/full-details.html",
    "<span class=\"full-details-toggle pull-right card-title-text\">\n" +
    "  <i class=\"fa fa-lg clickable\"\n" +
    "    ng-class=\"{'fa-caret-down': fullDetails, 'fa-caret-left': !fullDetails}\">\n" +
    "  </i> \n" +
    "\n" +
    "</span>\n" +
    "");
}]);

angular.module("omnibox/templates/line.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/line.html",
    "<div ng-controller=\"LineCtrl as line\">\n" +
    "\n" +
    "  <div ng-repeat=\"(slug, lg) in box.content\" class=\"card active\" id=\"card-<% l.name %>\">\n" +
    "    <div ng-repeat=\"l in lg.layers\"\n" +
    "      id=\"card-content-<% l.name %>\"\n" +
    "      class=\"card-content\"\n" +
    "      ng-if=\"l.data && (l.scale === 'interval' || l.scale === 'ratio')\">\n" +
    "      <div class=\"card-content\" id=\"card-content-<% agg.name %>\">\n" +
    "        <graph ng-if=\"l.scale === 'interval' || l.scale === 'ratio'\"\n" +
    "          line\n" +
    "          data=\"l.data\"\n" +
    "          ylabel=\"l.quantity + ' [' + l.unit + ']'\"\n" +
    "          xlabel=\"'Afstand in [m]'\">\n" +
    "        </graph>\n" +
    "<!--    TODO: get proper response from the server when requesting a line of\n" +
    "        nominal dat and decomment this line\n" +
    "        <graph ng-if=\"l.scale === 'nominal'\"\n" +
    "          horizontal-stack\n" +
    "          data=\"l.data\"\n" +
    "          keys=\"{x: 'data', y: 'label'}\"\n" +
    "          xlabel=\"'[%]'\"\n" +
    "          dimensions=\"{height: 80, padding: {left: 0, right: 0, top: 5, bottom: 50}}\">\n" +
    "        </graph> -->\n" +
    "\n" +
    "        <div class=\"card-tools\">\n" +
    "           <a\n" +
    "             class=\"btn btn-default btn-xs\"\n" +
    "             title=\"<% 'Export info card data' | translate %>\"\n" +
    "             ng-csv=\"formatLineCSV(slug, l)\"\n" +
    "             field-separator=\";\"\n" +
    "             filename=\"<% slug %>.csv\"\n" +
    "             csv-header=\"getLineCSVHeaders(slug, l)\">\n" +
    "             <i class=\"fa fa-share-square-o\"></i>\n" +
    "             <span translate>Export</span>\n" +
    "          </a>\n" +
    "        </div>\n" +
    "\n" +
    "      </div>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("omnibox/templates/nestedasset.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/nestedasset.html",
    "<div class=\"card-content\">\n" +
    "\n" +
    "  <div class=\"timeseries-header-container\">\n" +
    "\n" +
    "\n" +
    "    <i id=\"icon-holder\"\n" +
    "      ng-class=\"$parent.getIconClass(attr)\">\n" +
    "    </i>\n" +
    "\n" +
    "    <!-- <span class=\"kunstwerk-title\" ng-class=\"{'sm-icon': !fullDetails};\"> -->\n" +
    "      <span id=\"title-holder\"\n" +
    "            class=\"card-title-text kunstwerk-title-text\"\n" +
    "            ng-bind=\"attr | objectTitle\">\n" +
    "      </span>\n" +
    "    <!-- </span> -->\n" +
    "\n" +
    "    <select\n" +
    "      class=\"timeseries nested-asset\"\n" +
    "      ng-if=\"list.length > 1\"\n" +
    "      ng-class=\"{hidden: !fullDetails}\"\n" +
    "      ng-model=\"asset.selectedAsset\"\n" +
    "      ng-options=\"\n" +
    "        a.code !== '' ? a.code\n" +
    "        : a.serial !== '' ? a.serial\n" +
    "        : a.id\n" +
    "        for a in list track by a.id\">\n" +
    "    </select>\n" +
    "\n" +
    "    <full-details></full-details>\n" +
    "  </div>\n" +
    "\n" +
    "\n" +
    "  <table ng-if=\"fullDetails\" id=\"kunstwerk-table\" class=\"table table-condensed table-hover\">\n" +
    "\n" +
    "    <tr class=\"attr-row\"\n" +
    "        ng-if=\"list.length === 1\n" +
    "          && asset.selectedAsset.code !== undefined\n" +
    "          && asset.selectedAsset.code !== null\n" +
    "          && asset.selectedAsset.code !== ''\">\n" +
    "      <td class=\"fixed-width-card-table\">\n" +
    "        <div class=\"attr-row-content\">\n" +
    "          <% 'code' | translate %>\n" +
    "        </div>\n" +
    "      </td>\n" +
    "\n" +
    "      <td class=\"lineout\">\n" +
    "        <div class=\"attr-row-content\" ng-bind=\"asset.selectedAsset.code\">\n" +
    "        </div>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "\n" +
    "\n" +
    "    <tr class=\"attr-row\"\n" +
    "        ng-repeat=\"obj in wanted[attr].rows\"\n" +
    "        >\n" +
    "\n" +
    "      <td class=\"fixed-width-card-table\">\n" +
    "        <div class=\"attr-row-content\">\n" +
    "          <% obj.keyName | translate %>\n" +
    "        </div>\n" +
    "      </td>\n" +
    "\n" +
    "      <td class=\"lineout\"\n" +
    "          ng-if=\"asset.selectedAsset[obj.attrName] !== undefined\n" +
    "            && asset.selectedAsset[obj.attrName] !== null\n" +
    "            && asset.selectedAsset[obj.attrName] !== ''\">\n" +
    "        <div class=\"attr-row-content\" ng-bind-html=\"$eval(obj.ngBindValue) + obj.valueSuffix\">\n" +
    "        </div>\n" +
    "      </td>\n" +
    "\n" +
    "      <td class=\"lineout\"\n" +
    "          ng-if=\"asset.selectedAsset[obj.attrName] === undefined\n" +
    "            || asset.selectedAsset[obj.attrName] === null\n" +
    "            || asset.selectedAsset[obj.attrName] === ''\"\n" +
    "          rel=\"tooltip\"\n" +
    "          data-toggle=\"tooltip\"\n" +
    "          title=\"<% 'Example value' | translate %>\">\n" +
    "        <div class=\"attr-row-content dummy-attr-value\" ng-bind-html=\"obj.defaultValue + obj.valueSuffix\">\n" +
    "        </div>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </table>\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("omnibox/templates/omnibox-search.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/omnibox-search.html",
    "<div class=\"searchbox\" id=\"searchbox\" tabindex=\"-1\" role=\"search\">\n" +
    "  <search></search>\n" +
    "</div>\n" +
    "\n" +
    "<div id=\"cards\" class=\"pullDown cardbox\" ng-show=\"box.showCards\">\n" +
    "\n" +
    "  <!-- Search results go here -->\n" +
    "  <div class=\"card active\"\n" +
    "       ng-if=\"box.content.searchResults\">\n" +
    "    <search-results></search-results>\n" +
    "  </div>\n" +
    "\n" +
    "  <!-- Point/Line/Area box content goes here  -->\n" +
    "  <div id=\"box-type-cards\"></div>\n" +
    "\n" +
    " <div ng-if=\"context === 'scenarios'\">\n" +
    "   <scenarios></scenarios>\n" +
    "  </div>\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("omnibox/templates/point.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/point.html",
    "<div ng-controller=\"PointCtrl\">\n" +
    "\n" +
    "  <div ng-if=\"box.content.waterchain\">\n" +
    "    <div class=\"card active\">\n" +
    "      <cardattributes waterchain=\"box.content.waterchain\"></cardattributes>\n" +
    "    </div>\n" +
    "\n" +
    "    <timeseries\n" +
    "      ng-if=\"box.content.waterchain.layers.waterchain_grid.data.num_timeseries\"\n" +
    "      asset=\"box.content.waterchain.layers.waterchain_grid.data\"\n" +
    "      time-state=\"omnibox.state.temporal\">\n" +
    "    </timeseries>\n" +
    "  </div>\n" +
    "\n" +
    "  <div ng-if=\"box.content.waterchain.layers.waterchain_grid.data.filters\n" +
    "    || box.content.waterchain.layers.waterchain_grid.data.pumps\">\n" +
    "    <div class=\"card active\">\n" +
    "      <nestedasset\n" +
    "        asset=\"box.content.waterchain.layers.waterchain_grid.data\">\n" +
    "      </nestedasset>\n" +
    "    </div>\n" +
    "\n" +
    "    <timeseries\n" +
    "      ng-if=\"box.content.waterchain.layers.waterchain_grid.data.selectedAsset\"\n" +
    "      asset=\"box.content.waterchain.layers.waterchain_grid.data.selectedAsset\"\n" +
    "      time-state=\"omnibox.state.temporal\">\n" +
    "    </timeseries>\n" +
    "\n" +
    "  </div>\n" +
    "\n" +
    "\n" +
    "  <div ng-if=\"box.content.rain\">\n" +
    "    <rain></rain>\n" +
    "  </div>\n" +
    "\n" +
    "  <div ng-repeat=\"(slug, lg) in box.content\"\n" +
    "       class=\"card active\"\n" +
    "       ng-if=\"slug !== 'waterchain' && slug !== 'timeseries' && slug !== 'rain'\">\n" +
    "    <defaultpoint lg=\"lg\" name=\"slug\" state=\"omnibox.state\" is-url=\"isUrl\"></defaultpoint>\n" +
    "  </div>\n" +
    "\n" +
    "</div>\n" +
    "\n" +
    "");
}]);

angular.module("omnibox/templates/rain.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/rain.html",
    "<div ng-controller=\"rain\">\n" +
    "\n" +
    "  <div class=\"card active\">\n" +
    "    <div class=\"card-content\"\n" +
    "      ng-init=\"lg = box.content.rain\">\n" +
    "\n" +
    "      <% aggWinToYLabel %>\n" +
    "     <full-details></full-details>\n" +
    "     <span class=\"card-title-text\" ng-class=\"{hidden: fullDetails}\" translate>Rain</span>\n" +
    "     <div ng-class=\"{ hidden: !fullDetails }\">\n" +
    "       <graph\n" +
    "         bar-chart\n" +
    "         class=\"xyGraph\"\n" +
    "         data=\"lg.layers['rain'].data\"\n" +
    "         ylabel=\"lg.layers['rain'].aggWindow\"\n" +
    "         yfilter=\"aggWinToYLabel\"\n" +
    "         keys=\"{x: 0, y: 1}\"\n" +
    "         temporal=\"omnibox.state.temporal\">\n" +
    "       </graph>\n" +
    "       <div class=\"card-tools\"\n" +
    "        ng-class=\"{hidden: !fullDetails}\">\n" +
    "         <a ng-click=\"recurrenceTimeToggle()\"\n" +
    "            ng-class=\"{'active': rrc.active}\" class=\"btn btn-default btn-xs\"\n" +
    "            title=\"<% 'Extra statistieken, herhalingstijden' | translate %>\"\n" +
    "            translate>\n" +
    "            Statistics\n" +
    "          </a>\n" +
    "         <a\n" +
    "           class=\"btn btn-default btn-xs\"\n" +
    "           title=\"Data van deze infocard exporteren\"\n" +
    "           ng-csv=\"$parent.formatCSVColumns(lg.layers['rain'].data)\"\n" +
    "           field-separator=\";\"\n" +
    "           filename=\"neerslag.csv\"\n" +
    "           csv-header=\"['Latitude', 'Longitude', 'Datestamp', 'Timestamp', 'Rain (mm)']\">\n" +
    "           <i class=\"fa fa-share-square-o\"></i>\n" +
    "           <span translate>Export</span>\n" +
    "         </a>\n" +
    "       </div>\n" +
    "     </div>\n" +
    "   </div>\n" +
    "  </div>\n" +
    "\n" +
    "  <div class=\"card active ng-class: {hidden: !fullDetails}\" ng-if=\"rrc.active\">\n" +
    "    <div class=\"card-content-message\"\n" +
    "      ng-init=\"lg = box.content.rain\">\n" +
    "      <div class=\"recurrence-time-container\">\n" +
    "        <div ng-if=\"!rrc.data.message\">\n" +
    "          <table class=\"table table-hover table-condensed\">\n" +
    "            <caption translate>Recurrence times (RT)</caption>\n" +
    "            <thead>\n" +
    "              <tr>\n" +
    "                <td class=\"col-md-4 larger-font-card-table\" translate>Start</th>\n" +
    "                <td class=\"larger-font-card-table\" translate>Duration</th>\n" +
    "                <td class=\"larger-font-card-table text-right\" translate translate-comment=\"millimeters\">mm</th>\n" +
    "                <td class=\"larger-font-card-table\" translate translate-comment=\"Recurrence Time\">RT (years)</th>\n" +
    "              </tr>\n" +
    "            </thead>\n" +
    "            <tbody>\n" +
    "            <tr class=\"recurrence_time\"\n" +
    "              ng-repeat=\"recurTime in rrc.data.data\">\n" +
    "              <td class=\"larger-font-card-table\"><% recurTime.start | date : 'dd-MM-yyyy HH:mm' %></td>\n" +
    "              <td class=\"larger-font-card-table\"><% recurTime.td_window %></td>\n" +
    "              <td class=\"larger-font-card-table text-right\"><% recurTime.max | number: 1 %></td>\n" +
    "              <td class=\"larger-font-card-table\"><% recurTime.t %></td>\n" +
    "            </tr>\n" +
    "            </tbody>\n" +
    "          </table>\n" +
    "        </div>\n" +
    "        <div ng-if=\"rrc.data.message\">\n" +
    "          <span class=\"message\"><% rrc.data.message %></span>\n" +
    "        </div>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("omnibox/templates/region.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/region.html",
    "<div ng-controller=\"RegionCtrl\">\n" +
    "\n" +
    "  <div ng-if=\"activeName\" class=\"card active\" id=\"card-<% slug %>\">\n" +
    "    <div class=\"card-content\">\n" +
    "      <strong><% activeName %></strong> <% regionArea %> ha.\n" +
    "		</div>\n" +
    "	</div>\n" +
    "\n" +
    "  <div ng-repeat=\"(slug, lg) in box.content\"\n" +
    "       ng-if=\"slug !== 'waterchain'\"\n" +
    "       class=\"card active\" id=\"card-<% slug %>\">\n" +
    "\n" +
    "    <div\n" +
    "      ng-repeat=\"(lslug, l) in lg.layers\"\n" +
    "      ng-if=\"!!l && l.data\"\n" +
    "      ng-switch=\"l.aggType\"\n" +
    "      class=\"card-content\"\n" +
    "      id=\"card-content-<% l.name %>\">\n" +
    "\n" +
    "      <graph\n" +
    "        ng-switch-when=\"curve\"\n" +
    "        line xlabel=\"'[%]'\"\n" +
    "        ylabel=\"l.unit\"\n" +
    "        data=\"l.data\"\n" +
    "        keys=\"{x: 0, y: 1}\">\n" +
    "      </graph>\n" +
    "\n" +
    "      <graph\n" +
    "        ng-switch-when=\"histogram\"\n" +
    "        bar-chart\n" +
    "        quantity=\"'linear'\"\n" +
    "        ylabel=\"'[%]'\"\n" +
    "        xlabel=\"l.unit\"\n" +
    "        data=\"l.data\"\n" +
    "        keys=\"{x: 0, y: 1}\">\n" +
    "      </graph>\n" +
    "\n" +
    "      <!-- Rain -->\n" +
    "      <graph\n" +
    "        ng-switch-when=\"sum\"\n" +
    "        bar-chart\n" +
    "        quantity=\"'time'\"\n" +
    "        ylabel=\"l.unit\"\n" +
    "        data=\"l.data\"\n" +
    "        keys=\"{x: 0, y: 1}\"\n" +
    "        temporal=\"omnibox.state.temporal\">\n" +
    "      </graph>\n" +
    "\n" +
    "      <graph\n" +
    "        ng-switch-when=\"counts\"\n" +
    "        horizontal-stack\n" +
    "        data=\"l.data\"\n" +
    "        keys=\"{x: 'data', y: 'label'}\"\n" +
    "        xlabel=\"'[%]'\"\n" +
    "        dimensions=\"{height: 80, padding: {left: 0, right: 0, top: 5, bottom: 50}}\">\n" +
    "      </graph>\n" +
    "\n" +
    "      <div ng-switch-default ng-switch=\"l.format\">\n" +
    "\n" +
    "        <graph\n" +
    "          ng-switch-when=\"Store\"\n" +
    "          line\n" +
    "          data=\"l.data\">\n" +
    "        </graph>\n" +
    "\n" +
    "      </div>\n" +
    "\n" +
    "    </div>\n" +
    "\n" +
    "  </div>\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("omnibox/templates/search-results.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/search-results.html",
    "<div>\n" +
    "\n" +
    "	<div\n" +
    "		ng-if=\"box.content.searchResults.temporal\"\n" +
    "		class=\"cluster location\">\n" +
    "	  <i class=\"fa fa-clock-o\"></i>&nbsp;\n" +
    "	  <a ng-click=\"zoomToTemporalResult(box.content.searchResults.temporal)\"\n" +
    "	    class=\"pointer clickable\">\n" +
    "	    <span><% box.content.searchResults.temporal.format(\n" +
    "	    	box.content.searchResults.temporal.nxtFormatString\n" +
    "	    ) %></span>\n" +
    "	  </a>\n" +
    "	</div>\n" +
    "\n" +
    "	<div ng-cloak\n" +
    "	  ng-repeat=\"result in box.content.searchResults.spatial\"\n" +
    "	  class=\"cluster location\">\n" +
    "	  <i class=\"fa fa-map-marker\"></i>&nbsp;\n" +
    "	  <a ng-click=\"zoomToSpatialResult(result)\"\n" +
    "	    class=\"pointer clickable\">\n" +
    "	    <span><% result.formatted_address %></span>\n" +
    "	  </a>\n" +
    "	</div>\n" +
    "\n" +
    "</div>\n" +
    "\n" +
    "");
}]);

angular.module("omnibox/templates/search.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("omnibox/templates/search.html",
    "<div class=\"searchboxinput\">\n" +
    "  <input id=\"searchboxinput\"\n" +
    "    ng-change=\"search()\"\n" +
    "    tabindex=\"-1\"\n" +
    "    placeholder=\"<% 'Search for places, or dates (i.e. 23-10-2013)' | translate %>\"\n" +
    "    autocomplete=\"off\"\n" +
    "    dir=\"ltr\"\n" +
    "    ng-model=\"query\"\n" +
    "    ng-keydown=\"searchKeyPress($event)\"\n" +
    "    spellcheck=\"false\">\n" +
    "  <div\n" +
    "    title=\"<% tooltips.resetQuery %>\"\n" +
    "    ng-click=\"cleanInput()\"\n" +
    "    id=\"clear\" class=\"clickable\" ></div>\n" +
    "  <div class=\"search-button-collection\">\n" +
    "    <button\n" +
    "      class=\"searchbutton clickable\"\n" +
    "      ng-click=\"zoomIn()\"\n" +
    "      aria-label=\"Zoom in\"\n" +
    "      title=\"<% tooltips.zoomInMap %>\">\n" +
    "      <i class=\"fa fa-plus\"></i>\n" +
    "    </button>\n" +
    "    <button\n" +
    "      class=\"searchbutton clickable\"\n" +
    "      ng-click=\"zoomOut()\"\n" +
    "      aria-label=\"Zoom uit\"\n" +
    "      title=\"<% tooltips.zoomOutMap %>\">\n" +
    "      <i class=\"fa fa-minus\"></i>\n" +
    "    </button>\n" +
    "  </div>\n" +
    "\n" +
    "</div>\n" +
    "\n" +
    "");
}]);

angular.module("opacity/opacity.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("opacity/opacity.html",
    "<div class=\"ng-class: {inactive: !layergroup.isActive() || layergroup.baselayer || !showOpacitySlider}; progress\">\n" +
    "    <div class=\"progress-bar\" role=\"progressbar\" ng-style=\"{ 'width': percOpacity }\">\n" +
    "      <span class=\"sr-only\"></span>\n" +
    "    </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("scenarios/scenarios.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("scenarios/scenarios.html",
    "<div class=\"card\" ng-controller=\"ScenariosCtrl\">\n" +
    "  <div class=\"card-content\">\n" +
    "    <div ng-if=\"loading\">\n" +
    "      <i class=\"fa fa-refresh fa-spin\"></i>\n" +
    "    </div>\n" +
    "\n" +
    "    <div ng-if=\"selectedScenario === null\">\n" +
    "      <span id=\"title-holder\" class=\"card-title-text ng-binding\" translate>\n" +
    "        3di resultaten\n" +
    "      </span>\n" +
    "\n" +
    "      <table class=\"table table-hover scenarios-table\">\n" +
    "        <tbody\n" +
    "          ng-if=\"scenarios.length > 0\"\n" +
    "          class=\"scenarios-table-body\"\n" +
    "          >\n" +
    "          <tr ng-repeat=\"scenario in scenarios | filter: query\"\n" +
    "            class=\"scenarios-table-row clickable\">\n" +
    "            <td ng-click=\"select(scenario)\" title=\"<% scenario.model_name %>\"><% scenario.name %> </td>\n" +
    "            <td ng-click=\"select(scenario)\" class=\"clickable text-right\" ><% scenario.created | date: 'M/d/y HH:mm:ss' %></td>\n" +
    "          </tr>\n" +
    "        </tbody>\n" +
    "\n" +
    "      </table>\n" +
    "\n" +
    "      <nav>\n" +
    "        <ul class=\"pagination\">\n" +
    "          <li>\n" +
    "          <a ng-click=\"getPage(page - 1)\" aria-label=\"Previous\">\n" +
    "            <span aria-hidden=\"true\">&laquo;</span>\n" +
    "          </a>\n" +
    "          </li>\n" +
    "          <li ng-repeat=\"_page in pages\" ng-class=\"{active: page === _page}\">\n" +
    "            <a ng-click=\"getPage(_page)\"><% _page %></a>\n" +
    "          </li>\n" +
    "          <li>\n" +
    "          <a ng-click=\"getPage(page + 1)\" aria-label=\"Next\">\n" +
    "            <span aria-hidden=\"true\">&raquo;</span>\n" +
    "          </a>\n" +
    "          </li>\n" +
    "        </ul>\n" +
    "      </nav>\n" +
    "\n" +
    "    </div>\n" +
    "\n" +
    "    <div ng-if=\"selectedScenario\">\n" +
    "      <a ng-click=\"select(selectedScenario)\" class=\"clickable\" title=\"Terug\"><i class=\"fa fa-arrow-left\"></i></a>\n" +
    "\n" +
    "      <span id=\"title-holder\" class=\"card-title-text ng-binding\">\n" +
    "        <% selectedScenario.name %> -\n" +
    "        <a href=\"https://models.lizard.net/model_databank/models/<% selectedScenario.model_name %>/commits/\" target=\"_blank\" title=\"Go to the Model database\"><% selectedScenario.model_name %></a> #<% selectedScenario.model_revision %>\n" +
    "      </span>\n" +
    "\n" +
    "      <table class=\"table table-condensed result-table\">\n" +
    "        <tr>\n" +
    "          <td><span translate>Started (simulation time)</span></td>\n" +
    "          <td><% selectedScenario.start_time_sim | date: 'M/d/y HH:mm:ss' %></td>\n" +
    "        </tr>\n" +
    "        <tr>\n" +
    "          <td><span translate>Ended (simulation time)</span></td>\n" +
    "          <td><% selectedScenario.end_time_sim | date: 'M/d/y HH:mm:ss' %></td>\n" +
    "        </tr>\n" +
    "        <tr\n" +
    "          ng-class=\"{'selected-result': result.lg._active, clickable: result.layer_group}\"\n" +
    "          ng-repeat=\"result in selectedScenario.result_set\">\n" +
    "          <td ng-click=\"preview(result)\"><% result.result_type.name %>\n" +
    "            <a ng-if=\"result.layer_group\" translate>(preview)</a>\n" +
    "         </td>\n" +
    "          <td>\n" +
    "            <a ng-if=\"result.result_type.code !== 'damage_estimation_json'\"\n" +
    "               href=\"<% result.attachment_url %>\" target=\"_blank\" translate>Download</a>\n" +
    "            <a ng-if=\"result.result_type.code === 'damage_estimation_json'\"\n" +
    "               href=\"<% result.attachment_url %>\" target=\"_blank\" translate>\n" +
    "              <span translate>\n" +
    "                €<% result.value | number: 2%> | Download\n" +
    "              </span>\n" +
    "            </a>\n" +
    "          </td>\n" +
    "        </tr>\n" +
    "      </table>\n" +
    "      <span ng-if=\"selectedScenario.result_set.length === 0\" translate>\n" +
    "        No results\n" +
    "      </span>\n" +
    "    </div>\n" +
    "\n" +
    "  </div><!-- card-content-->\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("time-ctx/time-ctx.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("time-ctx/time-ctx.html",
    "<div class=\"dashboard-wrapper\" ng-controller=\"TimeCtxCtrl as tctx\">\n" +
    "  <div class=\"container-fluid\">\n" +
    "\n" +
    "    <div class=\"row\">\n" +
    "\n" +
    "      <div id=\"time-ctx-top-row-place-holder\" class=\"col-md-10 dashboard-inner\"></div>\n" +
    "\n" +
    "    </div>\n" +
    "    <div class=\"row\" ng-repeat=\"item in tctx.content\">\n" +
    "\n" +
    "      <div class=\"dashboard-inner\">\n" +
    "\n" +
    "        <graph\n" +
    "          ng-if=\"item.type === 'timeseries'\"\n" +
    "          line\n" +
    "          data=\"item.data\"\n" +
    "          dimensions=\"tctx.dims\"\n" +
    "          type=\"temporal\"\n" +
    "          temporal=\"tctx.state.temporal\"\n" +
    "          ylabel=\"item.unit\"\n" +
    "          keys=\"{\n" +
    "            x: 'timestamp',\n" +
    "            y: { 'y0': 'min', 'y1': 'max' }\n" +
    "          }\"\n" +
    "          name=\"<% item.name %>\">\n" +
    "        </graph>\n" +
    "\n" +
    "        <graph\n" +
    "          ng-if=\"item.type !== 'timeseries'\n" +
    "            && item.scale !== 'ratio'\n" +
    "            && item.type !== 'Event'\"\n" +
    "          line\n" +
    "          data=\"item.data\"\n" +
    "          dimensions=\"tctx.dims\"\n" +
    "          type=\"temporal\"\n" +
    "          temporal=\"tctx.state.temporal\"\n" +
    "          ylabel=\"item.unit\"\n" +
    "          keys=\"{x: 0, y: 1}\"\n" +
    "          name=\"<% item.quantity %>\">\n" +
    "        </graph>\n" +
    "\n" +
    "        <graph\n" +
    "          ng-if=\"item.type === 'Event'\"\n" +
    "          bar-chart\n" +
    "          data=\"item.data\"\n" +
    "          ylabel=\"item.unit\"\n" +
    "          keys=\"{x: 'timestamp',\n" +
    "                 y: 'count',\n" +
    "                 color: 'color',\n" +
    "                 category: 'category'}\"\n" +
    "          dimensions=\"tctx.dims\"\n" +
    "          temporal=\"tctx.state.temporal\"\n" +
    "          name=\"<% item.quantity %>\">\n" +
    "        </graph>\n" +
    "\n" +
    "        <graph\n" +
    "          ng-if=\"item.scale === 'ratio'\"\n" +
    "          bar-chart\n" +
    "          data=\"item.data\"\n" +
    "          dimensions=\"tctx.dims\"\n" +
    "          type=\"temporal\"\n" +
    "          temporal=\"tctx.state.temporal\"\n" +
    "          ylabel=\"item.aggWindow\"\n" +
    "          yfilter=\"aggWinToYLabel\"\n" +
    "          keys=\"{x: 0, y: 1}\"\n" +
    "          name=\"<% item.quantity %>\">\n" +
    "        </graph>\n" +
    "\n" +
    "      </div>\n" +
    "\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("timeline/timeline.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("timeline/timeline.html",
    "<div id=\"timeline\"\n" +
    "     ng-controller=\"TimeCtrl as timeline\">\n" +
    "\n" +
    "    <div class=\"clock-wrapper noselect\">\n" +
    "\n" +
    "      <!-- TODO?: use toLocaleString() for datetime dutchification? -->\n" +
    "\n" +
    "      <div class=\"clock-time\">\n" +
    "        <div\n" +
    "           ng-click=\"timeline.toggleTimelineVisiblity()\"\n" +
    "           ng-bind=\"timeline.state.temporal.at | date: timeline.formatDatetime()\">\n" +
    "        </div>\n" +
    "        <div ng-if=\"timeline.showContextSwitch\">\n" +
    "          <a\n" +
    "            ng-click=\"timeline.toggleTimeCtx()\"\n" +
    "            class=\"button-list-link\"\n" +
    "            title=\"<% 'Show dashboard' | translate %>\"\n" +
    "            style=\"cursor: pointer;\">\n" +
    "            <i class=\"fa\" ng-class=\"{\n" +
    "              'fa-minus-square': timeline.state.context === 'time',\n" +
    "              'fa-bar-chart': timeline.state.context === 'map'\n" +
    "            }\"></i>\n" +
    "          </a>\n" +
    "        </div>\n" +
    "      </div>\n" +
    "\n" +
    "    </div>\n" +
    "\n" +
    "  <div class=\"timeline-wrapper\">\n" +
    "    <div class=\"time-controls\" ng-if=\"timeline.animatable\">\n" +
    "      <div class=\"btn-group\">\n" +
    "        <a ng-click=\"timeline.playPauseAnimation()\"\n" +
    "           class=\"extra-padding timeline-button\"\n" +
    "           ng-class=\"{\n" +
    "            'active': timeline.state.temporal.playing,\n" +
    "            'hidden': !timeline.animatable\n" +
    "           }\"\n" +
    "           title=\"<% timeline.state.temporal.playing ? tooltips.stopAnim : tooltips.startAnim %>\"\n" +
    "           data-original-title=\"<% 'Play/pause' | translate %>\">\n" +
    "          <span\n" +
    "            class=\"fa\"\n" +
    "            ng-class=\"{\n" +
    "              'fa-circle-o-notch fa-spin': timeline.state.layerGroups.timeIsSyncing,\n" +
    "              'fa-pause active': timeline.state.temporal.playing,\n" +
    "              'fa-play': !timeline.state.temporal.playing && !timeline.state.layerGroups.timeIsSyncing,\n" +
    "              }\">\n" +
    "          </span>\n" +
    "        </a>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "    <div id=\"timeline-svg-wrapper\" class=\"timeline-svg-wrapper\">\n" +
    "      <svg></svg>\n" +
    "    </div>\n" +
    "    <div class=\"time-controls-right\">\n" +
    "      <div class=\"btn-group-horizontal\">\n" +
    "          <a class=\"btn btn-default btn-xss\" ng-click=\"timeline.zoom('in')\"\n" +
    "            class=\"extra-padding timeline-button\"\n" +
    "            title=\"<% tooltips.zoomInTimeline %>\"\n" +
    "            data-original-title=\"Zoom in\">\n" +
    "            <i class=\"fa fa-plus\"></i>\n" +
    "          </a>\n" +
    "          <a class=\"btn btn-default btn-xss\" ng-mousedown=\"timeline.zoomToNow()\"\n" +
    "            class=\"extra-padding timeline-button\"\n" +
    "            title=\"<% tooltips.goToNow %>\"\n" +
    "            data-original-title=\"Naar nu\">\n" +
    "            <i class=\"fa fa-clock-o\"></i>\n" +
    "          </a>\n" +
    "          <a class=\"btn btn-default btn-xss\" ng-click=\"timeline.zoom('out')\"\n" +
    "            class=\"extra-padding timeline-button\"\n" +
    "            title=\"<% tooltips.zoomOutTimeline %>\"\n" +
    "            data-original-title=\"Zoom uit\">\n" +
    "            <i class=\"fa fa-minus\"></i>\n" +
    "          </a>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("timeseries/timeseries.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("timeseries/timeseries.html",
    "<div class=\"card active\" ng-if=\"timeseries.data.length > 0\">\n" +
    "  <div class=\"card-content\"\n" +
    "       ng-class=\"{timeseries: fullDetails}\">\n" +
    "\n" +
    "    <div class=\"timeseries-header-container\">\n" +
    "      <i class=\"fa fa-clock-o\" ng-class=\"{'fa-spin': fetching}\"></i>\n" +
    "      <select\n" +
    "        class=\"timeseries\"\n" +
    "        ng-if=\"timeseries.data.length > 1\"\n" +
    "        ng-class=\"{hidden: !fullDetails}\"\n" +
    "        ng-model=\"timeseries.selectedTimeseries\"\n" +
    "        ng-options=\"ts.location.name\n" +
    "          + ', '\n" +
    "          + ts.parameter_referenced_unit.parameter_short_display_name\n" +
    "          for ts in timeseries.data\n" +
    "        \">\n" +
    "      </select>\n" +
    "      <span\n" +
    "        class=\"card-title-text placeholder\"\n" +
    "        ng-if=\"timeseries.data.length === 1 && fullDetails\">\n" +
    "        <% timeseries.selectedTimeseries.location.name\n" +
    "          + ', '\n" +
    "          + timeseries.selectedTimeseries.parameter_referenced_unit.parameter_short_display_name %>\n" +
    "      </span>\n" +
    "      <span class=\"card-title-text placeholder\" ng-class=\"{hidden: fullDetails}\" translate>Timeseries</span>\n" +
    "      <full-details></full-details>\n" +
    "    </div>\n" +
    "\n" +
    "    <br>\n" +
    "\n" +
    "    <div class=\"timeseries-graph-container\"\n" +
    "        ng-class=\"{hidden: !fullDetails}\"\n" +
    "        ng-if=\"$parent.box.content.waterchain.layers.waterchain_grid.data.entity_name === 'measuringstation' && $parent.box.content.waterchain.layers.waterchain_grid.data.station_type === 1\">\n" +
    "       <graph\n" +
    "          bar-chart\n" +
    "          type=\"temporal\"\n" +
    "          temporal=\"timeState\"\n" +
    "          data=\"timeseries.selectedTimeseries.events\"\n" +
    "          ylabel=\"timeseries\n" +
    "            .selectedTimeseries\n" +
    "            .parameter_referenced_unit\n" +
    "            .referenced_unit_short_display_name\"\n" +
    "          xlabel=\"\"\n" +
    "          keys=\"{\n" +
    "            x: 'timestamp',\n" +
    "            y: 'min'\n" +
    "          }\"\n" +
    "          now=\"timeState.at\">\n" +
    "        </graph>\n" +
    "    </div>\n" +
    "\n" +
    "    <div class=\"timeseries-graph-container\"\n" +
    "      ng-class=\"{hidden: !fullDetails}\"\n" +
    "        ng-if=\"$parent.box.content.waterchain.layers.waterchain_grid.data.entity_name === 'measuringstation' && $parent.box.content.waterchain.layers.waterchain_grid.data.station_type !== 1\">\n" +
    "      <graph\n" +
    "        line\n" +
    "        type=\"temporal\"\n" +
    "        temporal=\"timeState\"\n" +
    "        data=\"timeseries.selectedTimeseries.events\"\n" +
    "        ylabel=\"timeseries\n" +
    "          .selectedTimeseries\n" +
    "          .parameter_referenced_unit\n" +
    "          .referenced_unit_short_display_name\"\n" +
    "        xlabel=\"\"\n" +
    "        keys=\"{\n" +
    "          x: 'timestamp',\n" +
    "          y: { 'y0': 'min', 'y1': 'max' }\n" +
    "        }\"\n" +
    "        now=\"timeState.at\">\n" +
    "      </graph>\n" +
    "    </div>\n" +
    "\n" +
    "    <div class=\"timeseries-graph-container\"\n" +
    "      ng-class=\"{hidden: !fullDetails}\"\n" +
    "      ng-if=\"$parent.box.content.waterchain.layers.waterchain_grid.data.entity_name !== 'measuringstation'\">\n" +
    "      <graph\n" +
    "        line\n" +
    "        type=\"temporal\"\n" +
    "        temporal=\"timeState\"\n" +
    "        data=\"timeseries.selectedTimeseries.events\"\n" +
    "        ylabel=\"timeseries\n" +
    "          .selectedTimeseries\n" +
    "          .parameter_referenced_unit\n" +
    "          .referenced_unit_short_display_name\"\n" +
    "        xlabel=\"\"\n" +
    "        keys=\"{\n" +
    "          x: 'timestamp',\n" +
    "          y: { 'y0': 'min', 'y1': 'max' }\n" +
    "        }\"\n" +
    "        now=\"timeState.at\">\n" +
    "      </graph>\n" +
    "    </div>\n" +
    "\n" +
    "     <div class=\"card-tools\"\n" +
    "      ng-class=\"{hidden: !fullDetails}\">\n" +
    "       <a\n" +
    "         target=\"_blank\"\n" +
    "         href=\"<% timeseries.selectedTimeseries.url\n" +
    "         + 'data/?format=csv&start=' + timeState.start + '&end=' + timeState.end %>\"\n" +
    "         class=\"btn btn-default btn-xs\"\n" +
    "         title=\"<% 'Export info card data' | translate %>\">\n" +
    "         <i class=\"fa fa-share-square-o\"></i>\n" +
    "         Exporteer\n" +
    "       </a>\n" +
    "     </div>\n" +
    "\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("user-menu/user-menu.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("user-menu/user-menu.html",
    "<div>\n" +
    "\n" +
    "  <div class=\"user-menu-wrapper\">\n" +
    "\n" +
    "    <a ng-if=\"user.authenticated\"\n" +
    "       class=\"logout user\"\n" +
    "       href=\"/accounts/logout/?next=/\"\n" +
    "       title=\"<% tooltips.logout %>\"\n" +
    "       onclick=\"return logOut()\">\n" +
    "      <div class=\"pull-right\"\n" +
    "           title=\"<% tooltips.logout %>\">\n" +
    "        <i id=\"\" style=\"font-size:1.2em;\" class=\"fa fa-power-off\"></i>\n" +
    "      </div>\n" +
    "    </a>\n" +
    "\n" +
    "    <a ng-if=\"!user.authenticated\"\n" +
    "       onclick=\"logIn()\"\n" +
    "       title=\"<% tooltips.login %>\">\n" +
    "      <div class=\"clickable\" ng-cloak id=\"username\" >\n" +
    "        <i id=\"\" class=\"fa fa-user\" style=\"font-size:1.2em;\"></i>\n" +
    "        <span translate>Log in</span>\n" +
    "      </div>\n" +
    "    </a>\n" +
    "\n" +
    "\n" +
    "    <a ng-if=\"user.authenticated\"\n" +
    "       class=\"user\"\n" +
    "       title=\"<% tooltips.profile %>\"\n" +
    "       href=\"http://sso.lizard.net/edit_profile/\">\n" +
    "      <div class=\"\" ng-cloak id=\"username\" >\n" +
    "        <i id=\"\" class=\"fa fa-user\" style=\"font-size:1.2em;\"></i>\n" +
    "        <span ng-bind=\"user.firstName\"></span>\n" +
    "      </div>\n" +
    "    </a>\n" +
    "\n" +
    "  </div>\n" +
    "\n" +
    "  <a class=\"hidden-xs help\" href=\"https://www.lizard.net/support\" title=\"<% 'Question and manual' | translate %>\" target=\"_blank\">\n" +
    "    <i class=\"fa fa-question\" style=\"font-size: 1.2em\"></i>\n" +
    "  </a>\n" +
    "\n" +
    "</div>\n" +
    "");
}]);
